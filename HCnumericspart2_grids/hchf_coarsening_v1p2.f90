! gfortran -O2  hchf_coarsening_v1p2.f90
! ifort    -O2  hchf_coarsening_v1p2.f90
!*******************************************************************************
!
!     ----- Coarse-grid generation code for a HCH-Family grid -----
!
!
! This code generates a series of nested coarse grids for a grid generated by
! the following programs:
!
!     'hchf_v1p8.f90'
! 
! Note: This is not a general-purpose code.
!
! This is Version 1.1 (July 12, 2017).
!
! v1.1: PLOT3D files are now generated for strctured grids.
!------------------------------------------------------------------------------
!
!-------------
!  Input: Parameters are set in the input file named as 'input_coarsen.nml'.
!         See 'Input parameter module' below.
!
!-------------
! Output: Coarse grid files at each level, i:
!
!   (1)         .ugrid file = "hch_'element_type'.i.ugrid"
!                              with PLOT3D files [.p3d/ufmt,.nmf] for structured grids.
!   (2)         bc map file = "hch_'element_type'.i.mapbc" !Boundary condition file (FUN3D)
!   (3)      Line info file = "hch_'element_type'.i.lines_fmt"     !Lines within the B-layer
!   (4)      Line info file = "hch_'element_type'.i.lines_fmt_all" !Lines all the way.
!   (5)        k-index file = "hch_'element_type'.i.k"             !Structured indices.
!
!   (6) .rmp file =  "hch_'element_type'.i.rmp" !List of removed point coordinates.
!
!        Note: Removed point coordinates are taken from a finer grid.
!              On the boundary, these removed points are precisely on the
!              boundary. So, it can be used to construct high-order elements.
!              The files contains a list of removed points for each coarse-grid element.
!              See 'subroutine write_rmp_file_c' contained in this code.
!
!   (7)     prolong_nc file = "hch_'element_type'.(i-1).prolong_nc"
!   (8) prolong_nc_seq file = "hch_'element_type'.(i-1).prolong_nc_seq"
!
!       Note: NC prolongation information files are associated with the finer grid,
!             therefore it has (i-1) instead of i. i is the coarse level, and (i-1)
!             is the current finer level.
!
!   (9)     prolong_cc file = "hch_'element_type'.i.prolong_cc"
!
!       Note: CC prolongation information files are associated with the coarse grid.
!             It provides a list of fine-grid cells that topologically form a coarse-grid cell.
!
!       Note: Element(cell) numbers are defined in the order: tetra -> prism -> hex.
!
!  (10) Volume elements over the hc/wing surface = hch_'element_type'.i.surface.cc.c2f
!
!       Note: This file is used by this program to generate natural partition files.
!       Note: Element(cell) numbers are defined in the order: tetra -> prism -> hex.
!
!  (11) Tecplot file = "hch_'element_type'.1.tec_bndary.dat" !Boundary grid for viewing
!  (12) Tecplot file = "hch_'element_type'.1.tec_volume.dat" !Volume grid for viewing
!
!  (13)  Natural partition files = "hch_'element_type'.i.cc.ntrl_part_np"
!
!       Note: Partition derived from the regular coarsening.
!             "np" is the number of partitions.
!       Note: Element(cell) numbers are defined in the order: tetra -> prism -> hex.
!
!  (14)  Volume and heff files = "hch_'element_type'_heff_vol.txt
!
!       Note: Info on min/max/ave volumes and h_effective for both cc and nc for all grids.
!
!------------------------------------------------------------------------------
! Instruction: Example of HC grid.
!
!     1. Generate a prism/tet/mixed/mixed_ph/strct grid by 'hchf_v1p8.f90'.
!     2. Then, run this program.
!
!  Note: The total coarse grid level is determined by the input grid size.
!        The code continues to generate coarse grids until a regular coarsening
!        becomes impossible.
!
!
! [Send comments/bug-report to Hiro at hiro(at)nianet.org.]
!
!*******************************************************************************

!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!
!  Input parameter module
!
!-------------------------------------------------------------------------------
!
!  Sample input file: 'input_coarsen.nml'
!   ------------------------------------------------------
!   &input_parameters
!                      debug_mode = T
!                         project = 'wing_prism_ph'
!                       tet2prism = F
!          ugrid_file_unformatted = T
!              k_file_unformatted = T
!            rmp_file_unformatted = T
!        prolong_file_unformatted = T
!             generate_tec_file_b = T
!           generate_tec_file_vol = T
!   generate_ntrl_partition_files = T
!        generate_heff_vol_report = T
!   /
!   ------------------------------------------------------
!
!  Note: No need to specify all namelist variables.
!        In the above, those not shown are given their default values
!        as defined below.
!
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
 module input_parameter_module

  implicit none

  public

!----------------------------
! Default input values
!----------------------------

!----------------------------
! debug_mode = T: for debug use only.
!              F: Default
!
  logical :: debug_mode = .false.

!----------------------------
! project = Name of the input target-grid files:
!           'hch_prism',   'hch_tetra',   'hch_mixed',   'hch_mixed_ph', 'hch_strct'
!
!           Note: project = "hch_mixed" requires the following input files:
!           --       .ugrid file = "hch_mixed.1.ugrid"
!           -- nc line info file = "hch_mixed.1.lines_fmt"
!           -- cc line info file = "hch_mixed.1.lines_cc_fmt"
!           --      k-index file = "hch_mixed.1.k"
!
!    [These input files are assumed to have been generated by the program 'hchf_v1p8.f90'.]

  character(len=80) :: project = "hch_prism"


!----------------------------
! tet2prism = T: All-prismatic coarse grids for tetra or mixed grids.
!             F: Keep tetrahedra on coarse levels for tetra or mixed grids.
!
  logical :: tet2prism = .false.

!----------------------------
! ugrid_file_unformatted = T: .ugrid is binary   , e.g., hch_prism.1.b8.ugrid
!                          F: .ugrid is formatted, e.g., hch_prism.1.ugrid

  logical ::   ugrid_file_unformatted = .true.

!----------------------------
! k_file_unformatted = T: .k is binary
!                      F: .k is formatted

  logical ::       k_file_unformatted = .true.

!----------------------------
! Generate a file containing a list of removed nodes for each coarse grid.
! It is written in terms of a list of elements with a list
! of removed nodes for each element.

  logical ::     rmp_file_unformatted = .true.

!----------------------------
! prolong_file_unformatted = T: .prolong_cc, .prolong_nc, .prolong_nc_seq are written as binary.
!                            F: .prolong_cc, .prolong_nc, .prolong_nc_seq are written as formatted.

  logical :: prolong_file_unformatted = .true.

!----------------------------
! generate_tec_file_b = T: Write a Tecplot file, hch_'element_type'.1.tec_bndary.dat

  logical ::      generate_tec_file_b = .false.

!----------------------------
! generate_tec_file_v = T: Write a Tecplot file, hch_'element_type'.1.tec_volume.dat

  logical ::    generate_tec_file_vol = .false.

!----------------------------
! Generate natural partition files.
! Partition is based on the volume coarsening. Each partition contains the entire
! lise of cells along each line from the surface to the outer boundary.
!
! The partition file can be read as
!   read(*,*) ncells
!  do i = 1, ncells
!   read(*,*) partition_number(i)
!  end do

  logical :: generate_ntrl_partition_files = .true.

!----------------------------
! Compute and report the volume and heff information for all grids.
! A file 'hch_xxxxx_heff_vol.txt' generated for all grids, which contains
! min/max/ave volumes and h_effective for both cc and nc.

  logical ::    generate_heff_vol_report = .true.

!----------------------------
! End of Default input values
!----------------------------

  namelist / input_parameters /   &
                      debug_mode, &
                         project, &
                       tet2prism, &
          ugrid_file_unformatted, &
              k_file_unformatted, &
            rmp_file_unformatted, &
        prolong_file_unformatted, &
             generate_tec_file_b, &
           generate_tec_file_vol, &
   generate_ntrl_partition_files, &
        generate_heff_vol_report

 contains

!*****************************************************************************
!* Read input_parameters in the input file: file name = namelist_file
!*****************************************************************************
  subroutine read_nml_input_parameters(namelist_file)

  implicit none
  character(17), intent(in) :: namelist_file
  integer :: os

  write(*,*) "**************************************************************"
  write(*,*) " List of namelist variables and their values"
  write(*,*)

  open(unit=10,file=namelist_file,form='formatted',status='old',iostat=os)
  read(unit=10,nml=input_parameters)

  write(*,nml=input_parameters)
  close(10)

  end subroutine read_nml_input_parameters

 end module input_parameter_module
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!
!  End of input parameter module
!
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------


!*******************************************************************************
!*******************************************************************************
! Main program begins here.
!*******************************************************************************
!*******************************************************************************
 program regular_hcfamily_coarsening

 use input_parameter_module

 implicit none

! Parameters
  integer , parameter ::     dp = selected_real_kind(P=15)
  integer , parameter ::     kd = selected_int_kind(8)
  real(dp), parameter ::    one = 1.0_dp
  real(dp), parameter ::   half = 0.5_dp
  real(dp), parameter ::  third = 0.333333333333333333333333_dp !1/3
  real(dp), parameter ::  sixth = 0.166666666666666666666666_dp !1/6
  real(dp), parameter :: quater = 0.25_dp
  real(dp), parameter :: eighth = 0.125_dp

  integer(kd), parameter :: zero_int = 0_kd
  integer(kd), parameter ::  one_int = 1_kd
  integer(kd), parameter ::  two_int = 2_kd

  type cell_data
   real(dp) :: x,y,z       !Coordinates in xyz space
  end type cell_data

  integer(kd) :: ntria, nquad, ntet, npyr, nprs, nhex, nnodes, nprs0

  integer(kd) , dimension(:)  , allocatable :: node, k1, k2, k3, k4, k5
  integer(kd) , dimension(:,:), allocatable :: tria, quad, prs, tet, hex
  integer(kd) , dimension(:,:), allocatable :: ctria, cquad, cprs, ccprs, chex, ctet
  real(dp)    , dimension(:)  , allocatable :: xf, yf, zf
  real(dp)    , dimension(:)  , allocatable :: xc, yc, zc
  real(dp)    , dimension(:)  , allocatable :: dual_vol

  integer(kd) :: nctria_temp, nctria, ncquad_temp, ncquad, ncprs, nccprs, nchex, nctet, ncnodes, nctet0

  integer(kd) , dimension(:,:,:,:), allocatable :: k2n
  integer(kd) , dimension(:,:,:,:), allocatable :: k2nc

  integer(kd) :: k1min, k2min, k3min, k4min, k5min
  integer(kd) :: k1max, k2max, k3max, k4max, k5max
  integer(kd) :: kc1min, kc2min, kc3min, kc4min, kc5min
  integer(kd) :: kc1max, kc2max, kc3max, kc4max, kc5max
  integer(kd) :: ik1, ik2, ik3, ik4, ik5
  integer(kd) :: node1, node2, node3, node4, node5, node6, node7, node8, node9, node10
  integer(kd) :: node11, node12, node13, node14, node15, node16, node17, node18, node19, node20
  integer(kd) :: node21, node22, node23, node24, node25, node26, node27
  integer(kd) :: node_left, node_right, node_up, node_down

  integer(kd) :: rnode1, rnode2, rnode3, rnode4, rnode5, rnode7,  rnode8,  rnode9, rnode10
  integer(kd) :: rnode11, rnode12, rnode13, rnode14, rnode15, rnode16, rnode17, rnode18
  integer(kd) :: rnode19, rnode20, rnode21, rnode22, rnode23, rnode24
  integer(kd) :: rnode25, rnode26, rnode27

  integer(kd) :: cnode1, cnode2, cnode3, cnode4, cnode5, cnode6, cnode7, cnode8

  integer(kd) :: i, j, k, kk, kf, idiag, ihoriz, os, fnode, cnode, nnodes_body, nfnodes_body

  integer(kd) :: n1k1, n1k2, n1k4
  integer(kd) :: n2k1, n2k2, n2k4
  integer(kd) :: n3k1, n3k2, n3k4
  integer(kd) :: n4k1, n4k2, n4k4
  integer(kd) :: node1_above, node2_above, node3_above, node4_above

  integer(kd) :: n1k1m, n1k2m, n1k4m
  integer(kd) :: n2k1m, n2k2m, n2k4m
  integer(kd) :: n3k1m, n3k2m, n3k4m
  integer(kd) :: n4k1m, n4k2m, n4k4m
  integer(kd) :: n5k1m, n5k2m, n5k4m

  integer(kd) , dimension(:)  , allocatable :: f2c
  integer(kd) , dimension(:)  , allocatable :: kc1, kc2, kc3, kc4, kc5

  integer(kd) , dimension(:)  , allocatable :: ncnghbrs_tet
  integer(kd) , dimension(:,:), allocatable :: cnghbr_tet

  integer(kd) , dimension(:)  , allocatable :: ncelms
  integer(kd) , dimension(:,:), allocatable :: celm

  integer(kd) , dimension(:)  , allocatable :: nfelms
  integer(kd) , dimension(:,:), allocatable :: felm

  character(80) :: filename_lines_finer
  character(80) :: filename_lines_all_finer
  character(80) :: filename_ugrid_finer
  character(80) :: filename_k_finer
  character(80) :: filename_mapbc_finer
  character(80) :: filename_lines_cc_finer
  character(80) :: filename_lines_cc_all_finer

  character(80) :: filename_mapbc
  character(80) :: filename_lines
  character(80) :: filename_lines_all
  character(80) :: filename_ugrid
  character(80) :: filename_p3d
  character(80) :: filename_nmf
  character(80) :: filename_k
  character(80) :: filename_rmp
  character(80) :: filename_tecplot_b
  character(80) :: filename_tecplot_b_ep
  character(80) :: filename_tecplot_v
  character(80) :: filename_prolong_nc
  character(80) :: filename_prolong_nc_seq
  character(80) :: filename_lines_cc
  character(80) :: filename_lines_cc_all
  character(80) :: filename_prolong_cc

  character(80) :: filename02  = "debug_hc_surface"
  character(80) :: filename02s
  character(80) :: filename_heff_vol
  character(80) :: filename_c2f_cell_body

  integer(kd) :: i_count, n_lines, n_total_points, min_points, max_points, k_start
  integer(kd) :: i_count_all, n_lines_all, n_total_points_all, min_points_all, max_points_all, k_start_all

  integer(kd)      , dimension(:,:), allocatable :: fline
  integer(kd)      , dimension(:,:), allocatable :: fline_all

  character(80)               :: dummy
  character(80), dimension(6) :: dummy_v
  real(dp)                    :: x, y, z

  integer(kd) :: n_clines, n_total_cpoints, min_cpoints, max_cpoints
  integer(kd) , dimension(:,:), allocatable :: cline

  integer(kd) :: n_clines_all, n_total_cpoints_all, min_cpoints_all, max_cpoints_all
  integer(kd) , dimension(:,:), allocatable :: cline_all

  integer(kd)   :: cgrid_level_int, cgrid_level_int_f, icgrid
  character(80) :: cgrid_level_char
  character(80) :: cgrid_level_char_f
  integer(kd)   :: fgrid_level_int
  character(80) :: fgrid_level_char
  integer(kd)   :: k_start_prs

  integer(kd) , dimension(:)  , allocatable :: n_coeff
  integer(kd) , dimension(:,:), allocatable :: cnode_prolong
  real(dp)    , dimension(:,:), allocatable :: coeff_prolong

  integer(kd) , dimension(:)  , allocatable :: nccells_prolong
  integer(kd) , dimension(:,:), allocatable ::   ccell_prolong

  logical     :: mixed_ph
  integer(kd) :: nprsm_from_tets, k5_tetra
  integer(kd) :: tria_type
  logical     :: half_geom, strct_grid

  integer(kd) , dimension(:,:,:), allocatable :: k2n_p3d
  integer(kd) , dimension(:,:,:), allocatable :: k2n_p3d_temp

  logical, dimension(3) :: negative_volume_detected

  integer(kd) :: alloc_error

  integer(kd),  dimension(:)  , allocatable :: cell_above
  integer(kd),  dimension(:)  , allocatable :: cell_body

  integer(kd) :: cell_below, ncells_body, ncells_in_line, ncells_in_line_all

  type(cell_data), dimension(:),  pointer :: ccell

  integer(kd) :: n_lines_cc_all, n_total_cells_all, min_cells_all, max_cells_all

  integer(kd) , dimension(:,:), allocatable :: fline_cc_all
  integer(kd) , dimension(:,:), allocatable ::  ctria2
  integer(kd) , dimension(:,:), allocatable ::  cquad2

  integer(kd) ::  ntria_body,  nquad_body, icell, ifcell
  integer(kd) :: nctria_body, ncquad_body

  integer(kd) , dimension(4)  :: vertices
  integer(kd) , dimension(24) :: fcells_loc
  integer(kd) , dimension(4)  :: flines_incell

  integer(kd) :: i_cell_type, last_prs_location, last_cprs_location
  logical     :: ctetra, ftetra
  integer(kd) :: etype

  integer(kd) , dimension(3)  :: c3tetra

  integer(kd) :: nclayers, merged_prs_tet
  logical     :: err

  real(dp), dimension(100,0:3) :: min_evol
  real(dp), dimension(100,0:3) :: max_evol
  real(dp), dimension(100,0:3) :: ave_evol

  real(dp), dimension(100)   :: min_dvol
  real(dp), dimension(100)   :: max_dvol
  real(dp), dimension(100)   :: ave_dvol

  real(dp), dimension(100,3) :: heff_evol
  real(dp), dimension(100,3) :: heff_dvol

  integer :: ngrids, type1_rear, type2_rear
  logical :: finish_coarse_levels

  integer :: rh_ctria0, rh_nctrias, i_temp
  logical :: rear_hemi
  integer :: rh_ctet0 , rh_nctets
  integer :: rh_cprs0 , rh_ncprs

   finish_coarse_levels = .false.

      nchex = 0
   mixed_ph = .false.

   write(*,*)
   write(*,*) "----------------------------------------------------------------"
   write(*,*) "----------------------------------------------------------------"
   write(*,*) "----------------------------------------------------------------"
   write(*,*) "----------------------------------------------------------------"
   write(*,*) "----------------------------------------------------------------"
   write(*,*) " Hemisphere-Cylinder-Family (HCF) grid coarsening program"
   write(*,*) "----------------------------------------------------------------"
   write(*,*) "----------------------------------------------------------------"
   write(*,*) "----------------------------------------------------------------"
   write(*,*) "----------------------------------------------------------------"
   write(*,*) "----------------------------------------------------------------"
   write(*,*)

!*******************************************************************************
! Read the input parameters, defined in the file named as 'input_coarsen.nml'.
!*******************************************************************************

   write(*,*) "Reading the input file: input_coarsen.nml..... "
   write(*,*)
   call read_nml_input_parameters('input_coarsen.nml')
   write(*,*)

!*******************************************************************************
!*******************************************************************************
!
! Start of coarse grid generation loop.
!
!*******************************************************************************
!*******************************************************************************

  write(*,*)
  write(*,*) ">>>>>>> Begin looping over coarse grid levels....."
  write(*,*)

  ngrids = 0

  coarse_levels : do icgrid = 2, 100

  ngrids = ngrids + 1

  write(*,*)
  write(*,*)
  write(*,*)
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*)
  write(*,*) " Begin coarse-grid level = ", icgrid, " (Finest grid at level=1)"
  write(*,*)
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 1. Set up input parameters and read input files..."
  write(*,*) "**************************************************************"

  cgrid_level_int   = icgrid   ! Coarse grid level, to be generated.
  cgrid_level_int_f = icgrid-1 !  Finer grid level.

  write( cgrid_level_char  , '(i0)' ) cgrid_level_int
  write( cgrid_level_char_f, '(i0)' ) cgrid_level_int_f

 !------------------------------------------------------------
 ! Output coarse-grid file names.

  filename_mapbc        = trim(project) // trim(".") // trim(cgrid_level_char) // '.mapbc'
  filename_lines        = trim(project) // trim(".") // trim(cgrid_level_char) // '.lines_fmt'
  filename_lines_all    = trim(project) // trim(".") // trim(cgrid_level_char) // '.lines_fmt_all'
  filename_lines_cc     = trim(project) // trim(".") // trim(cgrid_level_char) // '.lines_fmt_cc'
  filename_lines_cc_all = trim(project) // trim(".") // trim(cgrid_level_char) // '.lines_fmt_cc_all'

   if (ugrid_file_unformatted) then

     if ( big_endian_io(9999) ) then
      filename_ugrid     = trim(project) // trim(".") // trim(cgrid_level_char) // '.b8.ugrid'
      filename_p3d       = trim(project) // trim(".") // trim(cgrid_level_char) // '.ufmt'
     else
      filename_ugrid     = trim(project) // trim(".") // trim(cgrid_level_char) // '.l8.ugrid'
      filename_p3d       = trim(project) // trim(".") // trim(cgrid_level_char) // '.ufmt'
     end if

   else
      filename_ugrid     = trim(project) // trim(".") // trim(cgrid_level_char) // '.ugrid'
      filename_p3d       = trim(project) // trim(".") // trim(cgrid_level_char) // '.p3d'
   endif

  filename_nmf      = trim(project) // trim(".") // trim(cgrid_level_char) // '.nmf'
  filename_k        = trim(project) // trim(".") // trim(cgrid_level_char) // '.k'
  filename_rmp      = trim(project) // trim(".") // trim(cgrid_level_char) // '.rmp'

 !Nodal prolongation file has a finer-grid number since it is a pointer from f-node to c-nodes.
  filename_prolong_nc       = &
         trim(project) // trim(".") // trim(cgrid_level_char_f) // '.prolong_nc'

  filename_prolong_nc_seq   = &
         trim(project) // trim(".") // trim(cgrid_level_char_f) // '.prolong_nc_seq'

 !Element prolongation file has a coarser-grid number since it is a pointer from a c-cell to f-cells.
  filename_prolong_cc       = &
         trim(project) // trim(".") // trim(cgrid_level_char) // '.prolong_cc'

  filename_tecplot_b = trim(project) // trim(".") // trim(cgrid_level_char) // '.tec_bndary.dat'
  filename_tecplot_v = trim(project) // trim(".") // trim(cgrid_level_char) // '.tec_volume.dat'

  filename_tecplot_b_ep = trim(project) // trim(".") // trim(cgrid_level_char_f) // '.tec_bndary_ep.dat'


  filename02s = trim(filename02) // trim(".") // trim(cgrid_level_char) // '.tec.dat'

  filename_c2f_cell_body = trim(project) // trim(".") // trim(cgrid_level_char) // '.surface.cc.c2f'

 !------------------------------------------------------------
 ! Input finer-grid file names.

  if (icgrid==2) then

   filename_lines_finer        = trim(project) // '.1.lines_fmt'
   filename_lines_all_finer    = trim(project) // '.1.lines_fmt_all'
   filename_lines_cc_finer     = trim(project) // '.1.lines_fmt_cc'
   filename_lines_cc_all_finer = trim(project) // '.1.lines_fmt_cc_all'

   if (ugrid_file_unformatted) then
     if ( big_endian_io(9999) ) then
      filename_ugrid_finer = trim(project) // '.1.b8.ugrid'
     else
      filename_ugrid_finer = trim(project) // '.1.l8.ugrid'
     endif
   else
    filename_ugrid_finer = trim(project) // '.1.ugrid'
   endif

   filename_k_finer     = trim(project) // '.1.k'

   filename_mapbc_finer = trim(project) // '.1.mapbc'

  else

   fgrid_level_int = icgrid-1 ! Finer grid level.
   write( fgrid_level_char, '(i0)' ) fgrid_level_int
   filename_lines_finer        = trim(project) // trim(".") // trim(fgrid_level_char) // '.lines_fmt'
   filename_lines_all_finer    = trim(project) // trim(".") // trim(fgrid_level_char) // '.lines_fmt_all'
   filename_lines_cc_finer     = trim(project) // trim(".") // trim(fgrid_level_char) // '.lines_fmt_cc'
   filename_lines_cc_all_finer = trim(project) // trim(".") // trim(fgrid_level_char) // '.lines_fmt_cc_all'

   if (ugrid_file_unformatted) then

     if ( big_endian_io(9999) ) then
      filename_ugrid_finer     = trim(project) // trim(".") // trim(fgrid_level_char) // '.b8.ugrid'
     else
      filename_ugrid_finer     = trim(project) // trim(".") // trim(fgrid_level_char) // '.l8.ugrid'
     end if

   else
   filename_ugrid_finer     = trim(project) // trim(".") // trim(fgrid_level_char) // '.ugrid'
   endif

   filename_k_finer         = trim(project) // trim(".") // trim(fgrid_level_char) // '.k'

   filename_mapbc_finer     = trim(project) // trim(".") // trim(fgrid_level_char) // '.mapbc'

  endif

  filename_heff_vol = trim(project) // trim("_heff_vol") // '.txt'

!*******************************************************************************
! Step 1. Read the .ugrid file
!*******************************************************************************

  write(*,*)
  write(*,*) "---------------------------------------"
  write(*,*) " Reading : ", filename_ugrid_finer

 !------------------------------------------------------------------------------
 !(1)Read an unformatted file.

  unformatted : if ( ugrid_file_unformatted ) then

   open(unit=2, file=filename_ugrid_finer, form='unformatted',access="stream", &
                                                   status="unknown", iostat=os )
   read(2) nnodes, ntria, nquad, ntet, npyr, nprs, nhex

  write(*,*) "          nnodes = ", nnodes
  write(*,*) "          prisms = ", nprs
  write(*,*) "           tetra = ", ntet
  write(*,*) "            hexa = ", nhex
  write(*,*) "         pyramid = ", npyr
  write(*,*) "       triangles = ", ntria
  write(*,*) "  quadrilaterals = ", nquad

               allocate(tria(ntria,4))
  if (nquad>0) allocate(quad(nquad,5))
  if (ntet >0) allocate(  tet(ntet,6))
  if (nprs >0) allocate(  prs(nprs,6))
  if (nhex >0) allocate(  hex(nhex,8))
               allocate(xf(nnodes), yf(nnodes), zf(nnodes))
               allocate(dual_vol(nnodes))

   do i = 1, nnodes
    read(2) xf(i), yf(i), zf(i)
   end do

  ! Triangular boundary faces
     do i = 1, ntria
      read(2) tria(i,1), tria(i,2), tria(i,3)
     end do

  ! Quad boundary faces
    if (nquad>0) then
     do i = 1, nquad
      read(2) quad(i,1), quad(i,2), quad(i,3), quad(i,4)
     end do
    endif

  ! Face tag: Boundary group number
      ntria_body = 0
     do i = 1, ntria
      read(2) tria(i,4)
      if (tria(i,4) == 1) ntria_body = ntria_body + 1
     end do

      nquad_body = 0
     do i = 1, nquad
      read(2) quad(i,5)
      if (quad(i,5) == 1) nquad_body = nquad_body + 1
     end do

  ! Tets
    if (ntet>0) then
     do i = 1, ntet
     read(2) tet(i,1), tet(i,2), tet(i,3), tet(i,4)
     end do
    endif

  ! Prisms
    if (nprs>0) then
     do i = 1, nprs
     read(2) prs(i,1), prs(i,2), prs(i,3), prs(i,4), prs(i,5), prs(i,6)
     end do
    endif

  ! Hexahedra
    if (nhex>0) then
     do i = 1, nhex
     read(2) hex(i,1), hex(i,2), hex(i,3), hex(i,4), hex(i,5), hex(i,6), hex(i,7), hex(i,8)
     end do
    endif

 !------------------------------------------------------------------------------
 !(2)Read a formatted file.

  else

   open(unit=2, file=filename_ugrid_finer, status="unknown", iostat=os)
   read(2,*) nnodes, ntria, nquad, ntet, npyr, nprs, nhex

  write(*,*) "          nnodes = ", nnodes
  write(*,*) "          prisms = ", nprs
  write(*,*) "           tetra = ", ntet
  write(*,*) "            hexa = ", nhex
  write(*,*) "         pyramid = ", npyr
  write(*,*) "       triangles = ", ntria
  write(*,*) "  quadrilaterals = ", nquad

               allocate(tria(ntria,4))
  if (nquad>0) allocate(quad(nquad,5))
  if (ntet >0) allocate(  tet(ntet,6))
  if (nprs >0) allocate(  prs(nprs,6))
  if (nhex >0) allocate(  hex(nhex,8))
               allocate(xf(nnodes), yf(nnodes), zf(nnodes))

   do i = 1, nnodes
    read(2,*) xf(i), yf(i), zf(i)
   end do

  ! Triangular boundary faces
     do i = 1, ntria
      read(2,*) tria(i,1), tria(i,2), tria(i,3)
     end do

  ! Quad boundary faces
    if (nquad>0) then
     do i = 1, nquad
      read(2,*) quad(i,1), quad(i,2), quad(i,3), quad(i,4)
     end do
    endif

  ! Face tag: Boundary group number
      ntria_body = 0
     do i = 1, ntria
      read(2,*) tria(i,4)
      if (tria(i,4) == 1) ntria_body = ntria_body + 1
     end do

      nquad_body = 0
     do i = 1, nquad
      read(2,*) quad(i,5)
     end do
      if (quad(i,5) == 1) nquad_body = nquad_body + 1

  ! Tets
    if (ntet>0) then
     do i = 1, ntet
     read(2,*) tet(i,1), tet(i,2), tet(i,3), tet(i,4)
     end do
    endif

  ! Prisms
    if (nprs>0) then
     do i = 1, nprs
     read(2,*) prs(i,1), prs(i,2), prs(i,3), prs(i,4), prs(i,5), prs(i,6)
     end do
    endif

  ! Hexahedra
    if (nhex>0) then
     do i = 1, nhex
     read(2,*) hex(i,1), hex(i,2), hex(i,3), hex(i,4), hex(i,5), hex(i,6), hex(i,7), hex(i,8)
     end do
    endif

  endif unformatted
 !------------------------------------------------------------------------------

  close(2)

 !Compute the volume and heff info and save them for the finer grid.
  if (generate_heff_vol_report) then

  nprs0 = nprs

  write(*,*)
  write(*,*) "------------------------------------------------------------------"
  write(*,*) "------------------------------------------------------------------"
  write(*,*) " Computing volume and heff for the given finer grid..... "
  write(*,*) " --- A summary will be written in the file: ", trim(filename_heff_vol)
  write(*,*)
  write(*,*) " ( To skip this, set 'generate_heff_vol_report' to be false:"
  write(*,*) "         generate_heff_vol_report = F"
  write(*,*) "   in the input file. )"
  write(*,*)

  call finer_grid_volumes(                                               &
       max_evol(icgrid-1,0), min_evol(icgrid-1,0), ave_evol(icgrid-1,0), & !Element volume
       max_dvol(icgrid-1  ), min_dvol(icgrid-1  ), ave_dvol(icgrid-1  ), & !Dual volume
       max_evol(icgrid-1,1), min_evol(icgrid-1,1), ave_evol(icgrid-1,1), & !Tet
       max_evol(icgrid-1,2), min_evol(icgrid-1,2), ave_evol(icgrid-1,2), & !Hex
       max_evol(icgrid-1,3), min_evol(icgrid-1,3), ave_evol(icgrid-1,3), & !Prism
      heff_dvol(icgrid-1,1),heff_dvol(icgrid-1,2),heff_dvol(icgrid-1,3), & !max, min, ave (dual vol)
      heff_evol(icgrid-1,1),heff_evol(icgrid-1,2),heff_evol(icgrid-1,3)  ) !max, min, ave (elm vol)
  endif

!*******************************************************************************
! Step 0. Read the .k file
!*******************************************************************************

  write(*,*)
  write(*,*) "---------------------------------------"
  write(*,*) " Reading : ", filename_k_finer

  if (k_file_unformatted) then

   open(unit=1, file=filename_k_finer, form='unformatted', status="unknown", iostat=os)
   read(1) nnodes
   allocate(node(nnodes))
   allocate(  k1(nnodes))
   allocate(  k2(nnodes))
   allocate(  k3(nnodes))
   allocate(  k4(nnodes))
   allocate(  k5(nnodes))
   do i = 1, nnodes
    read(1) node(i), k1(i), k2(i), k3(i), k4(i), k5(i)
   end do

  else

   open(unit=1, file=filename_k_finer, status="unknown", iostat=os)
   read(1,*) nnodes
   allocate(node(nnodes))
   allocate(  k1(nnodes))
   allocate(  k2(nnodes))
   allocate(  k3(nnodes))
   allocate(  k4(nnodes))
   allocate(  k5(nnodes))
   do i = 1, nnodes
    read(1,*) node(i), k1(i), k2(i), k3(i), k4(i), k5(i)
   end do

  endif

  close(1)

   k1min = minval(k1)
   k2min = minval(k2)
   k3min = minval(k3)
   k4min = minval(k4)
   k5min = minval(k5)

   k1max = maxval(k1)
   k2max = maxval(k2)
   k3max = maxval(k3)
   k4max = maxval(k4)
   k5max = maxval(k5)

   write(*,*) "k1 min max = ", k1min, k1max
   write(*,*) "k2 min max = ", k2min, k2max
   write(*,*) "k3 min max = ", k3min, k3max
   write(*,*) "k4 min max = ", k4min, k4max
   write(*,*) "k5 min max = ", k5min, k5max

!----------------------------------------------------------------------------
! Detect the type of grids and the type of geometry (full or half).

    half_geom = .false.
   strct_grid = .false.

  !---------------------
  ! Structured grid:

   strct_or_unstructured : if (k2min == 0 .and. k2max == 0) then

     strct_grid = .true.
     write(*,*)
     write(*,*) " --- This is a structured-type grid. OK."
     write(*,*) "     strct_grid = ", strct_grid

      tet2prism = .false.
     write(*,*)
     write(*,*) " --- tet2prism doesn't matter. So, we set "
     write(*,*) "     tet2prism = ", tet2prism

     if (k3min == -1) then
      half_geom = .true.
      write(*,*)
      write(*,*) " --- This is a half-geometry grid. OK. "
      write(*,*) "      half_geom = ", half_geom
     endif

  !---------------------
  ! Unstructured grid (regularly triangulated hemisphere):

   else

     half_geom = .false.
    if (k2min /= 0 .and. k2max == 0) then

      half_geom = .true.
      write(*,*)
      write(*,*) " --- This is a half-geometry grid. OK. "
      write(*,*) "      half_geom = ", half_geom

    else
      if (.not.strct_grid) write(*,*) "      half_geom = ", half_geom
    endif

   endif strct_or_unstructured

   if (.not.half_geom) then

    write(*,*)
    write(*,*) " --- This is a full geometry case. OK. "
    write(*,*) "     half_geom = ", half_geom
   
   endif

  !---------------------



!----------------------------------------------------------------------------
! Check if coarsening is possible.

  !----------------------------------------
  ! Structured grid for a half geometry:

   if (strct_grid .and. half_geom) then

    if (mod(k1max-one_int,two_int)/=zero_int .or. mod(k4max,two_int)/=zero_int .or. mod(k5max,two_int)/=zero_int) then

    !Note: k1=0 only at the apex node. Otherwise, k1=1,2,3,...,k1max in all
    !      circumferential nodes.

     write(*,*)
     if (mod(k1max-one_int,two_int)/=zero_int) write(*,*) " mod(k1max-1,2) = ", mod(k1max-one_int,two_int)," : k1max not  odd"
     if (mod(k4max  ,two_int)/=zero_int) write(*,*) " mod(k4max  ,2) = ", mod(k4max  ,two_int)," : k4max not even"
     if (mod(k5max  ,two_int)/=zero_int) write(*,*) " mod(k5max  ,2) = ", mod(k5max  ,two_int)," : k5max not even"
     write(*,*)
     write(*,*) " NOTE: k1max must be odd for regular coarsening in the"
     write(*,*) "       case of a structured grid for a half geometry."
     write(*,*)
     write(*,*) "Cannot regularly coarsen any further."
     write(*,*) "Exit coarsening. Bye."
     write(*,*) " --- Level ", icgrid, " not generated."
     write(*,*)
     write(*,*)
     write(*,*) " End of regular coarsening..."
     write(*,*) "-----------------------------------------------------------------"
     write(*,*) "-----------------------------------------------------------------"
     write(*,*)
     write(*,*)
     finish_coarse_levels = .true. !exit coarse_levels

    endif

  !----------------------------------------
  ! All other cases:

   else

    if (mod(k1max,two_int)/=0 .or. mod(k2max,two_int)/=0 .or. mod(k3max,two_int)/=0 .or. &
        mod(k4max,two_int)/=0 .or. mod(k5max,two_int)/=0                           ) then

     write(*,*)
     if (mod(k1max,two_int)/=0) write(*,*) " mod(k1max,2) = ", mod(k1max,two_int)," : k1max not even"
     if (mod(k2max,two_int)/=0) write(*,*) " mod(k2max,2) = ", mod(k2max,two_int)," : k2max not even"
     if (mod(k3max,two_int)/=0) write(*,*) " mod(k3max,2) = ", mod(k3max,two_int)," : k3max not even"
     if (mod(k4max,two_int)/=0) write(*,*) " mod(k4max,2) = ", mod(k4max,two_int)," : k4max not even"
     if (mod(k5max,two_int)/=0) write(*,*) " mod(k5max,2) = ", mod(k5max,two_int)," : k5max not even"
     write(*,*)
     write(*,*) "Cannot regularly coarsen any further."
     write(*,*) "Exit coarsening. Bye."
     write(*,*) " --- Level ", icgrid, " not generated."
     write(*,*)
     write(*,*)
     write(*,*) " End of regular coarsening..."
     write(*,*) "-----------------------------------------------------------------"
     write(*,*) "-----------------------------------------------------------------"
     write(*,*)
     write(*,*)
     finish_coarse_levels = .true. !exit coarse_levels

    endif

   endif

  if (finish_coarse_levels) exit coarse_levels

  !----------------------------------------

   write(*,*)
   write(*,*) " Allocating k2n(k1,k2,k3,k4,k5)......."
   write(*,*)
   write(*,*) "k1min, k1max = ", k1min, k1max
   write(*,*) "k2min, k2max = ", k2min, k2max
   write(*,*) "k3min, k3max = ", k3min, k3max
   write(*,*) "k4min, k4max = ", k4min, k4max
   write(*,*) "k5min, k5max = ", k5min, k5max
   write(*,*)

   allocate(k2n(k1min:k1max,k2min:k2max,k4min:k4max,k5min:k5max),stat=alloc_error)

   if (alloc_error .ne. 0) then
    write(*,*)
    write(*,*) " Couldn't allocate k2n(k1,k2,k3,k4,k5)..."
    write(*,*) " Run on a machine having more memory..... Stop"
    write(*,*)
    stop
   endif

   write(*,*) " Allocated  k2n(k1,k2,k3,k4,k5)"
   write(*,*)
   write(*,*) " Filling k2n(k1,k2,k3,k4,k5)......."

   !Initialization: If k2n is not filled, then it has -1.
    k2n = -1

   do i = 1, nnodes
    k2n(k1(i),k2(i),k4(i),k5(i)) = i
   end do
   write(*,*) " Filled  k2n(:,:,:,:)"
   write(*,*)

!*******************************************************************************

  write(*,*)
  write(*,*) " --- Elements on the body"
  write(*,*) "            triangles = ", ntria_body
  write(*,*) "       quadrilaterals = ", nquad_body
  write(*,*)

   nfnodes_body = -1

     do i = 1, ntria_body
      nfnodes_body = max( maxval(tria(i,1:3)), nfnodes_body)
     end do

     do i = 1, nquad_body
      nfnodes_body = max( maxval(quad(i,1:4)), nfnodes_body)
     end do

  write(*,*)
  write(*,*) " --- Nodes on the body"
  write(*,*) "            nnodes= ", nfnodes_body
  write(*,*)

 !------------------------------------------------------------------------------
 ! If hex elements exist, we assume that the grid is a prism-hex mixed grid.

  if (nhex > 0 .and. .not.strct_grid) then
   mixed_ph = .true.
   write(*,*)
   write(*,*) " This is a prism/hex grid..."
   write(*,*) "    mixed_ph = ", mixed_ph
   write(*,*)
  endif

  write(*,*)
  write(*,*) " Finished reading data file..."
  write(*,*)

 !------------------------------------------------------------------------------
 ! If tetrahedra are present, find the minimum k5 index of the node
 ! associated with a tetrahedron.

  k5_tetra = -1 ! No tetrahedra

  if (ntet > 0) then

    k5_tetra = 1000000 !<- Initialization

   do i = 1, ntet
    k5_tetra = min( k5_tetra, k5(tet(i,1)),k5(tet(i,2)),k5(tet(i,3)),k5(tet(i,4)) )
   end do

  endif

  write(*,*)
  write(*,*) " Minimum k5 index of the node associated with a tetrahedron:"
  write(*,*) " --- k5_tetra = ", k5_tetra
  if     (k5_tetra == 0) then
   write(*,*) " --- Finer grid is a pure tetrahedral grid. OK."
  elseif (k5_tetra  > 0) then
   write(*,*) " --- Finer grid is a tet/prism mixed grid. OK."
  else
   write(*,*) " --- Finer grid has no tetrahedra. OK."
  endif

 !------------------------------------------------------------------------------
 ! Check if all-prism coarse grids are requested by a user.

  if (icgrid == 2 .and. tet2prism) then
   write(*,*) " Oh, tet2prism = ",  tet2prism
   k5_tetra = -1
   write(*,*) " OK, so, we set k5_tetra = -1."
   write(*,*) "--> All tetrahedra will be converted to prisms on coarse grids."
   
  endif

  write(*,*)

 !-----------------------------------------------------------
 ! Tetra to temporary prisms:
 !
 ! If the input grid file has tetrahedra, convert tetrahedra
 ! to prisms over the surface having triangular elements.
 ! So, we will form an all-prism grid, and will use this
 ! prismatic grid for all coarsening operations.
 !
 ! If tet2prism = F, all coarse grids will be prismatic grids.
 ! If tet2prism = T, tetra will be reconstructed at the end.
 !

  if (ntet > 0) then

   write(*,*) " Construct temporary prism info..."
   write(*,*) "     nprs = ", nprs
   write(*,*) "     ntet = ", ntet

   write(*,*) " allocated(prs) = ", allocated(prs)

   if (allocated(prs)) deallocate(prs)
   write(*,*) " Allocating prs... nprs+ntet = ", nprs+ntet
   allocate(prs(nprs+ntet,6))
   nprs = 0
   nprsm_from_tets = 0

   write(*,*) " Allocated prs..."

 ! Generate prisms all the way from the body to the outer boundary.

  do i = 1, ntria

   node1 = tria(i,1)
   node2 = tria(i,2)
   node3 = tria(i,3)

   !Skip triangles not located on the body.
   if (k5(node1)/=0 .or. k5(node2)/=0 .or. k5(node3)/=0) cycle

   n1k1 = k1(node1)
   n1k2 = k2(node1)
   n1k4 = k4(node1)

   n2k1 = k1(node2)
   n2k2 = k2(node2)
   n2k4 = k4(node2)

   n3k1 = k1(node3)
   n3k2 = k2(node3)
   n3k4 = k4(node3)

    do k = 0, k5max-1

     node1 = tria(i,1)
     node2 = tria(i,2)
     node3 = tria(i,3)

     n1k1 = k1(node1)
     n1k2 = k2(node1)
     n1k4 = k4(node1)

     n2k1 = k1(node2)
     n2k2 = k2(node2)
     n2k4 = k4(node2)

     n3k1 = k1(node3)
     n3k2 = k2(node3)
     n3k4 = k4(node3)

     node1       = k2n(n1k1,n1k2,n1k4,k)
     node2       = k2n(n2k1,n2k2,n2k4,k)
     node3       = k2n(n3k1,n3k2,n3k4,k)

     node1_above = k2n(n1k1,n1k2,n1k4,k+1)
     node2_above = k2n(n2k1,n2k2,n2k4,k+1)
     node3_above = k2n(n3k1,n3k2,n3k4,k+1)

     nprs = nprs + 1
     prs(nprs,1) = node1
     prs(nprs,2) = node2
     prs(nprs,3) = node3
     prs(nprs,4) = node1_above
     prs(nprs,5) = node2_above
     prs(nprs,6) = node3_above

    end do

  end do

  nprsm_from_tets = nprs
  write(*,*) " Number of temporary prisms in tet region = ", nprsm_from_tets

  endif

!-----------------------------------------------------------
!-----------------------------------------------------------

! Note: At this point, we have temporary data for all-prism grid.
!       If requested, these prisms will replace the tetrahedra.
!       If not, these prism data are used only for coarsening.

!*******************************************************************************
! Step 2. Read the .lines_fmt file
!*******************************************************************************

  write(*,*)
  write(*,*) "---------------------------------------"
  write(*,*) " Reading : ", filename_lines_finer
  open(unit=3, file=filename_lines_finer, status="unknown", iostat=os)

  read(3,*)    n_lines, n_total_points, dummy
  read(3,*) min_points,     max_points, dummy

  write(*,*) "          n_lines = ", n_lines
  write(*,*) "       min_points = ", min_points
  write(*,*) "       max_points = ", max_points
  write(*,*) "   n_total_points = ", n_total_points

  allocate(fline(max_points,n_lines))

  i_count = 0

  do i = 1, n_lines

     i_count = i_count + 1

     read(3,*) max_points, (dummy_v(j),j=1,6), k
     read(3,*) fline(1,i), dummy, x, y, z

    if (max_points > 2) then
     do k = 2, max_points-1
      read(3,*) fline(k,i)
     end do
    endif

    if (max_points > 1) then
     read(3,*) fline(max_points,i), dummy, x, y, z
    endif

  end do

      dummy_v = dummy
      dummy   = dummy_v(1)
   max_points = min_points
            x = y
            y = z
            z = x

  close(3)


 ! All points in lines

  write(*,*)
  write(*,*) "---------------------------------------"
  write(*,*) " Reading : ", filename_lines_all_finer
  open(unit=3, file=filename_lines_all_finer, status="unknown", iostat=os)

  read(3,*)    n_lines_all, n_total_points_all, dummy
  read(3,*) min_points_all,     max_points_all, dummy

  write(*,*) "          n_lines = ", n_lines_all
  write(*,*) "       min_points = ", min_points_all
  write(*,*) "       max_points = ", max_points_all
  write(*,*) "   n_total_points = ", n_total_points_all

  allocate(fline_all(max_points_all,n_lines_all))

  i_count_all = 0

  do i = 1, n_lines_all

     i_count_all = i_count_all + 1

     read(3,*) max_points_all, (dummy_v(j),j=1,6), k
     read(3,*) fline_all(1,i), dummy, x, y, z

    if (max_points_all > 2) then
     do k = 2, max_points_all-1
      read(3,*) fline_all(k,i)
     end do
    endif

    if (max_points_all > 1) then
     read(3,*) fline_all(max_points_all,i), dummy, x, y, z
    endif

  end do

      dummy_v = dummy
      dummy   = dummy_v(1)
   max_points_all = min_points_all
            x = y
            y = z
            z = x

  close(3)

!-------------------------------------------------------------------------------
! Read all-cell line information:
!-------------------------------------------------------------------------------
!  All cells in lines

  write(*,*)
  write(*,*) "---------------------------------------"
  write(*,*) " Reading : ", filename_lines_cc_all_finer
  open(unit=13, file=filename_lines_cc_all_finer, status="unknown", iostat=os)

  read(13,*) n_lines_cc_all, n_total_cells_all, dummy
  read(13,*)  min_cells_all,     max_cells_all, dummy

  write(*,*) "       n_lines_cc = ",    n_lines_cc_all
  write(*,*) "        min_cells = ",     min_cells_all
  write(*,*) "        max_cells = ",     max_cells_all
  write(*,*) "    n_total_cells = ", n_total_cells_all

  allocate(fline_cc_all(max_cells_all,n_lines_cc_all))

  i_count_all = 0
  i_cell_type = 6

  do i = 1, n_lines_cc_all !This corresponds to the boundary element loop (trias, and then quads).

     i_count_all = i_count_all + 1

     read(13,*)     max_cells_all, (dummy_v(j),j=1,6), k
     read(13,*) fline_cc_all(1,i),  dummy, x, y, z

      !-----------------------------------------------------------------------
      ! To detect the transition from prism to tetra.
       if (i==1) last_prs_location = 0
       if (i==1) i_cell_type = elm_type_f(fline_cc_all(1,i))
      !-----------------------------------------------------------------------

    if (max_cells_all > 2) then
     do k = 2, max_cells_all-1
      read(13,*) fline_cc_all(k,i)

      !-----------------------------------------------------------------------
      ! Detect the transition from prism to tetra.
       if ( i == 1 .and. i_cell_type == 6 .and. elm_type_f(fline_cc_all(k,i)) == 4 ) then
        last_prs_location = k-1 !<- k-th cell is tetrahedron. So, the last prism is at k-1.
              i_cell_type = 4
       endif
      !-----------------------------------------------------------------------

     end do
    endif

    if (max_cells_all > 1) then

     read(13,*) fline_cc_all(max_cells_all,i), dummy, x, y, z

      !-----------------------------------------------------------------------
      ! Detect the transition from prism to tetra.
       if ( i == 1 .and. i_cell_type == 6 .and. elm_type_f(fline_cc_all(max_cells_all,i)) == 4 ) then
        last_prs_location = max_cells_all-1
              i_cell_type = 4
       endif
      !-----------------------------------------------------------------------

    endif

   if (i==1) then
    if ( trim(project) == "hch_mixed" ) then
     write(*,*)
     write(*,*) " This is a tet-prism mixed grid: "
     write(*,*)
     write(*,*) "   last_prs_location = ", last_prs_location
     write(*,*) "            k5_tetra = ", k5_tetra
     write(*,*)
    else
     write(*,*)
     write(*,*) " All elements are of the same type in each line: "
     write(*,*) "   last_prs_location should be zero -> ", last_prs_location
     if (last_prs_location /= 0) then
      write(*,*) "Something is wrong... Stop"
      stop
     endif
     write(*,*)
    endif
   endif

  end do

      dummy_v = dummy
      dummy   = dummy_v(1)
   max_cells_all = min_cells_all
            x = y
            y = z
            z = x

  close(13)

  write(*,*)
  write(*,*) " Just checking... (below must be zero)"
  write(*,*) "    n_lines_cc_all - (ntria_body+nquad_body) = ", n_lines_cc_all-(ntria_body+nquad_body)
  write(*,*)
  if (  n_lines_cc_all-(ntria_body+nquad_body) /= 0 )then
   write(*,*) "  Something is wrong... # of cc lines doesn't match # of elements on the surface... stop"
   stop
  endif

!-------------------------------------------------------------------------------

!*******************************************************************************
!
! Start of hemisphere-cylinder-hemisphere surface coarsening
!
!*******************************************************************************

  allocate(ncelms(nfnodes_body   ))

  if (strct_grid) then
   allocate( celm( nfnodes_body,k1max+1)) ! to accomodate many cells around the apex.
  else
   allocate( celm( nfnodes_body,10))
  endif

  ncelms = 0
   celm  = 0

!-------------------------------------------------------------------------------
! (1) Start of structured surface coarsening.
!-------------------------------------------------------------------------------

 strct_unstrct : if (strct_grid) then

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 1. Generating coarse-grid surface elements: Structured grid"
  write(*,*) "**************************************************************"

!*******************************************************************************
! (1)Surface coarsening for prism, tetra, mixed grids.
!
! Note: k1 = 0 at apex node, k1 = 1,2,3,...,k1max along the circumferential
!       direction. So, k1max is an even number in the full geometry case,
!       and an odd number in the half geometry case.
!*******************************************************************************

  write(*,*)
  write(*,*) " Coarsening the front hemisphere surface grid......."

  allocate(ctria( ntria/2,6))
  allocate(ctria2(ntria/2,6))
   nctria  = 0
    ctria  = 0
    ctria2 = 0

  allocate(cquad(  nquad/4 ,5))
  allocate(cquad2( nquad/4 ,5))
   ncquad = 0
    cquad = 0

  ik2 = 0 !Not used
  ik5 = 0 !On the body

  !k1max is even for full geometry
  !k1max is  odd for non-full geometry

  !------------------------------------------------
  !(1)Coarsen the triangular part around the apex:

   write(*,*) " - Coarsening the triangular part......."

  ! Nodes are locally ordered as follows: skip every other node.
  ! A triangualr stencil pointing away from the apex.
  !
  !              1 Apex          -- k4 = 0
  !             /|\
  !            / | \
  !           /  |  \
  !     [1]  /___|___\ [3]       -- k4 = 1
  !         /    |[4] \
  !        /     |     \
  !       /      |      \
  !      /_______|_______\       -- k4 = 2
  ! right(2)    [2]     left(3)
  !  k1+2      <-----     k1
  !
  ! Note: [x]'s are removed nodes. Store them in ctria2(:,:).
  !

    ik4 = 0 ! Apex node location

  !Note: ik1 will automatically skip k1max-1 and reach k1max instead
  !      in the half-geometry case.

   do ik1 = 1, k1max-1, 2

      node_left  = k2n(ik1  , ik2, ik4+2, ik5)

     if (ik1==k1max-1) then
      node_right = k2n(    1, ik2, ik4+2, ik5)
     else
      node_right = k2n(ik1+2, ik2, ik4+2, ik5)
     endif

     nctria = nctria + 1
     ctria(nctria,1) = 1          !apex node (assumed to be 1)
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_left  !Node 3
     ctria(nctria,5) = 1          !Boundary tag

      call add_to_celm(         1, nctria)
      call add_to_celm(node_right, nctria)
      call add_to_celm(node_left , nctria)

     !------------------------------------------------
     ! Keep the removed points
      ctria2(nctria,2) = k2n(ik1+1, ik2, ik4+2, ik5)
      ctria2(nctria,3) = k2n(ik1  , ik2, ik4+1, ik5)
      if (ik1==k1max-1) then
       node_right = k2n(    1, ik2, ik4+1, ik5)
      else
       node_right = k2n(ik1+2, ik2, ik4+1, ik5)
      endif
      ctria2(nctria,1) = node_right
      ctria2(nctria,4) = k2n(ik1+1, ik2, ik4+1, ik5) ! Center node
      ctria2(nctria,5) = 1

      call add_to_celm(ctria2(nctria,1), nctria)
      call add_to_celm(ctria2(nctria,2), nctria)
      call add_to_celm(ctria2(nctria,3), nctria)
      call add_to_celm(ctria2(nctria,4), nctria)

     !------------------------------------------------

   end do

! # of triangles on the rear hemisphere must be the same as that of the front hemisphere.
  rh_nctrias = nctria

  !------------------------------------------------
  !(2)Coarsen the quadrilateral part (for strct_grid):
  !   k4max is assumed to be an even number: e.g., k4=0,1,2,3,...4.
  !   Checked at the beginning: stop if not even.

   write(*,*) " - Coarsening the quadrilateral part......."

  ! Nodes are locally ordered as follows: skip every other node.
  !
  !          
  !           k4          k4+2
  !           node1 [4]   node4
  ! k1 --      o-----------o          ------> x  towards cylinder base
  !            |     |     |          |
  !            |     |     |          |
  !         [1]|-----------|[3]       |
  !            |     |     |          v
  !            |     |     |   Circumferential direction
  ! k1+2 --    o-----------o
  !           node2 [2]  node3


  ik2 = 0 !Not used
  ik5 = 0 !On the body

 !Must leave the last two, which form the rear tip with triangles.
   do ik4 = 2, k4max-4, 2

  !Note: ik1 will automatically skip k1max-1 and reach k1max instead
  !      in the half-geometry case.

    do ik1 = 1, k1max-1, 2

      node1 = k2n(ik1  , ik2 ,ik4  , ik5)

     if (ik1 == k1max-1) then

      node2 = k2n(    1, ik2 ,ik4  , ik5)
      node3 = k2n(    1, ik2, ik4+2, ik5)

     else

      node2 = k2n(ik1+2, ik2 ,ik4  , ik5)
      node3 = k2n(ik1+2, ik2, ik4+2, ik5)

     endif

      node4 = k2n(ik1  , ik2, ik4+2, ik5)

      ncquad = ncquad + 1
      cquad(ncquad,1) = node1
      cquad(ncquad,2) = node2
      cquad(ncquad,3) = node3
      cquad(ncquad,4) = node4
      cquad(ncquad,5) = 1

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)

     !------------------------------------------------
     ! Keep the removed points
      node1 = k2n(ik1+1, ik2 ,ik4  , ik5)
      node3 = k2n(ik1+1, ik2, ik4+2, ik5)
      node4 = k2n(ik1  , ik2, ik4+1, ik5)

     if (ik1 == k1max-1) then

      node2 = k2n(    1, ik2 ,ik4+1, ik5)

     else

      node2 = k2n(ik1+2, ik2 ,ik4+1, ik5)

     endif

      cquad2(ncquad,1) = node1
      cquad2(ncquad,2) = node2
      cquad2(ncquad,3) = node3
      cquad2(ncquad,4) = node4
      cquad2(ncquad,5) = k2n(ik1+1, ik2, ik4+1, ik5) ! Center node

      call add_to_celm(cquad2(ncquad,1), -ncquad)
      call add_to_celm(cquad2(ncquad,2), -ncquad)
      call add_to_celm(cquad2(ncquad,3), -ncquad)
      call add_to_celm(cquad2(ncquad,4), -ncquad)
      call add_to_celm(cquad2(ncquad,5), -ncquad)

     !------------------------------------------------


    end do

   end do

!-------------------------------------------------------------------------------
! End of structured surface coarsening.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------

 else

!-------------------------------------------------------------------------------
! (2) Start of unstructured surface coarsening.
!-------------------------------------------------------------------------------

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 2. Generating coarse-grid elements: prism and/or tetrahedra"
  write(*,*) "**************************************************************"

!*******************************************************************************
! (2)Surface coarsening for prism, tetra, mixed grids.
!
! Note: k1 is a coordinate along a diagonal direction over the hemisphere,
!       with minimum at lower-left and maximum at upper right regions.
!       k3 is a coordinate along the opposite diagonal direction:
!       lower-right to upper-left.
!*******************************************************************************

  write(*,*)
  write(*,*) " Coarsening the triangulation on the front hemisphere......."
  allocate(ctria( ntria/4,6))
  allocate(ctria2(ntria/4,6))
   nctria = 0
    ctria = 0

   ik4 = 0 !<- On the hemisphere
   ik5 = 0 !<- On the body

! Section #0: theta = [240->180] Clockwise

  do idiag = -2, k1min, -2
  if (half_geom) exit

   downward_tria : do ihoriz = abs(idiag), 2, -2

   ! Generate triangles pointing the apex.
   !
   !
   !   1:right _______________3:down (directed to the apex)
   !          \      /\      / 
   !        .  \    /  \    /   .
   !       .    \  /    \  /     .
   !      .      \/______\/       . 
   !     .      . \      / .      idiag+2
   ! ihoriz    .   \    /   .
   !          .     \  /     . 
   !         .       \/       idiag+1
   !        .        . 2:left
   !    ihoriz-1    .   .
   !               .     .
   !            ihorz-2   idiag
   !
   ! Note: idiag = k1, ihoriz = k3.

    ik1 = idiag
    ik3 = ihoriz
    ik2 = -(ik1+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag
    ik3 = ihoriz - 2
    ik2 = -(ik1+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag  + 2
    ik3 = ihoriz - 2
    ik2 = -(ik1+ik3)
    node_down = k2n(ik1,ik2,ik4,ik5)

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1          !Boundary tag
    ctria(nctria,6) = 1          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik1 = idiag  + 1
       ik3 = ihoriz - 1
       ik2 = -(ik1+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag
       ik3 = ihoriz - 1
       ik2 = -(ik1+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  + 1
       ik3 = ihoriz - 2
       ik2 = -(ik1+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do downward_tria

   if (abs(idiag) > 1) then

   ! Generate triangles pointing away from the apex.
   !
   !          2:right (idiag+2, ihoriz-2)
   !            / \                       . Apex
   !           /   \
   !          /     \
   !         /_______\
   !        / \      /\
   !       /   \    /  \
   !      /     \  /    \
   !     /_______\/______\
   ! 3:up                1:left
   ! (idiag, ihoriz-2)    (idiag+2, ihoriz-4)
   ! 

    upward_tria : do ihoriz = abs(idiag), 4, -2

    ik1 = idiag
    ik3 = ihoriz-2
    ik2 = -(ik1+ik3)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag+2
    ik3 = ihoriz-2
    ik2 = -(ik1+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag+2
    ik3 = ihoriz-4
    ik2 = -(ik1+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1          !Boundary tag
     ctria(nctria,6) = 2          !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik1 = idiag  + 1
       ik3 = ihoriz - 3
       ik2 = -(ik1+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  + 2
       ik3 = ihoriz - 3
       ik2 = -(ik1+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  + 1
       ik3 = ihoriz - 2
       ik2 = -(ik1+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do upward_tria

   endif

  end do

! Section #1: theta = [300->-240] Clockwise

   !
   !           _______________  ............... idiag
   !          \      /\      / 
   !        .  \    /  \    /   .
   !       .    \  /    \  /     .
   !      .      \/______\/       . 
   !     .      . \      / .    ihoriz-2  ..... idiag - 1
   !           .   \    /   .
   !          .     \  /     . 
   !         .       \/     ihoriz-1 .......... idiag - 2
   !        .        . 
   !                .   .
   !               .     .
   !                      ihoriz-2
   !

  do idiag = 2, k2max, 2
  if (half_geom) exit

   do k = idiag, 2, -2
    ihoriz = -k

    ik2 = idiag
    ik1 = ihoriz
    ik3 = -(ik1+ik2)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag
    ik1 = ihoriz + 2
    ik3 = -(ik1+ik2)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag  - 2
    ik1 = ihoriz + 2
    ik3 = -(ik1+ik2)
    node_down = k2n(ik1,ik2,ik4,ik5)

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1
    ctria(nctria,6) = 1          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik2 = idiag  - 1
       ik1 = ihoriz + 1
       ik3 = -(ik1+ik2)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag
       ik1 = ihoriz + 1
       ik3 = -(ik1+ik2)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  - 1
       ik1 = ihoriz + 2
       ik3 = -(ik1+ik2)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)
 
      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do

   if (abs(idiag) > 1) then

    do k = idiag, 4, -2
     ihoriz = -k

    ik2 = idiag
    ik1 = ihoriz+2
    ik3 = -(ik1+ik2)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag-2
    ik1 = ihoriz+2
    ik3 = -(ik1+ik2)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag-2
    ik1 = ihoriz+4
    ik3 = -(ik1+ik2)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 2          !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik2 = idiag  - 1
       ik1 = ihoriz + 3
       ik3 = -(ik1+ik2)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  - 2
       ik1 = ihoriz + 3
       ik3 = -(ik1+ik2)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  - 1
       ik1 = ihoriz + 2
       ik3 = -(ik1+ik2)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do

   endif

  end do

! Section #2: theta = [360->300] Clockwise

  do idiag = -2, k3min, -2
  if (half_geom) exit

   do ihoriz = abs(idiag), 2, -2

    ik3 = idiag
    ik2 = ihoriz
    ik1 = -(ik2+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag
    ik2 = ihoriz-2
    ik1 = -(ik2+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag+2
    ik2 = ihoriz-2
    ik1 = -(ik2+ik3)
    node_down = k2n(ik1,ik2,ik4,ik5)

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1
    ctria(nctria,6) = 1          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik3 = idiag  + 1
       ik2 = ihoriz - 1
       ik1 = -(ik2+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag
       ik2 = ihoriz - 1
       ik1 = -(ik2+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  + 1
       ik2 = ihoriz - 2
       ik1 = -(ik2+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do

   if (abs(idiag) > 1) then

    do ihoriz = abs(idiag), 4, -2

    ik3 = idiag
    ik2 = ihoriz-2
    ik1 = -(ik2+ik3)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag+2
    ik2 = ihoriz-2
    ik1 = -(ik2+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag+2
    ik2 = ihoriz-4
    ik1 = -(ik2+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 2          !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik3 = idiag  + 1
       ik2 = ihoriz - 3
       ik1 = -(ik2+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  + 2
       ik2 = ihoriz - 3
       ik1 = -(ik2+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  + 1
       ik2 = ihoriz - 2
       ik1 = -(ik2+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do

   endif

  end do

! Section #3: theta = [60->0] Clockwise

  do idiag = 2, k1max, 2

   do k = idiag, 2, -2
    ihoriz = -k

    ik1 = idiag
    ik3 = ihoriz
    ik2 = -(ik1+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag
    ik3 = ihoriz+2
    ik2 = -(ik1+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag-2
    ik3 = ihoriz+2
    ik2 = -(ik1+ik3)
    node_down = k2n(ik1,ik2,ik4,ik5)

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1
    ctria(nctria,6) = 1          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik1 = idiag  - 1
       ik3 = ihoriz + 1
       ik2 = -(ik1+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag
       ik3 = ihoriz + 1
       ik2 = -(ik1+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  - 1
       ik3 = ihoriz + 2
       ik2 = -(ik1+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do

   if (abs(idiag) > 1) then

   do k = idiag, 4, -2
    ihoriz = -k

    ik1 = idiag
    ik3 = ihoriz+2
    ik2 = -(ik1+ik3)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag-2
    ik3 = ihoriz+2
    ik2 = -(ik1+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag-2
    ik3 = ihoriz+4
    ik2 = -(ik1+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 2          !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik1 = idiag  - 1
       ik3 = ihoriz + 3
       ik2 = -(ik1+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  - 2
       ik3 = ihoriz + 3
       ik2 = -(ik1+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  - 1
       ik3 = ihoriz + 2
       ik2 = -(ik1+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do

   endif

  end do

! Section #4: theta = [120->60] Clockwise

  do idiag = -2, k2min, -2

   do ihoriz = abs(idiag), 2, -2

    ik2 = idiag
    ik1 = ihoriz
    ik3 = -(ik2+ik1)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag
    ik1 = ihoriz-2
    ik3 = -(ik2+ik1)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag+2
    ik1 = ihoriz-2
    ik3 = -(ik2+ik1)
    node_down = k2n(ik1,ik2,ik4,ik5)

    if (node_down==0 .or. node_left==0 .or. node_right==0) then
     write(*,*) " Sec4 -  Zero: ", node_down, node_left, node_right
    endif

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1
    ctria(nctria,6) = 1          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik2 = idiag  + 1
       ik1 = ihoriz - 1
       ik3 = -(ik2+ik1)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag
       ik1 = ihoriz - 1
       ik3 = -(ik2+ik1)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  + 1
       ik1 = ihoriz - 2
       ik3 = -(ik2+ik1)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do

   if (abs(idiag) > 1) then

    do ihoriz = abs(idiag), 4, -2

    ik2 = idiag
    ik1 = ihoriz-2
    ik3 = -(ik2+ik1)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag+2
    ik1 = ihoriz-2
    ik3 = -(ik2+ik1)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag+2
    ik1 = ihoriz-4
    ik3 = -(ik2+ik1)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 2          !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik2 = idiag  + 1
       ik1 = ihoriz - 3
       ik3 = -(ik2+ik1)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  + 2
       ik1 = ihoriz - 3
       ik3 = -(ik2+ik1)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  + 1
       ik1 = ihoriz - 2
       ik3 = -(ik2+ik1)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do

   endif

  end do


! Section #5: theta = [180->120] Clockwise

  do idiag = 2, k3max, 2

   do k = idiag, 2, -2
    ihoriz = -k

    ik3 = idiag
    ik2 = ihoriz
    ik1 = -(ik2+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag
    ik2 = ihoriz+2
    ik1 = -(ik2+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag-2
    ik2 = ihoriz+2
    ik1 = -(ik2+ik3)
    node_down = k2n(ik1,ik2,ik4,ik5)

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1
    ctria(nctria,6) = 1          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik3 = idiag  - 1
       ik2 = ihoriz + 1
       ik1 = -(ik2+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag
       ik2 = ihoriz + 1
       ik1 = -(ik2+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  - 1
       ik2 = ihoriz + 2
       ik1 = -(ik2+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do

   if (abs(idiag) > 1) then

   do k = idiag, 4, -2
    ihoriz = -k

    ik3 = idiag
    ik2 = ihoriz+2
    ik1 = -(ik2+ik3)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag-2
    ik2 = ihoriz+2
    ik1 = -(ik2+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag-2
    ik2 = ihoriz+4
    ik1 = -(ik2+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 2          !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik3 = idiag  - 1
       ik2 = ihoriz + 3
       ik1 = -(ik2+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  - 2 
       ik2 = ihoriz + 3
       ik1 = -(ik2+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  - 1
       ik2 = ihoriz + 2
       ik1 = -(ik2+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do

   endif

  end do

  write(*,*) " Triangles on the front hemisphere = ", nctria

! # of triangles on the rear hemisphere must be the same as that of the front hemisphere.
  rh_nctrias = nctria

!-----------------------------------------------------------------------------------
! Cylinder surface
!-----------------------------------------------------------------------------------
  write(*,*)
  write(*,*) " Coarsening the cylinder surface......."

  allocate(cquad(  nquad/3 ,5)) !nquad/4 fails for mixed grid (at outflow)... TBDbgd
  allocate(cquad2( nquad/3 ,5)) !nquad/4 fails for mixed grid (at outflow)... TBDbgd
   ncquad = 0
    cquad = 0

   k_start = 0 ! k4max=even. No adjustments needed. Do nothing.

! Regular coarsening -> k_start = 0. Love it! It's simple.

!------------------------------------------------------------------
!------------------------------------------------------------------
!------------------------------------------------------------------
  cylinder : do ik4 = k_start, k4max-2, 2
!------------------------------------------------------------------
!------------------------------------------------------------------
!------------------------------------------------------------------

  !------------------------------------------------------------------
  ! ((1)) All quadrilateral elements on the cylinder
  !------------------------------------------------------------------
   mixed_ph_cylinder_coarsen : if (mixed_ph) then
  !------------------------------------------------------------------

  ! In all sections below, nodes are ordered as follows:
  !
  !          
  !           k4          k4+2
  !           node2 [1]   node1
  ! ki   --    o-----------o          ------> x  towards cylinder base
  !            |     |     |          |
  !            |     |     |          |
  !         [2]|-----------|[4]       |
  !            |     |     |          v
  !            |     |     |   Circumferential direction
  ! ki-2 --    o-----------o
  !           node3 [3]  node4

  ! Section #0: theta = [240->180] Clockwise.
  !

    ik1 = k1min
   do ik3 = 0, k3max-2, 2
   if (half_geom) exit
    ik2 = -(ik1+ik3)

    node1 = k2n(ik1,ik2  ,ik4+2,ik5)
    node2 = k2n(ik1,ik2  ,ik4  ,ik5)
    node3 = k2n(ik1,ik2-2,ik4  ,ik5)
    node4 = k2n(ik1,ik2-2,ik4+2,ik5)

     ncquad = ncquad + 1
     cquad(ncquad,1) = node1
     cquad(ncquad,2) = node2
     cquad(ncquad,3) = node3
     cquad(ncquad,4) = node4
     cquad(ncquad,5) = 1

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)

     !------------------------------------------------
     ! Keep the removed points
       node1 = k2n(ik1,ik2  ,ik4+1,ik5)
       node2 = k2n(ik1,ik2-1,ik4  ,ik5)
       node3 = k2n(ik1,ik2-2,ik4+1,ik5)
       node4 = k2n(ik1,ik2-1,ik4+2,ik5)
       node5 = k2n(ik1,ik2-1,ik4+1,ik5)

       cquad2(ncquad,1) = node1
       cquad2(ncquad,2) = node2
       cquad2(ncquad,3) = node3
       cquad2(ncquad,4) = node4
       cquad2(ncquad,5) = node5 !Center node

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)
      call add_to_celm(node5, -ncquad)
     !------------------------------------------------

   end do

  ! Section #1: theta = [300->240] Clockwise.

    ik2 = k2max
   do ik1 = 0, k1min+2, -2
   if (half_geom) exit
    ik3 = -(ik1+ik2)

    node1 = k2n(ik1,ik2  ,ik4+2,ik5)
    node2 = k2n(ik1,ik2  ,ik4  ,ik5)
    node3 = k2n(ik1-2,ik2,ik4  ,ik5)
    node4 = k2n(ik1-2,ik2,ik4+2,ik5)

     ncquad = ncquad + 1
     cquad(ncquad,1) = node1
     cquad(ncquad,2) = node2
     cquad(ncquad,3) = node3
     cquad(ncquad,4) = node4
     cquad(ncquad,5) = 1

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)

     !------------------------------------------------
     ! Keep the removed points
       node1 = k2n(ik1  ,ik2,ik4+1,ik5)
       node2 = k2n(ik1-1,ik2,ik4  ,ik5)
       node3 = k2n(ik1-2,ik2,ik4+1,ik5)
       node4 = k2n(ik1-1,ik2,ik4+2,ik5)
       node5 = k2n(ik1-1,ik2,ik4+1,ik5)

       cquad2(ncquad,1) = node1
       cquad2(ncquad,2) = node2
       cquad2(ncquad,3) = node3
       cquad2(ncquad,4) = node4
       cquad2(ncquad,5) = node5 !Center node

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)
      call add_to_celm(node5, -ncquad)
     !------------------------------------------------

   end do

  ! Section #2: theta = [360->300] Clockwise

    ik3 = k3min
   do ik2 = 0, k2max-2, 2
   if (half_geom) exit
    ik1 = -(ik2+ik3)

    node1 = k2n(ik1  ,ik2  ,ik4+2,ik5)
    node2 = k2n(ik1  ,ik2  ,ik4  ,ik5)
    node3 = k2n(ik1-2,ik2+2,ik4  ,ik5)
    node4 = k2n(ik1-2,ik2+2,ik4+2,ik5)

     ncquad = ncquad + 1
     cquad(ncquad,1) = node1
     cquad(ncquad,2) = node2
     cquad(ncquad,3) = node3
     cquad(ncquad,4) = node4
     cquad(ncquad,5) = 1

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)

     !------------------------------------------------
     ! Keep the removed points
       node1 = k2n(ik1  ,ik2  ,ik4+1,ik5)
       node2 = k2n(ik1-1,ik2+1,ik4  ,ik5)
       node3 = k2n(ik1-2,ik2+2,ik4+1,ik5)
       node4 = k2n(ik1-1,ik2+1,ik4+2,ik5)
       node5 = k2n(ik1-1,ik2+1,ik4+1,ik5)

       cquad2(ncquad,1) = node1
       cquad2(ncquad,2) = node2
       cquad2(ncquad,3) = node3
       cquad2(ncquad,4) = node4
       cquad2(ncquad,5) = node5 !Center node

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)
      call add_to_celm(node5, -ncquad)
     !------------------------------------------------

   end do

  ! Section #3: theta = [60->0] Clockwise

    ik1 = k1max
   do ik3 = 0, k3min+2, -2
    ik2 = -(ik1+ik3)

    node1 = k2n(ik1,ik2  ,ik4+2,ik5)
    node2 = k2n(ik1,ik2  ,ik4  ,ik5)
    node3 = k2n(ik1,ik2+2,ik4  ,ik5)
    node4 = k2n(ik1,ik2+2,ik4+2,ik5)

     ncquad = ncquad + 1
     cquad(ncquad,1) = node1
     cquad(ncquad,2) = node2
     cquad(ncquad,3) = node3
     cquad(ncquad,4) = node4
     cquad(ncquad,5) = 1

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)

     !------------------------------------------------
     ! Keep the removed points
       node1 = k2n(ik1  ,ik2  ,ik4+1,ik5)
       node2 = k2n(ik1  ,ik2+1,ik4  ,ik5)
       node3 = k2n(ik1  ,ik2+2,ik4+1,ik5)
       node4 = k2n(ik1  ,ik2+1,ik4+2,ik5)
       node5 = k2n(ik1  ,ik2+1,ik4+1,ik5)

       cquad2(ncquad,1) = node1
       cquad2(ncquad,2) = node2
       cquad2(ncquad,3) = node3
       cquad2(ncquad,4) = node4
       cquad2(ncquad,5) = node5 !Center node

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)
      call add_to_celm(node5, -ncquad)
     !------------------------------------------------

   end do

  ! Section #4: theta = [120->60] Clockwise

    ik2 = k2min
   do ik1 = 0, k1max-2, 2
    ik3 = -(ik1+ik2)

    node1 = k2n(ik1  ,ik2,ik4+2,ik5)
    node2 = k2n(ik1  ,ik2,ik4  ,ik5)
    node3 = k2n(ik1+2,ik2,ik4  ,ik5)
    node4 = k2n(ik1+2,ik2,ik4+2,ik5)

     ncquad = ncquad + 1
     cquad(ncquad,1) = node1
     cquad(ncquad,2) = node2
     cquad(ncquad,3) = node3
     cquad(ncquad,4) = node4
     cquad(ncquad,5) = 1

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)

     !------------------------------------------------
     ! Keep the removed points
       node1 = k2n(ik1  ,ik2  ,ik4+1,ik5)
       node2 = k2n(ik1+1,ik2  ,ik4  ,ik5)
       node3 = k2n(ik1+2,ik2  ,ik4+1,ik5)
       node4 = k2n(ik1+1,ik2  ,ik4+2,ik5)
       node5 = k2n(ik1+1,ik2  ,ik4+1,ik5)

       cquad2(ncquad,1) = node1
       cquad2(ncquad,2) = node2
       cquad2(ncquad,3) = node3
       cquad2(ncquad,4) = node4
       cquad2(ncquad,5) = node5 !Center node

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)
      call add_to_celm(node5, -ncquad)
     !------------------------------------------------

   end do

  ! Section #5: theta = [180->120] Clockwise

    ik3 = k3max
   do ik2 = 0, k2min+2, -2
    ik1 = -(ik2+ik3)

    node1 = k2n(ik1  ,ik2  ,ik4+2,ik5)
    node2 = k2n(ik1  ,ik2  ,ik4  ,ik5)
    node3 = k2n(ik1+2,ik2-2,ik4  ,ik5)
    node4 = k2n(ik1+2,ik2-2,ik4+2,ik5)

     ncquad = ncquad + 1
     cquad(ncquad,1) = node1
     cquad(ncquad,2) = node2
     cquad(ncquad,3) = node3
     cquad(ncquad,4) = node4
     cquad(ncquad,5) = 1

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)

     !------------------------------------------------
     ! Keep the removed points
       node1 = k2n(ik1  ,ik2  ,ik4+1,ik5)
       node2 = k2n(ik1+1,ik2-1,ik4  ,ik5)
       node3 = k2n(ik1+2,ik2-2,ik4+1,ik5)
       node4 = k2n(ik1+1,ik2-1,ik4+2,ik5)
       node5 = k2n(ik1+1,ik2-1,ik4+1,ik5)

       cquad2(ncquad,1) = node1
       cquad2(ncquad,2) = node2
       cquad2(ncquad,3) = node3
       cquad2(ncquad,4) = node4
       cquad2(ncquad,5) = node5 !Center node

      call add_to_celm(node1, -ncquad)
      call add_to_celm(node2, -ncquad)
      call add_to_celm(node3, -ncquad)
      call add_to_celm(node4, -ncquad)
      call add_to_celm(node5, -ncquad)
     !------------------------------------------------

   end do
 
  !------------------------------------------------------------------
  ! ((2)) All triangular elements on the cylinder
  !------------------------------------------------------------------
  !------------------------------------------------------------------
   else mixed_ph_cylinder_coarsen
  !------------------------------------------------------------------

  !          
  !           k4          k4+2
  !           node2 [1]   node1
  !    --      o-----------o          ------> x  towards cylinder base
  !            |     |     |          |
  !            |     |[5]  |          |
  !         [2]|-----------|[4]       |
  !            |     |     |          v
  !            |     |     |   Circumferential direction
  ! -2 --      o-----------o
  !           node3 [3]  node4

  ! Form triangular elements from the quad:
  !
  !     node2      node1
  !       o----------o          ------> x  towards cylinder base
  !       |          |          |
  !       |          |          |
  !       |          |          |
  !       |          |          v
  !       |          |   Circumferential direction
  !       o----------o
  !     node3      node4

  ! Type 3 triangle
  !
  !     node2          node1
  !       o----------o          ------> x
  !       |        .            |
  !       |      .              |
  !       |    .                |
  !       |  .                  v
  !       |.          Circumferential direction
  !       o
  !     node3

  ! Type 4 triangle
  !
  !                node1
  !                  o              ------> x
  !                . |              |
  !             .    |              |
  !           .      |              |
  !         .        |              v
  !       .          |    Circumferential direction
  !      o---------- o
  !    node3         node4

  ! Section #0

    ik1 = k1min
   do ik3 = 0, k3max-2, 2
   if (half_geom) exit
    ik2 = -(ik1+ik3)

    node1 = k2n(ik1,ik2  ,ik4+2,ik5)
    node2 = k2n(ik1,ik2  ,ik4  ,ik5)
    node3 = k2n(ik1,ik2-2,ik4  ,ik5)
    node4 = k2n(ik1,ik2-2,ik4+2,ik5)

    !------------------------------------------------
    ! Removed nodes
     rnode1 = k2n(ik1,ik2  ,ik4+1,ik5)
     rnode2 = k2n(ik1,ik2-1,ik4  ,ik5)
     rnode3 = k2n(ik1,ik2-2,ik4+1,ik5)
     rnode4 = k2n(ik1,ik2-1,ik4+2,ik5)
     rnode5 = k2n(ik1,ik2-1,ik4+1,ik5) ! Center node
    !------------------------------------------------

     nctria = nctria + 1
     ctria(nctria,1) = node2
     ctria(nctria,2) = node3
     ctria(nctria,3) = node1
     ctria(nctria,5) = 1
     ctria(nctria,6) = 3

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode2
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode1
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node2, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm(rnode1, nctria)
      call add_to_celm(rnode2, nctria)
      call add_to_celm(rnode5, nctria)

     nctria = nctria + 1
     ctria(nctria,1) = node4
     ctria(nctria,2) = node1
     ctria(nctria,3) = node3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 4

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode4
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode3
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm( node4, nctria)
      call add_to_celm(rnode3, nctria)
      call add_to_celm(rnode4, nctria)
      call add_to_celm(rnode5, nctria)

   end do

  ! Section #1

    ik2 = k2max
   do ik1 = 0, k1min+2, -2
   if (half_geom) exit
    ik3 = -(ik1+ik2)

    node1 = k2n(ik1,ik2  ,ik4+2,ik5)
    node2 = k2n(ik1,ik2  ,ik4  ,ik5)
    node3 = k2n(ik1-2,ik2,ik4  ,ik5)
    node4 = k2n(ik1-2,ik2,ik4+2,ik5)

    !------------------------------------------------
    ! Removed nodes
      rnode1 = k2n(ik1  ,ik2,ik4+1,ik5)
      rnode2 = k2n(ik1-1,ik2,ik4  ,ik5)
      rnode3 = k2n(ik1-2,ik2,ik4+1,ik5)
      rnode4 = k2n(ik1-1,ik2,ik4+2,ik5)
      rnode5 = k2n(ik1-1,ik2,ik4+1,ik5) ! Center node
    !------------------------------------------------

     nctria = nctria + 1
     ctria(nctria,1) = node2
     ctria(nctria,2) = node3
     ctria(nctria,3) = node1
     ctria(nctria,5) = 1
     ctria(nctria,6) = 3

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode2
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode1
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node2, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm(rnode1, nctria)
      call add_to_celm(rnode2, nctria)
      call add_to_celm(rnode5, nctria)

     nctria = nctria + 1
     ctria(nctria,1) = node4
     ctria(nctria,2) = node1
     ctria(nctria,3) = node3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 4

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode4
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode3
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm( node4, nctria)
      call add_to_celm(rnode3, nctria)
      call add_to_celm(rnode4, nctria)
      call add_to_celm(rnode5, nctria)

   end do

  ! Section #2

    ik3 = k3min
   do ik2 = 0, k2max-2, 2
   if (half_geom) exit
    ik1 = -(ik2+ik3)

    node1 = k2n(ik1  ,ik2  ,ik4+2,ik5)
    node2 = k2n(ik1  ,ik2  ,ik4  ,ik5)
    node3 = k2n(ik1-2,ik2+2,ik4  ,ik5)
    node4 = k2n(ik1-2,ik2+2,ik4+2,ik5)

    !------------------------------------------------
    ! Removed nodes
      rnode1 = k2n(ik1  ,ik2  ,ik4+1,ik5)
      rnode2 = k2n(ik1-1,ik2+1,ik4  ,ik5)
      rnode3 = k2n(ik1-2,ik2+2,ik4+1,ik5)
      rnode4 = k2n(ik1-1,ik2+1,ik4+2,ik5)
      rnode5 = k2n(ik1-1,ik2+1,ik4+1,ik5) ! Center node
    !------------------------------------------------

     nctria = nctria + 1
     ctria(nctria,1) = node2
     ctria(nctria,2) = node3
     ctria(nctria,3) = node1
     ctria(nctria,5) = 1
     ctria(nctria,6) = 3

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode2
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode1
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node2, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm(rnode1, nctria)
      call add_to_celm(rnode2, nctria)
      call add_to_celm(rnode5, nctria)

     nctria = nctria + 1
     ctria(nctria,1) = node4
     ctria(nctria,2) = node1
     ctria(nctria,3) = node3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 4

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode4
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode3
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm( node4, nctria)
      call add_to_celm(rnode3, nctria)
      call add_to_celm(rnode4, nctria)
      call add_to_celm(rnode5, nctria)

   end do

  ! Section #3

    ik1 = k1max
   do ik3 = 0, k3min+2, -2
    ik2 = -(ik1+ik3)

    node1 = k2n(ik1,ik2  ,ik4+2,ik5)
    node2 = k2n(ik1,ik2  ,ik4  ,ik5)
    node3 = k2n(ik1,ik2+2,ik4  ,ik5)
    node4 = k2n(ik1,ik2+2,ik4+2,ik5)

    !------------------------------------------------
    ! Removed nodes
      rnode1 = k2n(ik1  ,ik2  ,ik4+1,ik5)
      rnode2 = k2n(ik1  ,ik2+1,ik4  ,ik5)
      rnode3 = k2n(ik1  ,ik2+2,ik4+1,ik5)
      rnode4 = k2n(ik1  ,ik2+1,ik4+2,ik5)
      rnode5 = k2n(ik1  ,ik2+1,ik4+1,ik5) ! Center node
    !------------------------------------------------

     nctria = nctria + 1
     ctria(nctria,1) = node2
     ctria(nctria,2) = node3
     ctria(nctria,3) = node1
     ctria(nctria,5) = 1
     ctria(nctria,6) = 3

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode2
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode1
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node2, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm(rnode1, nctria)
      call add_to_celm(rnode2, nctria)
      call add_to_celm(rnode5, nctria)

     nctria = nctria + 1
     ctria(nctria,1) = node4
     ctria(nctria,2) = node1
     ctria(nctria,3) = node3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 4

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode4
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode3
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm( node4, nctria)
      call add_to_celm(rnode3, nctria)
      call add_to_celm(rnode4, nctria)
      call add_to_celm(rnode5, nctria)

   end do

  ! Section #4

    ik2 = k2min
   do ik1 = 0, k1max-2, 2
    ik3 = -(ik1+ik2)

    node1 = k2n(ik1  ,ik2,ik4+2,ik5)
    node2 = k2n(ik1  ,ik2,ik4  ,ik5)
    node3 = k2n(ik1+2,ik2,ik4  ,ik5)
    node4 = k2n(ik1+2,ik2,ik4+2,ik5)

    !------------------------------------------------
    ! Removed nodes
      rnode1 = k2n(ik1  ,ik2  ,ik4+1,ik5)
      rnode2 = k2n(ik1+1,ik2  ,ik4  ,ik5)
      rnode3 = k2n(ik1+2,ik2  ,ik4+1,ik5)
      rnode4 = k2n(ik1+1,ik2  ,ik4+2,ik5)
      rnode5 = k2n(ik1+1,ik2  ,ik4+1,ik5) ! Center node
    !------------------------------------------------

     nctria = nctria + 1
     ctria(nctria,1) = node2
     ctria(nctria,2) = node3
     ctria(nctria,3) = node1
     ctria(nctria,5) = 1
     ctria(nctria,6) = 3

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode2
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode1
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node2, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm(rnode1, nctria)
      call add_to_celm(rnode2, nctria)
      call add_to_celm(rnode5, nctria)

     nctria = nctria + 1
     ctria(nctria,1) = node4
     ctria(nctria,2) = node1
     ctria(nctria,3) = node3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 4

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode4
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode3
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm( node4, nctria)
      call add_to_celm(rnode3, nctria)
      call add_to_celm(rnode4, nctria)
      call add_to_celm(rnode5, nctria)

   end do

  ! Section #5

    ik3 = k3max
   do ik2 = 0, k2min+2, -2
    ik1 = -(ik2+ik3)

    node1 = k2n(ik1  ,ik2  ,ik4+2,ik5)
    node2 = k2n(ik1  ,ik2  ,ik4  ,ik5)
    node3 = k2n(ik1+2,ik2-2,ik4  ,ik5)
    node4 = k2n(ik1+2,ik2-2,ik4+2,ik5)

    !------------------------------------------------
    ! Removed nodes
      rnode1 = k2n(ik1  ,ik2  ,ik4+1,ik5)
      rnode2 = k2n(ik1+1,ik2-1,ik4  ,ik5)
      rnode3 = k2n(ik1+2,ik2-2,ik4+1,ik5)
      rnode4 = k2n(ik1+1,ik2-1,ik4+2,ik5)
      rnode5 = k2n(ik1+1,ik2-1,ik4+1,ik5) ! Center node
    !------------------------------------------------

     nctria = nctria + 1
     ctria(nctria,1) = node2
     ctria(nctria,2) = node3
     ctria(nctria,3) = node1
     ctria(nctria,5) = 1
     ctria(nctria,6) = 3

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode2
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode1
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node2, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm(rnode1, nctria)
      call add_to_celm(rnode2, nctria)
      call add_to_celm(rnode5, nctria)

     nctria = nctria + 1
     ctria(nctria,1) = node4
     ctria(nctria,2) = node1
     ctria(nctria,3) = node3
     ctria(nctria,5) = 1
     ctria(nctria,6) = 4

     !------------------------------------------------
     ! Keep the removed points
       ctria2(nctria,1) = rnode4
       ctria2(nctria,2) = rnode5
       ctria2(nctria,3) = rnode3
       ctria2(nctria,5) = 0    ! Center node (do not apply)
       ctria2(nctria,6) = 3
     !------------------------------------------------

      call add_to_celm( node1, nctria)
      call add_to_celm( node3, nctria)
      call add_to_celm( node4, nctria)
      call add_to_celm(rnode3, nctria)
      call add_to_celm(rnode4, nctria)
      call add_to_celm(rnode5, nctria)

   end do
 
  !------------------------------------------------------------------
   endif mixed_ph_cylinder_coarsen
  !------------------------------------------------------------------

  end do cylinder


 endif strct_unstrct

!*******************************************************************************
! Count nnodes on the coarsened body by temporarily generating a fine-to-coarse pointer.

  allocate(f2c(nnodes))
      f2c = 0
  ncnodes = 0

  do i = 1, nctria
   do k = 1, 3
      fnode = ctria(i,k)
    if (f2c(fnode) == 0 ) then

     ncnodes = ncnodes + 1
     f2c(fnode) = ncnodes
    endif
   end do
  end do

  if (ncquad > 0) then
   do i = 1, ncquad
    do k = 1, 3
       fnode = cquad(i,k)
     if (f2c(fnode) == 0 ) then
      ncnodes = ncnodes + 1
      f2c(fnode) = ncnodes
     endif
    end do
   end do
  endif

  nnodes_body = ncnodes
          f2c = 0
      ncnodes = 0
  deallocate(f2c)

!-------------------------------------------------------------------------------
! (2) End of unstructured surface coarsening.
!-------------------------------------------------------------------------------

  write(*,*) "--- nnodes_body = ", nnodes_body
  write(*,*) "---      nctria = ", nctria
  write(*,*) "---      ncquad = ", ncquad

 !Triangles on the rear hemisphere will be numbered as
 ! i = rh_ctria0 + k, k = 1,2,3,...,rh_nctrias.
  rh_ctria0 = nctria

!*******************************************************************************
!
! End of hemisphere-cylinder surface coarsening
!
!*******************************************************************************

! At this point, we have only a hemisphere-cylinder surface grid.
!
!  Nodes     = nnodes_body
!  Triangles = ctria(1:nctria)
!  Quads     = cquad(1:ncquad)
!
! Note: Here, both ctria and cquad are based still on the fine-grid node numbers.

  nctria_body = nctria
  ncquad_body = ncquad

!*******************************************************************************
!
! Beginning of the rear hemisphere surface coarsening
!
!*******************************************************************************

!-----------------------------------------------------------------------
! Structured surface coarsening (rear hemisphere).
!-----------------------------------------------------------------------
 
 strct_unstrct_rear : if (strct_grid) then

  ik2 = 0 !Not used
  ik5 = 0 !On the body

  !k1max is even for full geometry
  !k1max is  odd for non-full geometry

  !------------------------------------------------
  !(1)Coarsen the triangular part around the apex:

   write(*,*) " - Coarsening the triangular part......."

  ! Nodes are locally ordered as follows: skip every other node.
  ! A triangualr stencil pointing away from the apex.
  !
  !              1 Apex          -- k4 = k4max
  !             /|\
  !            / | \
  !           /  |  \
  !     [1]  /___|___\ [3]       -- k4 = k4max-1
  !         /    |[4] \
  !        /     |     \
  !       /      |      \
  !      /_______|_______\       -- k4 = k4max-2
  ! right(2)    [2]     left(3)
  !  k1+2      <-----     k1
  !
  ! Note: [x]'s are removed nodes. Store them in ctria2(:,:).
  !

    ik4 = k4max ! Apex node location at rear.

  !Note: ik1 will automatically skip k1max-1 and reach k1max instead
  !      in the half-geometry case.

   do ik1 = 1, k1max-1, 2

      node_left  = k2n(ik1  , ik2, ik4-2, ik5)

     if (ik1==k1max-1) then
      node_right = k2n(    1, ik2, ik4-2, ik5)
     else
      node_right = k2n(ik1+2, ik2, ik4-2, ik5)
     endif

     nctria = nctria + 1
     ctria(nctria,1) = k2n(0,0, k4max, 0)  !apex node
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_left  !Node 3
     ctria(nctria,5) = 1          !Boundary tag

      call add_to_celm(ctria(nctria,1), nctria)
      call add_to_celm(node_right, nctria)
      call add_to_celm(node_left , nctria)

     !------------------------------------------------
     ! Keep the removed points
      ctria2(nctria,2) = k2n(ik1+1, ik2, ik4-2, ik5)
      ctria2(nctria,3) = k2n(ik1  , ik2, ik4-1, ik5)
      if (ik1==k1max-1) then
       node_right = k2n(    1, ik2, ik4-1, ik5)
      else
       node_right = k2n(ik1+2, ik2, ik4-1, ik5)
      endif
      ctria2(nctria,1) = node_right
      ctria2(nctria,4) = k2n(ik1+1, ik2, ik4-1, ik5) ! Center node
      ctria2(nctria,5) = 1

      call add_to_celm(ctria2(nctria,1), nctria)
      call add_to_celm(ctria2(nctria,2), nctria)
      call add_to_celm(ctria2(nctria,3), nctria)
      call add_to_celm(ctria2(nctria,4), nctria)

     !------------------------------------------------

   end do

!--------------------------------------------------------------------------
! End of structured surface coarsening (rear hemisphere).
!--------------------------------------------------------------------------

!--------------------------------------------------------------------------
! Unstructured surface coarsening (rear hemisphere).
!--------------------------------------------------------------------------

 else

   ik4 = k4max !<- On the rear hemisphere
   ik5 = 0     !<- On the body

   type1_rear = 1
   type2_rear = 2

! Section #0: theta = [240->180] Clockwise

  do idiag = -2, k1min, -2
  if (half_geom) exit

   downward_tria_rear : do ihoriz = abs(idiag), 2, -2

   ! Generate triangles pointing the apex.
   !
   !
   !   1:right _______________3:down (directed to the apex)
   !          \      /\      / 
   !        .  \    /  \    /   .
   !       .    \  /    \  /     .
   !      .      \/______\/       . 
   !     .      . \      / .      idiag+2
   ! ihoriz    .   \    /   .
   !          .     \  /     . 
   !         .       \/       idiag+1
   !        .        . 2:left
   !    ihoriz-1    .   .
   !               .     .
   !            ihorz-2   idiag
   !
   ! Note: idiag = k1, ihoriz = k3.

    ik1 = idiag
    ik3 = ihoriz
    ik2 = -(ik1+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag
    ik3 = ihoriz - 2
    ik2 = -(ik1+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag  + 2
    ik3 = ihoriz - 2
    ik2 = -(ik1+ik3)
    node_down = k2n(ik1,ik2,ik4,ik5)

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
!     ctria(nctria,1) = node_left  !Node 1
!     ctria(nctria,2) = node_right !Node 2
!     ctria(nctria,3) = node_up    !Node 3
    ctria(nctria,5) = 1          !Boundary tag
    ctria(nctria,6) = type1_rear          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik1 = idiag  + 1
       ik3 = ihoriz - 1
       ik2 = -(ik1+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag
       ik3 = ihoriz - 1
       ik2 = -(ik1+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  + 1
       ik3 = ihoriz - 2
       ik2 = -(ik1+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do downward_tria_rear

   if (abs(idiag) > 1) then

   ! Generate triangles pointing away from the apex.
   !
   !          2:right (idiag+2, ihoriz-2)
   !            / \                       . Apex
   !           /   \
   !          /     \
   !         /_______\
   !        / \      /\
   !       /   \    /  \
   !      /     \  /    \
   !     /_______\/______\
   ! 3:up                1:left
   ! (idiag, ihoriz-2)    (idiag+2, ihoriz-4)
   ! 

    upward_tria_rear : do ihoriz = abs(idiag), 4, -2

    ik1 = idiag
    ik3 = ihoriz-2
    ik2 = -(ik1+ik3)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag+2
    ik3 = ihoriz-2
    ik2 = -(ik1+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag+2
    ik3 = ihoriz-4
    ik2 = -(ik1+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1          !Boundary tag
     ctria(nctria,6) = type2_rear          !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik1 = idiag  + 1
       ik3 = ihoriz - 3
       ik2 = -(ik1+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  + 2
       ik3 = ihoriz - 3
       ik2 = -(ik1+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  + 1
       ik3 = ihoriz - 2
       ik2 = -(ik1+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do upward_tria_rear

   endif

  end do

! Section #1: theta = [300->-240] Clockwise

   !
   !           _______________  ............... idiag
   !          \      /\      / 
   !        .  \    /  \    /   .
   !       .    \  /    \  /     .
   !      .      \/______\/       . 
   !     .      . \      / .    ihoriz-2  ..... idiag - 1
   !           .   \    /   .
   !          .     \  /     . 
   !         .       \/     ihoriz-1 .......... idiag - 2
   !        .        . 
   !                .   .
   !               .     .
   !                      ihoriz-2
   !

  do idiag = 2, k2max, 2
  if (half_geom) exit

   do k = idiag, 2, -2
    ihoriz = -k

    ik2 = idiag
    ik1 = ihoriz
    ik3 = -(ik1+ik2)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag
    ik1 = ihoriz + 2
    ik3 = -(ik1+ik2)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag  - 2
    ik1 = ihoriz + 2
    ik3 = -(ik1+ik2)
    node_down = k2n(ik1,ik2,ik4,ik5)

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1
    ctria(nctria,6) = type1_rear          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik2 = idiag  - 1
       ik1 = ihoriz + 1
       ik3 = -(ik1+ik2)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag
       ik1 = ihoriz + 1
       ik3 = -(ik1+ik2)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  - 1
       ik1 = ihoriz + 2
       ik3 = -(ik1+ik2)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)
 
      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do

   if (abs(idiag) > 1) then

    do k = idiag, 4, -2
     ihoriz = -k

    ik2 = idiag
    ik1 = ihoriz+2
    ik3 = -(ik1+ik2)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag-2
    ik1 = ihoriz+2
    ik3 = -(ik1+ik2)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag-2
    ik1 = ihoriz+4
    ik3 = -(ik1+ik2)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1
     ctria(nctria,6) = type2_rear         !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik2 = idiag  - 1
       ik1 = ihoriz + 3
       ik3 = -(ik1+ik2)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  - 2
       ik1 = ihoriz + 3
       ik3 = -(ik1+ik2)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  - 1
       ik1 = ihoriz + 2
       ik3 = -(ik1+ik2)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do

   endif

  end do

! Section #2: theta = [360->300] Clockwise

  do idiag = -2, k3min, -2
  if (half_geom) exit

   do ihoriz = abs(idiag), 2, -2

    ik3 = idiag
    ik2 = ihoriz
    ik1 = -(ik2+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag
    ik2 = ihoriz-2
    ik1 = -(ik2+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag+2
    ik2 = ihoriz-2
    ik1 = -(ik2+ik3)
    node_down = k2n(ik1,ik2,ik4,ik5)

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1
    ctria(nctria,6) = type1_rear          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik3 = idiag  + 1
       ik2 = ihoriz - 1
       ik1 = -(ik2+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag
       ik2 = ihoriz - 1
       ik1 = -(ik2+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  + 1
       ik2 = ihoriz - 2
       ik1 = -(ik2+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do

   if (abs(idiag) > 1) then

    do ihoriz = abs(idiag), 4, -2

    ik3 = idiag
    ik2 = ihoriz-2
    ik1 = -(ik2+ik3)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag+2
    ik2 = ihoriz-2
    ik1 = -(ik2+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag+2
    ik2 = ihoriz-4
    ik1 = -(ik2+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1
     ctria(nctria,6) = type2_rear          !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik3 = idiag  + 1
       ik2 = ihoriz - 3
       ik1 = -(ik2+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  + 2
       ik2 = ihoriz - 3
       ik1 = -(ik2+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  + 1
       ik2 = ihoriz - 2
       ik1 = -(ik2+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do

   endif

  end do

! Section #3: theta = [60->0] Clockwise

  do idiag = 2, k1max, 2

   do k = idiag, 2, -2
    ihoriz = -k

    ik1 = idiag
    ik3 = ihoriz
    ik2 = -(ik1+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag
    ik3 = ihoriz+2
    ik2 = -(ik1+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag-2
    ik3 = ihoriz+2
    ik2 = -(ik1+ik3)
    node_down = k2n(ik1,ik2,ik4,ik5)

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1
    ctria(nctria,6) = type1_rear          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik1 = idiag  - 1
       ik3 = ihoriz + 1
       ik2 = -(ik1+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag
       ik3 = ihoriz + 1
       ik2 = -(ik1+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  - 1
       ik3 = ihoriz + 2
       ik2 = -(ik1+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do

   if (abs(idiag) > 1) then

   do k = idiag, 4, -2
    ihoriz = -k

    ik1 = idiag
    ik3 = ihoriz+2
    ik2 = -(ik1+ik3)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag-2
    ik3 = ihoriz+2
    ik2 = -(ik1+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik1 = idiag-2
    ik3 = ihoriz+4
    ik2 = -(ik1+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1
     ctria(nctria,6) = type2_rear          !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik1 = idiag  - 1
       ik3 = ihoriz + 3
       ik2 = -(ik1+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  - 2
       ik3 = ihoriz + 3
       ik2 = -(ik1+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik1 = idiag  - 1
       ik3 = ihoriz + 2
       ik2 = -(ik1+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do

   endif

  end do

! Section #4: theta = [120->60] Clockwise

  do idiag = -2, k2min, -2

   do ihoriz = abs(idiag), 2, -2

    ik2 = idiag
    ik1 = ihoriz
    ik3 = -(ik2+ik1)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag
    ik1 = ihoriz-2
    ik3 = -(ik2+ik1)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag+2
    ik1 = ihoriz-2
    ik3 = -(ik2+ik1)
    node_down = k2n(ik1,ik2,ik4,ik5)

    if (node_down==0 .or. node_left==0 .or. node_right==0) then
     write(*,*) " Sec4 -  Zero: ", node_down, node_left, node_right
    endif

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1
    ctria(nctria,6) = type1_rear          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik2 = idiag  + 1
       ik1 = ihoriz - 1
       ik3 = -(ik2+ik1)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag
       ik1 = ihoriz - 1
       ik3 = -(ik2+ik1)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  + 1
       ik1 = ihoriz - 2
       ik3 = -(ik2+ik1)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do

   if (abs(idiag) > 1) then

    do ihoriz = abs(idiag), 4, -2

    ik2 = idiag
    ik1 = ihoriz-2
    ik3 = -(ik2+ik1)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag+2
    ik1 = ihoriz-2
    ik3 = -(ik2+ik1)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik2 = idiag+2
    ik1 = ihoriz-4
    ik3 = -(ik2+ik1)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1
     ctria(nctria,6) = type2_rear          !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik2 = idiag  + 1
       ik1 = ihoriz - 3
       ik3 = -(ik2+ik1)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  + 2
       ik1 = ihoriz - 3
       ik3 = -(ik2+ik1)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik2 = idiag  + 1
       ik1 = ihoriz - 2
       ik3 = -(ik2+ik1)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do

   endif

  end do


! Section #5: theta = [180->120] Clockwise

  do idiag = 2, k3max, 2

   do k = idiag, 2, -2
    ihoriz = -k

    ik3 = idiag
    ik2 = ihoriz
    ik1 = -(ik2+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag
    ik2 = ihoriz+2
    ik1 = -(ik2+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag-2
    ik2 = ihoriz+2
    ik1 = -(ik2+ik3)
    node_down = k2n(ik1,ik2,ik4,ik5)

    nctria = nctria + 1
    ctria(nctria,1) = node_right !Node 1
    ctria(nctria,2) = node_left  !Node 2
    ctria(nctria,3) = node_down  !Node 3
    ctria(nctria,5) = 1
    ctria(nctria,6) = type1_rear          !Triangle type

      call add_to_celm( node_down, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik3 = idiag  - 1
       ik2 = ihoriz + 1
       ik1 = -(ik2+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag
       ik2 = ihoriz + 1
       ik1 = -(ik2+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  - 1
       ik2 = ihoriz + 2
       ik1 = -(ik2+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

   end do

   if (abs(idiag) > 1) then

   do k = idiag, 4, -2
    ihoriz = -k

    ik3 = idiag
    ik2 = ihoriz+2
    ik1 = -(ik2+ik3)
    node_up = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag-2
    ik2 = ihoriz+2
    ik1 = -(ik2+ik3)
    node_right = k2n(ik1,ik2,ik4,ik5)

    ik3 = idiag-2
    ik2 = ihoriz+4
    ik1 = -(ik2+ik3)
    node_left = k2n(ik1,ik2,ik4,ik5)

     nctria = nctria + 1
     ctria(nctria,1) = node_left  !Node 1
     ctria(nctria,2) = node_right !Node 2
     ctria(nctria,3) = node_up    !Node 3
     ctria(nctria,5) = 1
     ctria(nctria,6) = type2_rear         !Triangle type

      call add_to_celm(   node_up, nctria)
      call add_to_celm( node_left, nctria)
      call add_to_celm(node_right, nctria)

     !------------------------------------------------
     ! Keep the removed points
       ik3 = idiag  - 1
       ik2 = ihoriz + 3
       ik1 = -(ik2+ik3)
       node1 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  - 2 
       ik2 = ihoriz + 3
       ik1 = -(ik2+ik3)
       node2 = k2n(ik1,ik2,ik4,ik5)

       ik3 = idiag  - 1
       ik2 = ihoriz + 2
       ik1 = -(ik2+ik3)
       node3 = k2n(ik1,ik2,ik4,ik5)

       ctria2(nctria,1) = node2 !Removed Node 1
       ctria2(nctria,2) = node3 !Removed Node 2
       ctria2(nctria,3) = node1 !Removed Node 3
       ctria2(nctria,4) = 0     !Center node (do not apply here)

      call add_to_celm(node1, nctria)
      call add_to_celm(node2, nctria)
      call add_to_celm(node3, nctria)
     !------------------------------------------------

    end do

   endif

  end do

!--------------------------------------------------------------------------
! End of Unstructured surface coarsening (rear hemisphere).
!--------------------------------------------------------------------------

 endif strct_unstrct_rear

  write(*,*)
  write(*,*) " Adding another hemisphere at the end:"
  write(*,*) "---      nctria = ", nctria
  write(*,*) "---      ncquad = ", ncquad
  write(*,*)

!*******************************************************************************
! Write a Tecplot file for the HCH surface triangulation
! on a coarsened grid with removed nodes.
!*******************************************************************************
 debug_mode_04 : if (debug_mode) then
 open(unit=4, file=filename02s, status="unknown", iostat=os)

  write(4,*) 'TITLE = "GRID"'
  write(4,*) 'VARIABLES = "x","y","z"'

!---------------------------------------------
  write(4,*) 'ZONE T="Coarse-grid nodes" N=', nfnodes_body, &
             ',E=', nctria+ncquad,' , ET=quadrilateral, F=FEPOINT'

! Nodes
  do i = 1, nfnodes_body
    write(4,'(3ES20.10)') xf(i), yf(i), zf(i)
  end do

! Triangles
  do i = 1, nctria
   write(4,'(4I12)') ctria(i,1),ctria(i,2),ctria(i,3),ctria(i,3)
  end do

! Quads
  do i = 1, ncquad
   write(4,'(4I12)') cquad(i,1),cquad(i,2),cquad(i,3),cquad(i,4)
  end do

!---------------------------------------------
  write(4,*) 'ZONE T="Removed nodes" N=', nfnodes_body, &
             ',E=', nctria+ncquad,' , ET=quadrilateral, F=FEPOINT'

! Nodes
  do i = 1, nfnodes_body
    write(4,'(3ES20.10)') xf(i), yf(i), zf(i)
  end do

! Triangles
  do i = 1, nctria
   write(4,'(4I12)') ctria2(i,1),ctria2(i,2),ctria2(i,3),ctria2(i,3)
  end do

! Quads
  do i = 1, ncquad
   write(4,'(4I12)') cquad2(i,1),cquad2(i,2),cquad2(i,3),cquad2(i,4)
  end do

 close(4)

 write(*,*) "Tecplot file has been written: ", filename02s

 endif debug_mode_04
!*******************************************************************************

  nctria_body = nctria
  ncquad_body = ncquad

!*******************************************************************************
!
! End of the rear hemisphere surface coarsening
!
!*******************************************************************************


  ncells_body = nctria + ncquad
  allocate(cell_above(3*k5max*(ncells_body)))
  allocate(cell_body(          ncells_body ))

!-------------------------------------------------------------------------------
! Create pointers from c-grid cells to f-grid cells on the HC body:
!
! These are arrayes of size 1:nctria + ncquad:
!
!           nfelms(:) = # of fine-grid boundary cells
!      felm(:,nfelms) = the list of fine-grid boundary cells
!
!-------------------------------------------------------------------------------

  allocate(nfelms(ncells_body   ))
  allocate( felm( ncells_body, 4)) !<- Always 4 f-grid cells in a c-grid cell.
  nfelms = 0
   felm  = 0

 !------------------------------------------------------------
 ! Find c-grid cell containing each f-grid triangular cell
 ! Note: Triangle is always inside a larger triangle.

  write(*,*) " Find c-grid cell containing each f-grid triangular cell."

  do i = 1, ntria_body

           vertices(1:3) = tria(i,1:3)
                      os = find_common_ccell(vertices,3)
              nfelms(os) = nfelms(os) + 1
     felm(os,nfelms(os)) = i

  end do

  write(*,*) " minval(nfelms(:)) = ",minval(nfelms(:))
  write(*,*) " maxval(nfelms(:)) = ",maxval(nfelms(:))

 !------------------------------------------------------------
 ! Find c-grid cell containing each f-grid quadrilateral cell
 ! Note: Quad can be inside a larger triangle or quadrilateral.

  write(*,*) " Find c-grid cell containing each f-grid quadrilateral cell."

  do i = 1, nquad_body

          vertices(1:4) = quad(i,1:4)
                     os = find_common_ccell(vertices,4)

  !C-grid cell is a TRIANGLE
   if (os > 0) then

             nfelms(os) = nfelms(os) + 1
    felm(os,nfelms(os)) = -i

  !C-grid cell is a QUAD
   else

                    nfelms(nctria-os) = nfelms(nctria-os) + 1
    felm(nctria-os,nfelms(nctria-os)) = -i

   endif

  end do

  write(*,*) " minval(nfelms(:)) = ",minval(nfelms(:))
  write(*,*) " maxval(nfelms(:)) = ",maxval(nfelms(:))

!-----------------------------------------------------------------------
! Write out a file containing c2f pointers for cells over the HC body.

  open(unit=38, file=filename_c2f_cell_body, status="unknown", iostat=os)

    write(38,*) ncells_body

  !Note: felm() stores quadrilateral cell number as negative. So, we use
  ! max(0,felm(i,k))+ntria_body*min(0,felm(i,k))/felm(i,k)-min(0,felm(i,k))
  !           =            felm(i,k) for triangle
  !           = ntria_body-felm(i,k) for quadrilateral
  ! in order to generate cell numbers for 
  !    cell = 1, ntria, ntria+1, ntria+2,  ..., ntria+nquad.

   do i = 1, ncells_body
    write(38,*) nfelms(i), &
    (max(0,felm(i,k))+ntria_body*min(0,felm(i,k))/felm(i,k)-min(0,felm(i,k)), k=1,nfelms(i))
   end do

  close(38)

!-------------------------------------------------------------------------------
! End of ceate pointers from c-grid cells to f-grid cells on the HC body:
!-------------------------------------------------------------------------------

!*******************************************************************************
!
! Start of volume coarsening
!
!*******************************************************************************

  ncells_in_line_all = 0

!-------------------------------------------------------------------------------
! (1) Start of structured volume coarsening.
!-------------------------------------------------------------------------------

 strct_unstrct_v : if (strct_grid) then

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 3. Structured volume element coarsening "
  write(*,*) "**************************************************************"

 !Temporary prisms
  allocate(ccprs(nprs/2,6))
  nccprs = 0
   ccprs = 0

 !Real prisms
  allocate(cprs(nprs/2,6 + 15))! + 15 to store removed f-grid nodes.
  ncprs = 0
   cprs = 0

 !Note: This prism consists of 4 f-grid prims and 4 f-grid hexas.
 !      So, it involves 3 additional nodes a the top, middle, and bottom faces: 12+3=15.

  allocate(ctet(1,6)) !Just allocate. Not used.
  nctet = 0
 nctet0 = 0
   ctet = 0

! Prismatic elements around the apex.

    rh_nctets = 0
    rh_ncprs  = 0
    rear_hemi = .false.

  nctria_temp = nctria
  ctria_strct : do i = 1, nctria_temp

  !Record # of tets before beginning volume construction on the rear hemisphere.
   if ( i == rh_ctria0 + 1) then
    rear_hemi = .true.
    rh_cprs0  = ncprs
   endif

   node1 = ctria(i,1)
   node2 = ctria(i,2)
   node3 = ctria(i,3)

   n1k1 = k1(node1)
   n1k2 = k2(node1)
   n1k4 = k4(node1)

   n2k1 = k1(node2)
   n2k2 = k2(node2)
   n2k4 = k4(node2)

   n3k1 = k1(node3)
   n3k2 = k2(node3)
   n3k4 = k4(node3)

   !--------------------------
   ! Mid points
     rnode1 = ctria2(i,1)
     rnode2 = ctria2(i,2)
     rnode3 = ctria2(i,3)
     rnode4 = ctria2(i,4) !Node at the center of ctria.

     n1k1m = k1(rnode1)
     n1k2m = k2(rnode1)
     n1k4m = k4(rnode1)

     n2k1m = k1(rnode2)
     n2k2m = k2(rnode2)
     n2k4m = k4(rnode2)

     n3k1m = k1(rnode3)
     n3k2m = k2(rnode3)
     n3k4m = k4(rnode3)

     n4k1m = k1(rnode4)
     n4k2m = k2(rnode4)
     n4k4m = k4(rnode4)
   !--------------------------

   do k = 0, k5max-2, 2

    node1 = k2n(n1k1,n1k2,n1k4,k)
    node2 = k2n(n2k1,n2k2,n2k4,k)
    node3 = k2n(n3k1,n3k2,n3k4,k)

    node1_above = k2n(n1k1,n1k2,n1k4,k+2)
    node2_above = k2n(n2k1,n2k2,n2k4,k+2)
    node3_above = k2n(n3k1,n3k2,n3k4,k+2)
          node4 = node1_above
          node5 = node2_above
          node6 = node3_above

   !---------------------------------------
   ! Keep removed nodes
   ! 3 inbetween the c-prism nodes (mid nodes of 3 vertical edges)
     rnode7  = k2n(n1k1,n1k2,n1k4,k+1)
     rnode8  = k2n(n2k1,n2k2,n2k4,k+1)
     rnode9  = k2n(n3k1,n3k2,n3k4,k+1)

   ! 3 edge-mid-nodes on the bottom
     rnode10 = k2n(n1k1m,n1k2m,n1k4m,k)
     rnode11 = k2n(n2k1m,n2k2m,n2k4m,k)
     rnode12 = k2n(n3k1m,n3k2m,n3k4m,k)
   ! 3 edge-mid-nodes in the middle
     rnode13 = k2n(n1k1m,n1k2m,n1k4m,k+1)
     rnode14 = k2n(n2k1m,n2k2m,n2k4m,k+1)
     rnode15 = k2n(n3k1m,n3k2m,n3k4m,k+1)
   ! 3 edge-mid-nodes on the top
     rnode16 = k2n(n1k1m,n1k2m,n1k4m,k+2)
     rnode17 = k2n(n2k1m,n2k2m,n2k4m,k+2)
     rnode18 = k2n(n3k1m,n3k2m,n3k4m,k+2)

   ! 3 face-center nodes: bottom, middle, top
     rnode19 = k2n(n4k1m,n4k2m,n4k4m,k  )
     rnode20 = k2n(n4k1m,n4k2m,n4k4m,k+1)
     rnode21 = k2n(n4k1m,n4k2m,n4k4m,k+2)
   !---------------------------------------

   !Form a prism
    nccprs = nccprs + 1
    ccprs(nccprs,1) = node1
    ccprs(nccprs,2) = node2
    ccprs(nccprs,3) = node3
    ccprs(nccprs,4) = node4
    ccprs(nccprs,5) = node5
    ccprs(nccprs,6) = node6

   !Form a prism
    if (rear_hemi) rh_ncprs = rh_ncprs + 1
    ncprs = ncprs + 1
    cprs(ncprs,1)   = node1
    cprs(ncprs,2)   = node2
    cprs(ncprs,3)   = node3
    cprs(ncprs,4)   = node4
    cprs(ncprs,5)   = node5
    cprs(ncprs,6)   = node6

   !---------------------------------------
   ! Keep removed nodes
    cprs(ncprs, 7) = rnode7
    cprs(ncprs, 8) = rnode8
    cprs(ncprs, 9) = rnode9
    cprs(ncprs,10) = rnode10
    cprs(ncprs,11) = rnode11
    cprs(ncprs,12) = rnode12
    cprs(ncprs,13) = rnode13
    cprs(ncprs,14) = rnode14
    cprs(ncprs,15) = rnode15
    cprs(ncprs,16) = rnode16
    cprs(ncprs,17) = rnode17
    cprs(ncprs,18) = rnode18
    cprs(ncprs,19) = rnode19
    cprs(ncprs,20) = rnode20
    cprs(ncprs,21) = rnode21
   !---------------------------------------

    if (k==0) then
     cell_body(i) = ncprs
     cell_below   = cell_body(i)
    else
     cell_above(cell_below) = ncprs
     cell_below             = ncprs
    endif

     if (i==1) ncells_in_line_all = ncells_in_line_all + 1

   !Add a triangular boundary element at outer boundary 
    if (k == k5max-2) then

     nctria = nctria + 1
     ctria(nctria,1) = node3_above
     ctria(nctria,2) = node2_above
     ctria(nctria,3) = node1_above
     ctria(nctria,5) = 2

    endif

   end do

  end do ctria_strct

! Hexahedral elements

  allocate(chex(nhex/8, 8 + 19))! 8 + 19 vertices to store removed 19 f-grid nodes.
  nchex = 0
   chex = 0

  ncquad_temp = ncquad
  cquad_strct : do i = 1, ncquad_temp

   node1 = cquad(i,1)
   node2 = cquad(i,2)
   node3 = cquad(i,3)
   node4 = cquad(i,4)

   n1k1 = k1(node1)
   n1k2 = k2(node1)
   n1k4 = k4(node1)

   n2k1 = k1(node2)
   n2k2 = k2(node2)
   n2k4 = k4(node2)

   n3k1 = k1(node3)
   n3k2 = k2(node3)
   n3k4 = k4(node3)

   n4k1 = k1(node4)
   n4k2 = k2(node4)
   n4k4 = k4(node4)

   !--------------------------
   ! Mid points
     rnode1 = cquad2(i,1)
     rnode2 = cquad2(i,2)
     rnode3 = cquad2(i,3)
     rnode4 = cquad2(i,4)
     rnode5 = cquad2(i,5)

     n1k1m = k1(rnode1)
     n1k2m = k2(rnode1)
     n1k4m = k4(rnode1)

     n2k1m = k1(rnode2)
     n2k2m = k2(rnode2)
     n2k4m = k4(rnode2)

     n3k1m = k1(rnode3)
     n3k2m = k2(rnode3)
     n3k4m = k4(rnode3)

     n4k1m = k1(rnode4)
     n4k2m = k2(rnode4)
     n4k4m = k4(rnode4)

     n5k1m = k1(rnode5)
     n5k2m = k2(rnode5)
     n5k4m = k4(rnode5)
   !--------------------------

   do k = 0, k5max-2, 2

    node1 = k2n(n1k1,n1k2,n1k4,k)
    node2 = k2n(n2k1,n2k2,n2k4,k)
    node3 = k2n(n3k1,n3k2,n3k4,k)
    node4 = k2n(n4k1,n4k2,n4k4,k)

    node1_above = k2n(n1k1,n1k2,n1k4,k+2)
    node2_above = k2n(n2k1,n2k2,n2k4,k+2)
    node3_above = k2n(n3k1,n3k2,n3k4,k+2)
    node4_above = k2n(n4k1,n4k2,n4k4,k+2)

   !---------------------------------------
   ! Keep removed nodes
   ! 4 inbetween the c-prism nodes (mid nodes of 4 vertical edges)
     rnode9  = k2n(n1k1,n1k2,n1k4,k+1)
     rnode10 = k2n(n2k1,n2k2,n2k4,k+1)
     rnode11 = k2n(n3k1,n3k2,n3k4,k+1)
     rnode12 = k2n(n4k1,n4k2,n4k4,k+1)
   ! 4 edge-mid-nodes on the bottom
     rnode13 = k2n(n1k1m,n1k2m,n1k4m,k)
     rnode14 = k2n(n2k1m,n2k2m,n2k4m,k)
     rnode15 = k2n(n3k1m,n3k2m,n3k4m,k)
     rnode16 = k2n(n4k1m,n4k2m,n4k4m,k)
   ! 4 edge-mid-nodes in the middle (side face centers)
     rnode17 = k2n(n1k1m,n1k2m,n1k4m,k+1)
     rnode18 = k2n(n2k1m,n2k2m,n2k4m,k+1)
     rnode19 = k2n(n3k1m,n3k2m,n3k4m,k+1)
     rnode20 = k2n(n4k1m,n4k2m,n4k4m,k+1)
   ! 4 edge-mid-nodes on the top
     rnode21 = k2n(n1k1m,n1k2m,n1k4m,k+2)
     rnode22 = k2n(n2k1m,n2k2m,n2k4m,k+2)
     rnode23 = k2n(n3k1m,n3k2m,n3k4m,k+2)
     rnode24 = k2n(n4k1m,n4k2m,n4k4m,k+2)
   ! 2 at the face centers of top and bottom.
     rnode25 = k2n(n5k1m,n5k2m,n5k4m,k  )
     rnode26 = k2n(n5k1m,n5k2m,n5k4m,k+2)
   ! 1 at the center of the hexa
     rnode27 = k2n(n5k1m,n5k2m,n5k4m,k+1)
   !---------------------------------------

   !Form a hexahedron
    nchex = nchex + 1
    chex(nchex,1) = node1
    chex(nchex,2) = node2
    chex(nchex,3) = node3
    chex(nchex,4) = node4
    chex(nchex,5) = node1_above
    chex(nchex,6) = node2_above
    chex(nchex,7) = node3_above
    chex(nchex,8) = node4_above

   !---------------------------------------
   ! Keep removed nodes
     chex(nchex, 9) = rnode9
     chex(nchex,10) = rnode10
     chex(nchex,11) = rnode11
     chex(nchex,12) = rnode12
     chex(nchex,13) = rnode13
     chex(nchex,14) = rnode14
     chex(nchex,15) = rnode15
     chex(nchex,16) = rnode16
     chex(nchex,17) = rnode17
     chex(nchex,18) = rnode18
     chex(nchex,19) = rnode19
     chex(nchex,20) = rnode20
     chex(nchex,21) = rnode21
     chex(nchex,22) = rnode22
     chex(nchex,23) = rnode23
     chex(nchex,24) = rnode24
     chex(nchex,25) = rnode25
     chex(nchex,26) = rnode26
     chex(nchex,27) = rnode27
   !---------------------------------------

    if (k==0) then
     cell_body(nctria_temp+i) = ncprs + nchex            ! Cell # = 1,2,3,...,(ntet+nprs+nhex)
     cell_below               = cell_body(nctria_temp+i) ! Cell # = 1,2,3,...,(ntet+nprs+nhex)
    else
     cell_above(cell_below)   = ncprs + nchex ! Cell # = 1,2,3,...,(ntet+nprs+nhex)
     cell_below               = ncprs + nchex ! Cell # = 1,2,3,...,(ntet+nprs+nhex)
    endif

   !Add a quadrilateral boundary element at outer boundary 
    if (k == k5max-2) then

     ncquad = ncquad + 1
     cquad(ncquad,1) = node4_above
     cquad(ncquad,2) = node3_above
     cquad(ncquad,3) = node2_above
     cquad(ncquad,4) = node1_above
     cquad(ncquad,5) = 2

    endif

   end do

  end do cquad_strct

!-------------------------------------------------------------------------------
! End of structured volume coarsening.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------

 else

!-------------------------------------------------------------------------------
! (2) Start of unstructured volume coarsening.
!-------------------------------------------------------------------------------

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 3. Unstructured volume element coarsening "
  write(*,*) "**************************************************************"

!-------------------------------------------------------------------------------
! Generate prismatic/tetrahedral elements by going up from a triangular element on the
! HCH surface towards the outer boundary.
! Outer boundary elements will be defined when it reaches the outer boundary.

 allocate(ccprs(nprs/3, 6))
 nccprs = 0
  ccprs = 0

 allocate(cprs(nprs/8, 6 + 12))! 6 + 12 vertices to store removed 12 f-grid nodes.
 ncprs = 0
  cprs = 0

 allocate(ctet(ntet/4, 6 + 6)) ! + 6 to store removed f-grid nodes.
 nctet = 0
  ctet = 0

!---------------------------------------------------------------------
! Estimate the number of tetrahedra in the coarse grid.

 ![1] No tetrahedra
 if (k5_tetra < 0) then

   nctet0 = 0

 ![2] Pure tetrahedral grid
 elseif (k5_tetra == zero_int) then

  if ( mod(k5max,two_int) /= zero_int ) then
   nctet0 = 3*(nctria*((k5max-1)/2+1)) !3 tets in nctria lines of (k5max-1)/2+1 prisms.
  else
   nctet0 = 3*(nctria*k5max/2) !3 tets in nctria lines of k5max/2 prisms.
  endif

 ![3] Mixed grid. Minimum k5 of tet vertices = k5_tetra.
 else

  if ( mod(k5max-k5_tetra,two_int) /= zero_int ) then
   !If tet region is odd, then the first one will be merged into prism. So, -1 for tets.
   nctet0 = 3*(nctria*((k5max-k5_tetra-1)/2))
  else
   nctet0 = 3*(nctria*(k5max-k5_tetra)/2)
  endif

 endif
!---------------------------------------------------------------------

  write(*,*) "  nctria(inner) = ", nctria
  write(*,*) "  k5max    = ", k5max
  write(*,*) "  k5_tetra = ", k5_tetra
  write(*,*) "  # of tetrahedra (expected) = ", nctet0

! Note: At this point, only the inner body surface mesh is available.
!       So, nctria is the # of triangles over the body only.

 nctria_temp = nctria
 last_cprs_location = 0

    rh_ncprs  = 0
    rh_nctets = 0
    rear_hemi = .false.

!-------------------------------------------------------------------------------
! Loop over triangular elements on the HCH surface.

 do i = 1, nctria_temp

   tria_type = ctria(i,6)

  !Record # of tets before beginning volume construction on the rear hemisphere.
   if ( i == rh_ctria0 + 1) then
    rear_hemi = .true.
    rh_cprs0  = ncprs
    rh_ctet0  = nctet
   endif

     node1 = ctria(i,1)
     node2 = ctria(i,2)
     node3 = ctria(i,3)

     n1k1 = k1(node1)
     n1k2 = k2(node1)
     n1k4 = k4(node1)

     n2k1 = k1(node2)
     n2k2 = k2(node2)
     n2k4 = k4(node2)

     n3k1 = k1(node3)
     n3k2 = k2(node3)
     n3k4 = k4(node3)

   !--------------------------
   ! Mid points to be removed.
     rnode1 = ctria2(i,1)
     rnode2 = ctria2(i,2)
     rnode3 = ctria2(i,3)

     n1k1m = k1(rnode1)
     n1k2m = k2(rnode1)
     n1k4m = k4(rnode1)

     n2k1m = k1(rnode2)
     n2k2m = k2(rnode2)
     n2k4m = k4(rnode2)

     n3k1m = k1(rnode3)
     n3k2m = k2(rnode3)
     n3k4m = k4(rnode3)
   !--------------------------

   k = 0

 !--------------------------------------------------
 !
 !  o : Coarse grid nodes
 !  x : Removed fine-grid nodes
 !
 !                        6
 !                        o                  
 !                     .  .  .               
 !             18   .     .     .  17
 !               x        .        x         
 !            .           .           .      
 !         .              .              .   
 !      .                 . 16              .
 !   4 o------------------x------------------o 5
 !     |                  .                  |
 !     |                  x 9                |
 !     |               .  .  .               |
 !     |       15   .     .     .  14        |
 !     |         x        .        x         |
 !     |      .           .           .      |
 !     |   .              .              .   |
 !     |.                 .13               .|
 !   7 x------------------x------------------x 8
 !     |                  .                  |
 !     |                  o 3                |
 !     |               .     .               |
 !     |       12   .           .  11        |
 !     |         x                 x         |
 !     |      .                       .      |
 !     |   .                             .   |
 !     |.                                   .|
 !   1 o------------------x------------------o 2
 !                       10
 !

 !--------------------------------------------------

 ! Adjustment for non-even number of nodes.
 ! Keep the first prims layer, and start coarsening from the next one.
  if ( mod(k5max,two_int) /= zero_int ) then

   node1_above = k2n(n1k1,n1k2,n1k4,k+1)
   node2_above = k2n(n2k1,n2k2,n2k4,k+1)
   node3_above = k2n(n3k1,n3k2,n3k4,k+1)

   k_start_prs = 1
   if (i==1) write(*,*) " Odd k5max = ", k5max, " : Skip the first node."
   write(*,*) " Actually, odd k5max is not allowed. So, stop..."
   stop

 ! Begin coarsening right from the first two layes.
  else

   node1_above = k2n(n1k1,n1k2,n1k4,k+2)
   node2_above = k2n(n2k1,n2k2,n2k4,k+2)
   node3_above = k2n(n3k1,n3k2,n3k4,k+2)

   k_start_prs = 2
   if (i==1) write(*,*) " Even k5max = ", k5max

  endif

         node4 = node1_above
         node5 = node2_above
         node6 = node3_above

   !---------------------------------------
   ! Keep removed nodes
   ! 3 inbetween the c-prism nodes, along fline. (mid nodes of 3 vertical edges)
     rnode7  = k2n(n1k1,n1k2,n1k4,k+1)
     rnode8  = k2n(n2k1,n2k2,n2k4,k+1)
     rnode9  = k2n(n3k1,n3k2,n3k4,k+1)

   ! 3 edge-mid-nodes on the bottom
     rnode10 = k2n(n1k1m,n1k2m,n1k4m,k)
     rnode11 = k2n(n2k1m,n2k2m,n2k4m,k)
     rnode12 = k2n(n3k1m,n3k2m,n3k4m,k)
   ! 3 edge-mid-nodes in the middle
     rnode13 = k2n(n1k1m,n1k2m,n1k4m,k+1)
     rnode14 = k2n(n2k1m,n2k2m,n2k4m,k+1)
     rnode15 = k2n(n3k1m,n3k2m,n3k4m,k+1)
   ! 3 edge-mid-nodes on the top
     rnode16 = k2n(n1k1m,n1k2m,n1k4m,k+2)
     rnode17 = k2n(n2k1m,n2k2m,n2k4m,k+2)
     rnode18 = k2n(n3k1m,n3k2m,n3k4m,k+2)
   !---------------------------------------

  !All-prism data for later use
    nccprs = nccprs + 1
    ccprs(nccprs,1) = node1
    ccprs(nccprs,2) = node2
    ccprs(nccprs,3) = node3
    ccprs(nccprs,4) = node4
    ccprs(nccprs,5) = node5
    ccprs(nccprs,6) = node6

  !Prism
  !Note: For mixed grid, when k5_tetra=2, we have only one prism layer in the finer grid.
  !      Since we begin with k=0, there will be always one prism layer in the coarse grid.
   prism_or_tet_pre : if (k < k5_tetra .or. k5_tetra < 0) then

   !Form a prism
    if (rear_hemi) rh_ncprs = rh_ncprs + 1
    ncprs = ncprs + 1
    cprs(ncprs,1) = node1
    cprs(ncprs,2) = node2
    cprs(ncprs,3) = node3
    cprs(ncprs,4) = node4
    cprs(ncprs,5) = node5
    cprs(ncprs,6) = node6

   !---------------------------------------
   ! Keep removed nodes
    cprs(ncprs, 7) = rnode7
    cprs(ncprs, 8) = rnode8
    cprs(ncprs, 9) = rnode9
    cprs(ncprs,10) = rnode10
    cprs(ncprs,11) = rnode11
    cprs(ncprs,12) = rnode12
    cprs(ncprs,13) = rnode13
    cprs(ncprs,14) = rnode14
    cprs(ncprs,15) = rnode15
    cprs(ncprs,16) = rnode16
    cprs(ncprs,17) = rnode17
    cprs(ncprs,18) = rnode18
   !---------------------------------------

     cell_body(i) = nctet0 + ncprs
     cell_below   = cell_body(i)

    if (i==1) ncells_in_line_all = ncells_in_line_all + 1
    if (i==1) last_cprs_location = last_cprs_location + 1

  !Tetra
   else

    if (i==1) ncells_in_line_all = ncells_in_line_all + 3

     if (tria_type == 1) then

      if (rear_hemi) rh_nctets = rh_nctets + 3

      nctet = nctet + 1
      ctet(nctet,1) = node1
      ctet(nctet,2) = node2
      ctet(nctet,3) = node3
      ctet(nctet,4) = node4

       cell_body(i) = nctet
       cell_below   = cell_body(i)

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode10
      ctet(nctet, 6) = rnode11
      ctet(nctet, 7) = rnode12
      ctet(nctet, 8) = rnode7
      ctet(nctet, 9) = rnode13
      ctet(nctet,10) = rnode15
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node5
      ctet(nctet,2) = node3
      ctet(nctet,3) = node2
      ctet(nctet,4) = node4

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode14
      ctet(nctet, 6) = rnode11
      ctet(nctet, 7) = rnode8
      ctet(nctet, 8) = rnode16
      ctet(nctet, 9) = rnode15
      ctet(nctet,10) = rnode13
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node5
      ctet(nctet,2) = node6
      ctet(nctet,3) = node3
      ctet(nctet,4) = node4

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode17
      ctet(nctet, 6) = rnode9
      ctet(nctet, 7) = rnode14
      ctet(nctet, 8) = rnode16
      ctet(nctet, 9) = rnode18
      ctet(nctet,10) = rnode15
     !---------------------------------------

     elseif (tria_type == 2) then

      if (rear_hemi) rh_nctets = rh_nctets + 3

      nctet = nctet + 1
      ctet(nctet,1) = node6
      ctet(nctet,2) = node3
      ctet(nctet,3) = node2
      ctet(nctet,4) = node1

       cell_body(i) = nctet
       cell_below   = cell_body(i)

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode9
      ctet(nctet, 6) = rnode11
      ctet(nctet, 7) = rnode14
      ctet(nctet, 8) = rnode15
      ctet(nctet, 9) = rnode12
      ctet(nctet,10) = rnode10
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node5
      ctet(nctet,2) = node6
      ctet(nctet,3) = node2
      ctet(nctet,4) = node1

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode17
      ctet(nctet, 6) = rnode14
      ctet(nctet, 7) = rnode8
      ctet(nctet, 8) = rnode13
      ctet(nctet, 9) = rnode15
      ctet(nctet,10) = rnode10
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node4
      ctet(nctet,2) = node6
      ctet(nctet,3) = node5
      ctet(nctet,4) = node1

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode18
      ctet(nctet, 6) = rnode17
      ctet(nctet, 7) = rnode16
      ctet(nctet, 8) = rnode7
      ctet(nctet, 9) = rnode15
      ctet(nctet,10) = rnode13
     !---------------------------------------

     elseif (tria_type == 3) then

      nctet = nctet + 1
      ctet(nctet,1) = node1
      ctet(nctet,2) = node2
      ctet(nctet,3) = node3
      ctet(nctet,4) = node5

       cell_body(i) = nctet
       cell_below   = cell_body(i)

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode10
      ctet(nctet, 6) = rnode11
      ctet(nctet, 7) = rnode12
      ctet(nctet, 8) = rnode13
      ctet(nctet, 9) = rnode8
      ctet(nctet,10) = rnode14
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node4
      ctet(nctet,2) = node1
      ctet(nctet,3) = node3
      ctet(nctet,4) = node5

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode7
      ctet(nctet, 6) = rnode12
      ctet(nctet, 7) = rnode15
      ctet(nctet, 8) = rnode16
      ctet(nctet, 9) = rnode13
      ctet(nctet,10) = rnode14
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node6
      ctet(nctet,2) = node4
      ctet(nctet,3) = node3
      ctet(nctet,4) = node5

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode18
      ctet(nctet, 6) = rnode15
      ctet(nctet, 7) = rnode9
      ctet(nctet, 8) = rnode17
      ctet(nctet, 9) = rnode16
      ctet(nctet,10) = rnode14
     !---------------------------------------

     elseif (tria_type == 4) then

      nctet = nctet + 1
      ctet(nctet,1) = node1
      ctet(nctet,2) = node2
      ctet(nctet,3) = node3
      ctet(nctet,4) = node6

       cell_body(i) = nctet
       cell_below   = cell_body(i)

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode10
      ctet(nctet, 6) = rnode11
      ctet(nctet, 7) = rnode12
      ctet(nctet, 8) = rnode15
      ctet(nctet, 9) = rnode14
      ctet(nctet,10) = rnode9
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node4
      ctet(nctet,2) = node2
      ctet(nctet,3) = node1
      ctet(nctet,4) = node6

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode13
      ctet(nctet, 6) = rnode10
      ctet(nctet, 7) = rnode7
      ctet(nctet, 8) = rnode18
      ctet(nctet, 9) = rnode14
      ctet(nctet,10) = rnode15
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node4
      ctet(nctet,2) = node5
      ctet(nctet,3) = node2
      ctet(nctet,4) = node6

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode16
      ctet(nctet, 6) = rnode8
      ctet(nctet, 7) = rnode13
      ctet(nctet, 8) = rnode18
      ctet(nctet, 9) = rnode17
      ctet(nctet,10) = rnode14
     !---------------------------------------

     endif

    endif prism_or_tet_pre


 !--------------------------------------------------
 ! Now go up and construct elements towards the outer boundary.

  do k = k_start_prs, k5max-2, 2

  node1       = k2n(n1k1,n1k2,n1k4,k)
  node2       = k2n(n2k1,n2k2,n2k4,k)
  node3       = k2n(n3k1,n3k2,n3k4,k)

  node1_above = k2n(n1k1,n1k2,n1k4,k+2)
  node2_above = k2n(n2k1,n2k2,n2k4,k+2)
  node3_above = k2n(n3k1,n3k2,n3k4,k+2)

        node4 = node1_above
        node5 = node2_above
        node6 = node3_above

   !---------------------------------------
   ! Keep removed nodes
   ! 3 inbetween the c-prism nodes (mid nodes of 3 vertical edges)
     rnode7  = k2n(n1k1,n1k2,n1k4,k+1)
     rnode8  = k2n(n2k1,n2k2,n2k4,k+1)
     rnode9  = k2n(n3k1,n3k2,n3k4,k+1)

   ! 3 edge-mid-nodes on the bottom
     rnode10 = k2n(n1k1m,n1k2m,n1k4m,k)
     rnode11 = k2n(n2k1m,n2k2m,n2k4m,k)
     rnode12 = k2n(n3k1m,n3k2m,n3k4m,k)
   ! 3 edge-mid-nodes in the middle
     rnode13 = k2n(n1k1m,n1k2m,n1k4m,k+1)
     rnode14 = k2n(n2k1m,n2k2m,n2k4m,k+1)
     rnode15 = k2n(n3k1m,n3k2m,n3k4m,k+1)
   ! 3 edge-mid-nodes on the top
     rnode16 = k2n(n1k1m,n1k2m,n1k4m,k+2)
     rnode17 = k2n(n2k1m,n2k2m,n2k4m,k+2)
     rnode18 = k2n(n3k1m,n3k2m,n3k4m,k+2)
   !---------------------------------------

  !All-prism data for later use
    nccprs = nccprs + 1
    ccprs(nccprs,1) = node1
    ccprs(nccprs,2) = node2
    ccprs(nccprs,3) = node3
    ccprs(nccprs,4) = node4
    ccprs(nccprs,5) = node5
    ccprs(nccprs,6) = node6

  !Prism
   prism_or_tet : if (k < k5_tetra .or. k5_tetra < 0) then

    if (rear_hemi) rh_ncprs = rh_ncprs + 1
    ncprs = ncprs + 1
    cprs(ncprs,1) = node1
    cprs(ncprs,2) = node2
    cprs(ncprs,3) = node3
    cprs(ncprs,4) = node4
    cprs(ncprs,5) = node5
    cprs(ncprs,6) = node6

    cprs(ncprs, 7) = rnode7
    cprs(ncprs, 8) = rnode8
    cprs(ncprs, 9) = rnode9
    cprs(ncprs,10) = rnode10
    cprs(ncprs,11) = rnode11
    cprs(ncprs,12) = rnode12
    cprs(ncprs,13) = rnode13
    cprs(ncprs,14) = rnode14
    cprs(ncprs,15) = rnode15
    cprs(ncprs,16) = rnode16
    cprs(ncprs,17) = rnode17
    cprs(ncprs,18) = rnode18

      cell_above(cell_below) = nctet0 + ncprs
      cell_below             = nctet0 + ncprs

      if (i==1) ncells_in_line_all = ncells_in_line_all + 1
      if (i==1) last_cprs_location = last_cprs_location + 1

  !Tetra
   else

    if (i==1) ncells_in_line_all = ncells_in_line_all + 3

     if (tria_type == 1) then

      if (rear_hemi) rh_nctets = rh_nctets + 3

      nctet = nctet + 1
      ctet(nctet,1) = node1
      ctet(nctet,2) = node2
      ctet(nctet,3) = node3
      ctet(nctet,4) = node4

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode10
      ctet(nctet, 6) = rnode11
      ctet(nctet, 7) = rnode12
      ctet(nctet, 8) = rnode7
      ctet(nctet, 9) = rnode13
      ctet(nctet,10) = rnode15
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node5
      ctet(nctet,2) = node3
      ctet(nctet,3) = node2
      ctet(nctet,4) = node4

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode14
      ctet(nctet, 6) = rnode11
      ctet(nctet, 7) = rnode8
      ctet(nctet, 8) = rnode16
      ctet(nctet, 9) = rnode15
      ctet(nctet,10) = rnode13
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node5
      ctet(nctet,2) = node6
      ctet(nctet,3) = node3
      ctet(nctet,4) = node4

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode17
      ctet(nctet, 6) = rnode9
      ctet(nctet, 7) = rnode14
      ctet(nctet, 8) = rnode16
      ctet(nctet, 9) = rnode18
      ctet(nctet,10) = rnode15
     !---------------------------------------

     elseif (tria_type == 2) then

      if (rear_hemi) rh_nctets = rh_nctets + 3

      nctet = nctet + 1
      ctet(nctet,1) = node6
      ctet(nctet,2) = node3
      ctet(nctet,3) = node2
      ctet(nctet,4) = node1

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode9
      ctet(nctet, 6) = rnode11
      ctet(nctet, 7) = rnode14
      ctet(nctet, 8) = rnode15
      ctet(nctet, 9) = rnode12
      ctet(nctet,10) = rnode10
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node5
      ctet(nctet,2) = node6
      ctet(nctet,3) = node2
      ctet(nctet,4) = node1

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode17
      ctet(nctet, 6) = rnode14
      ctet(nctet, 7) = rnode8
      ctet(nctet, 8) = rnode13
      ctet(nctet, 9) = rnode15
      ctet(nctet,10) = rnode10
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node4
      ctet(nctet,2) = node6
      ctet(nctet,3) = node5
      ctet(nctet,4) = node1

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode18
      ctet(nctet, 6) = rnode17
      ctet(nctet, 7) = rnode16
      ctet(nctet, 8) = rnode7
      ctet(nctet, 9) = rnode15
      ctet(nctet,10) = rnode13
     !---------------------------------------

     elseif (tria_type == 3) then

      nctet = nctet + 1
      ctet(nctet,1) = node1
      ctet(nctet,2) = node2
      ctet(nctet,3) = node3
      ctet(nctet,4) = node5

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode10
      ctet(nctet, 6) = rnode11
      ctet(nctet, 7) = rnode12
      ctet(nctet, 8) = rnode13
      ctet(nctet, 9) = rnode8
      ctet(nctet,10) = rnode14
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node4
      ctet(nctet,2) = node1
      ctet(nctet,3) = node3
      ctet(nctet,4) = node5

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode7
      ctet(nctet, 6) = rnode12
      ctet(nctet, 7) = rnode15
      ctet(nctet, 8) = rnode16
      ctet(nctet, 9) = rnode13
      ctet(nctet,10) = rnode14
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node6
      ctet(nctet,2) = node4
      ctet(nctet,3) = node3
      ctet(nctet,4) = node5

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode18
      ctet(nctet, 6) = rnode15
      ctet(nctet, 7) = rnode9
      ctet(nctet, 8) = rnode17
      ctet(nctet, 9) = rnode16
      ctet(nctet,10) = rnode14
     !---------------------------------------

     elseif (tria_type == 4) then

      nctet = nctet + 1
      ctet(nctet,1) = node1
      ctet(nctet,2) = node2
      ctet(nctet,3) = node3
      ctet(nctet,4) = node6

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode10
      ctet(nctet, 6) = rnode11
      ctet(nctet, 7) = rnode12
      ctet(nctet, 8) = rnode15
      ctet(nctet, 9) = rnode14
      ctet(nctet,10) = rnode9
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node4
      ctet(nctet,2) = node2
      ctet(nctet,3) = node1
      ctet(nctet,4) = node6

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode13
      ctet(nctet, 6) = rnode10
      ctet(nctet, 7) = rnode7
      ctet(nctet, 8) = rnode18
      ctet(nctet, 9) = rnode14
      ctet(nctet,10) = rnode15
     !---------------------------------------

      nctet = nctet + 1
      ctet(nctet,1) = node4
      ctet(nctet,2) = node5
      ctet(nctet,3) = node2
      ctet(nctet,4) = node6

      cell_above(cell_below) = nctet
      cell_below             = nctet

     !---------------------------------------
     ! Keep removed nodes
      ctet(nctet, 5) = rnode16
      ctet(nctet, 6) = rnode8
      ctet(nctet, 7) = rnode13
      ctet(nctet, 8) = rnode18
      ctet(nctet, 9) = rnode17
      ctet(nctet,10) = rnode14
     !---------------------------------------

     endif

   endif prism_or_tet

   if (k == k5max-2) then

    nctria = nctria + 1
    ctria(nctria,1) = node3_above
    ctria(nctria,2) = node2_above
    ctria(nctria,3) = node1_above
    ctria(nctria,5) = 2

   endif

  end do

 end do


  write(*,*) " -----------------------------------------------------"
  write(*,*) " Generated tetrahedral elements....."
  write(*,*) "             # of tetrahedra = ", nctet
  write(*,*) "               check(tetra ) = ", nctet0-nctet

  if (abs(nctet0-nctet) > 0) then
   write(*,*) "  Something is wrong... Estimate is not correct..."
   write(*,*) "     abs(nctet0-nctet) == 0 ..."
   stop
  endif

!-------------------------------------------------------------------------------
! End of Loop over triangular elements on the hemisphere-cylinder surface.

!-------------------------------------------------------------------------------
! For prism-hex mixed grids, move on to coarsen the hex region (cylinder part).
! We go up from a quad element on the hemisphere-cylinder surface towards
! the outer boundary. Outer boundary elements will be defined here.

 mixed_ph_coarsening_hex : if (mixed_ph) then

 allocate(chex(nhex/8, 8 + 19))! 8 + 19 vertices to store removed 19 f-grid nodes.
 nchex = 0
  chex = 0

 ncquad_temp = ncquad
 do i = 1, ncquad_temp

   node1 = cquad(i,1)
   node2 = cquad(i,2)
   node3 = cquad(i,3)
   node4 = cquad(i,4)

   n1k1 = k1(node1)
   n1k2 = k2(node1)
   n1k4 = k4(node1)

   n2k1 = k1(node2)
   n2k2 = k2(node2)
   n2k4 = k4(node2)

   n3k1 = k1(node3)
   n3k2 = k2(node3)
   n3k4 = k4(node3)

   n4k1 = k1(node4)
   n4k2 = k2(node4)
   n4k4 = k4(node4)

   !--------------------------
   ! Mid points
     rnode1 = cquad2(i,1)
     rnode2 = cquad2(i,2)
     rnode3 = cquad2(i,3)
     rnode4 = cquad2(i,4)
     rnode5 = cquad2(i,5)

     n1k1m = k1(rnode1)
     n1k2m = k2(rnode1)
     n1k4m = k4(rnode1)

     n2k1m = k1(rnode2)
     n2k2m = k2(rnode2)
     n2k4m = k4(rnode2)

     n3k1m = k1(rnode3)
     n3k2m = k2(rnode3)
     n3k4m = k4(rnode3)

     n4k1m = k1(rnode4)
     n4k2m = k2(rnode4)
     n4k4m = k4(rnode4)

     n5k1m = k1(rnode5)
     n5k2m = k2(rnode5)
     n5k4m = k4(rnode5)
   !--------------------------

  if ( mod(k5max,two_int) /= zero_int ) then
   write(*,*) " This is not the case in the current version... Stop."
   stop
  endif

  do k = 0, k5max-2, 2

  node1       = k2n(n1k1,n1k2,n1k4,k)
  node2       = k2n(n2k1,n2k2,n2k4,k)
  node3       = k2n(n3k1,n3k2,n3k4,k)
  node4       = k2n(n4k1,n4k2,n4k4,k)

  node1_above = k2n(n1k1,n1k2,n1k4,k+2)
  node2_above = k2n(n2k1,n2k2,n2k4,k+2)
  node3_above = k2n(n3k1,n3k2,n3k4,k+2)
  node4_above = k2n(n4k1,n4k2,n4k4,k+2)

   !---------------------------------------
   ! Keep removed nodes
   ! 4 inbetween the c-prism nodes (mid nodes of 4 vertical edges)
     rnode9  = k2n(n1k1,n1k2,n1k4,k+1)
     rnode10 = k2n(n2k1,n2k2,n2k4,k+1)
     rnode11 = k2n(n3k1,n3k2,n3k4,k+1)
     rnode12 = k2n(n4k1,n4k2,n4k4,k+1)
   ! 4 edge-mid-nodes on the bottom
     rnode13 = k2n(n1k1m,n1k2m,n1k4m,k)
     rnode14 = k2n(n2k1m,n2k2m,n2k4m,k)
     rnode15 = k2n(n3k1m,n3k2m,n3k4m,k)
     rnode16 = k2n(n4k1m,n4k2m,n4k4m,k)
   ! 4 edge-mid-nodes in the middle (side face centers)
     rnode17 = k2n(n1k1m,n1k2m,n1k4m,k+1)
     rnode18 = k2n(n2k1m,n2k2m,n2k4m,k+1)
     rnode19 = k2n(n3k1m,n3k2m,n3k4m,k+1)
     rnode20 = k2n(n4k1m,n4k2m,n4k4m,k+1)
   ! 4 edge-mid-nodes on the top
     rnode21 = k2n(n1k1m,n1k2m,n1k4m,k+2)
     rnode22 = k2n(n2k1m,n2k2m,n2k4m,k+2)
     rnode23 = k2n(n3k1m,n3k2m,n3k4m,k+2)
     rnode24 = k2n(n4k1m,n4k2m,n4k4m,k+2)
   ! 2 at the face centers of top and bottom.
     rnode25 = k2n(n5k1m,n5k2m,n5k4m,k  )
     rnode26 = k2n(n5k1m,n5k2m,n5k4m,k+2)
   ! 1 at the center of the hexa
     rnode27 = k2n(n5k1m,n5k2m,n5k4m,k+1)
   !---------------------------------------

   !Form a hexahedron
    nchex = nchex + 1
    chex(nchex,1) = node1
    chex(nchex,2) = node2
    chex(nchex,3) = node3
    chex(nchex,4) = node4
    chex(nchex,5) = node1_above
    chex(nchex,6) = node2_above
    chex(nchex,7) = node3_above
    chex(nchex,8) = node4_above

   !---------------------------------------
   ! Keep removed nodes
     chex(nchex, 9) = rnode9
     chex(nchex,10) = rnode10
     chex(nchex,11) = rnode11
     chex(nchex,12) = rnode12
     chex(nchex,13) = rnode13
     chex(nchex,14) = rnode14
     chex(nchex,15) = rnode15
     chex(nchex,16) = rnode16
     chex(nchex,17) = rnode17
     chex(nchex,18) = rnode18
     chex(nchex,19) = rnode19
     chex(nchex,20) = rnode20
     chex(nchex,21) = rnode21
     chex(nchex,22) = rnode22
     chex(nchex,23) = rnode23
     chex(nchex,24) = rnode24
     chex(nchex,25) = rnode25
     chex(nchex,26) = rnode26
     chex(nchex,27) = rnode27
   !---------------------------------------

    if (k==0) then
     cell_body(nctria_temp+i) = ncprs + nchex            ! Cell # = 1,2,3,...,(ntet+nprs+nhex)
     cell_below               = cell_body(nctria_temp+i) ! Cell # = 1,2,3,...,(ntet+nprs+nhex)
    else
     cell_above(cell_below)   = ncprs + nchex ! Cell # = 1,2,3,...,(ntet+nprs+nhex)
     cell_below               = ncprs + nchex ! Cell # = 1,2,3,...,(ntet+nprs+nhex)
    endif

   if (k == k5max-2) then

     ncquad = ncquad + 1
     cquad(ncquad,1) = node4_above
     cquad(ncquad,2) = node3_above
     cquad(ncquad,3) = node2_above
     cquad(ncquad,4) = node1_above
     cquad(ncquad,5) = 2

   endif

  end do

 end do


 endif mixed_ph_coarsening_hex

!-------------------------------------------------------------------------------
! End of unstructured volume coarsening.
!-------------------------------------------------------------------------------

 endif strct_unstrct_v

  write(*,*)
  write(*,*) "  # cells in the coarse-grid full line = ", ncells_in_line_all
  write(*,*)

!*******************************************************************************
!
! End of volume coarsening
!
!*******************************************************************************

! At this point, we have volume elements, prism and/or hex.
!
!  Prisms    = cprs(1:ncprs)
!  Hexahedra = chex(1:nchex)
!

  write(*,*) " ---      nctet = ", nctet
  write(*,*) " ---      ncprs = ", ncprs
  write(*,*) " ---      nchex = ", nchex

! Tria and quad lists contain outer boundary surface elements:
!
!  Triangles = ctria(1:nctria)
!  Quads     = cquad(1:ncquad)
!
  write(*,*) " ---     nctria = ", nctria
  write(*,*) " ---     ncquad = ", ncquad

! Note: Here, cprs, chex, ctria, and cquad are based still on the fine-grid node numbers.

!---------------------------------------------------------------------------
! Repair the orientation
!---------------------------------------------------------------------------

 !---------------------------------------------------------------------------
 ! Repair the orientation of the triangles of the rear hemisphere surface.

  !---------------------------
  ! Triangles

   do j = 1, rh_nctrias

   !Inner boundary
    i = rh_ctria0 + j

         i_temp = ctria(i,1)
     ctria(i,1) = ctria(i,2)
     ctria(i,2) = i_temp

         i_temp = ctria2(i,5)
    ctria2(i,5) = ctria2(i,6)
    ctria2(i,6) = i_temp

   !Outer boundary
    i = (2*rh_ctria0+rh_nctrias) + j

         i_temp = ctria(i,1)
     ctria(i,1) = ctria(i,2)
     ctria(i,2) = i_temp

         i_temp = ctria2(i,5)
    ctria2(i,5) = ctria2(i,6)
    ctria2(i,6) = i_temp

   end do

 !---------------------------------------------------------------------------
 ! Repair the orientation of the tetrahedra over the rear hemisphere surface.

  !---------------------------
  ! Tetrahedra

   if (rh_nctets > 0) then

    do j = 1, rh_nctets

     i = rh_ctet0 + j

        i_temp = ctet(i,1)
     ctet(i,1) = ctet(i,2)
     ctet(i,2) = i_temp

         i_temp = ctet(i,6)
      ctet(i,6) = ctet(i,7)
      ctet(i,7) = i_temp

         i_temp = ctet(i, 8)
     ctet(i, 8) = ctet(i,10)
     ctet(i,10) = ctet(i, 9)
     ctet(i, 9) = i_temp

    end do

   endif

  !---------------------------
  ! Prisms

   if (rh_ncprs > 0) then

    do j = 1, rh_ncprs

     i = rh_cprs0 + j

        i_temp = cprs(i,1)
     cprs(i,1) = cprs(i,2)
     cprs(i,2) = i_temp

        i_temp = cprs(i,4)
     cprs(i,4) = cprs(i,5)
     cprs(i,5) = i_temp



        i_temp = cprs(i,7)
     cprs(i,7) = cprs(i,8)
     cprs(i,8) = i_temp

         i_temp = cprs(i,11)
     cprs(i,11) = cprs(i,12)
     cprs(i,12) = i_temp

         i_temp = cprs(i,14)
     cprs(i,14) = cprs(i,15)
     cprs(i,15) = i_temp

         i_temp = cprs(i,17)
     cprs(i,17) = cprs(i,18)
     cprs(i,18) = i_temp

    end do

   endif

!---------------------------------------------------------------------------
! End of Repair the orientation
!---------------------------------------------------------------------------



!*******************************************************************************
!
! Start of symmetry-boundary coarsening for half-geometry
!
! Note: This is different from the one for HC grids because this is only
!       applicable to HC grids (not Wing grids). In HC grids, the HC is in y < 0.
!       Here, due to the rotation, the body is in y > 0. So, the orientation of
!       elements must be completely opposite.
!*******************************************************************************

 half_geom_only : if (half_geom) then

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 4.5. Symmetry-boundary grid coarsening "
  write(*,*) "**************************************************************"

  write(*,*)
  write(*,*) " Coarsening the symmetry quad/tria boundary......."

!-----------------------------------------------------------------------
! (1)Unstructured grids
  strct_unstrct_symmetry : if (.not.strct_grid) then

 ! Note: This is for the left half body (y > 0).
 ! Note: Boundary element nodes are ordered counterclockwise,
 !       so that the element points inward.

!------------------------------------------------------
! Symmetry 1: -ve z-direction (originally +ve y)
! Note: k2 = 0 along the symmetry line, and k3 = 0, k3max in this region.

     ik4 = 0              !On the hemisphere
     ik2 = 0              !Along the symmetry line
  do ik3 = 0, k3max-2, 2  !From the apex to the cylinder part
     ik1 = -(ik2+ik3)

   do i = 0, k5max-2, 2

  !   HC body on this side
  !     node2      node1
  !    ---o----------o---     <------ to the cylinder base.
  !       |          |              |
  !       |          |              v
  !       o----------o               To the outer boundary
  !     node4      node3

    node1 = k2n(ik1  ,ik2,ik4  ,i)
    node2 = k2n(ik1-2,ik2,ik4  ,i)
    node3 = k2n(ik1  ,ik2,ik4  ,i+2)
    node4 = k2n(ik1-2,ik2,ik4  ,i+2)

   if (i < k5_tetra .or. k5_tetra < 0) then
    ncquad = ncquad + 1
    cquad(ncquad,1) = node1
    cquad(ncquad,2) = node2
    cquad(ncquad,3) = node4
    cquad(ncquad,4) = node3
    cquad(ncquad,5) = 3
   else
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node1
      ctria(nctria,2) = node2
      ctria(nctria,3) = node4
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node1
      ctria(nctria,2) = node4
      ctria(nctria,3) = node3
   endif

   end do

  end do

! Continue to the cylinder part.

     ik1 = k1min          !Symmetry line on the bottom side of the HC.
     ik2 = 0              !Along the symmetry line
  do ik4 = 0, k4max-2, 2  !From the apex to the cylinder part

  !   HC body on this side
  !     node2      node1
  !    ---o----------o---  <------ to the cylinder base.
  !       |          |           |
  !       |          |           v
  !       o----------o            To the outer boundary
  !     node4      node3

   do i = 0, k5max-2, 2

    node1 = k2n(ik1,ik2,ik4  ,i)
    node2 = k2n(ik1,ik2,ik4+2,i)
    node3 = k2n(ik1,ik2,ik4  ,i+2)
    node4 = k2n(ik1,ik2,ik4+2,i+2)

   if (i < k5_tetra .or. k5_tetra < 0) then
    ncquad = ncquad + 1
    cquad(ncquad,1) = node1
    cquad(ncquad,2) = node2
    cquad(ncquad,3) = node4
    cquad(ncquad,4) = node3
    cquad(ncquad,5) = 3
   else
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node1
      ctria(nctria,2) = node2
      ctria(nctria,3) = node3
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node2
      ctria(nctria,2) = node4
      ctria(nctria,3) = node3
   endif

   end do

  end do

! Note: k2 = 0 along the symmetry line, and k3 = [k3max,0] in this region.

     ik4 = k4max          !On the rear hemisphere
     ik2 = 0              !Along the symmetry line
  do ik1 = k1min, -2, 2

  !   HC body on this side
  !     node2      node1
  !    ---o----------o---   <------ to the cylinder base.
  !       |          |            |
  !       |          |            v
  !       o----------o             To the outer boundary
  !     node4      node3

   do i = 0, k5max-2, 2

    node1 = k2n(ik1  ,ik2,ik4  ,i)
    node2 = k2n(ik1+2,ik2,ik4  ,i)
    node3 = k2n(ik1  ,ik2,ik4  ,i+2)
    node4 = k2n(ik1+2,ik2,ik4  ,i+2)

   if (i < k5_tetra .or. k5_tetra < 0) then
    ncquad = ncquad + 1
    cquad(ncquad,1) = node1
    cquad(ncquad,2) = node2
    cquad(ncquad,3) = node4
    cquad(ncquad,4) = node3
    cquad(ncquad,5) = 3
   else
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node1
      ctria(nctria,2) = node2
      ctria(nctria,3) = node3
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node2
      ctria(nctria,2) = node4
      ctria(nctria,3) = node3
   endif

   end do

  end do

!------------------------------------------------------
! Symmetry 2: +ve z-direction (originally -ve y)
! Note: k2 = 0 along the symmetry line, and k3 = 0, k3min in this region from the apex.

     ik4 = 0              !On the hemisphere
     ik2 = 0              !Along the symmetry line
  do ik1 = 0, k1max-2, 2  !From the apex to the cylinder part

  !     node4      node3
  !       o----------o            ^ To the outer boundary
  !       |          |            |
  !       |          |      <------  to the cylinder base.
  !    ---o----------o---
  !     node2      node1
  !   HC body on this side

   do i = 0, k5max-2, 2

    node1 = k2n(ik1  ,ik2,ik4  ,i)
    node2 = k2n(ik1+2,ik2,ik4  ,i)
    node3 = k2n(ik1  ,ik2,ik4  ,i+2)
    node4 = k2n(ik1+2,ik2,ik4  ,i+2)

   if (i < k5_tetra .or. k5_tetra < 0) then
    ncquad = ncquad + 1
    cquad(ncquad,1) = node3
    cquad(ncquad,2) = node4
    cquad(ncquad,3) = node2
    cquad(ncquad,4) = node1
    cquad(ncquad,5) = 3
   else
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node1
      ctria(nctria,2) = node4
      ctria(nctria,3) = node2
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node1
      ctria(nctria,2) = node3
      ctria(nctria,3) = node4
   endif

   end do

  end do

! Continue to the cylinder part.

     ik1 = k1max          !Symmetry line on the top side of the HC.
     ik2 = 0              !Along the symmetry line
  do ik4 = 0, k4max-2, 2  !From the apex to the cylinder part

  !     node4      node3
  !       o----------o           ^ To the outer boundary
  !       |          |           |
  !       |          |     <------  to the cylinder base.
  !    ---o----------o---
  !     node2      node1
  !   HC body on this side

   do i = 0, k5max-2, 2

    node1 = k2n(ik1,ik2,ik4  ,i)
    node2 = k2n(ik1,ik2,ik4+2,i)
    node3 = k2n(ik1,ik2,ik4  ,i+2)
    node4 = k2n(ik1,ik2,ik4+2,i+2)

   if (i < k5_tetra .or. k5_tetra < 0) then
    ncquad = ncquad + 1
    cquad(ncquad,1) = node3
    cquad(ncquad,2) = node4
    cquad(ncquad,3) = node2
    cquad(ncquad,4) = node1
    cquad(ncquad,5) = 3
   else
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node1
      ctria(nctria,2) = node3
      ctria(nctria,3) = node2
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node2
      ctria(nctria,2) = node3
      ctria(nctria,3) = node4
   endif

   end do

  end do

! Note: k2 = 0 along the symmetry line, and k3 = [k1max,0] in this region from the apex.
! This is the upper half of symmetry plane (z > 0).

     ik4 = k4max          !On the hemisphere
     ik2 = 0              !Along the symmetry line
  do ik1 = k1max, 2, -2

  !     node4      node3
  !       o----------o             ^ To the outer boundary
  !       |          |             |
  !       |          |      <------  to the cylinder base.
  !    ---o----------o---
  !     node2      node1
  !   HC body on this side

   do i = 0, k5max-2, 2
   
    node1 = k2n(ik1  ,ik2,ik4  ,i)
    node2 = k2n(ik1-2,ik2,ik4  ,i)
    node3 = k2n(ik1  ,ik2,ik4  ,i+2)
    node4 = k2n(ik1-2,ik2,ik4  ,i+2)

   if (i < k5_tetra .or. k5_tetra < 0) then
    ncquad = ncquad + 1
    cquad(ncquad,1) = node3
    cquad(ncquad,2) = node4
    cquad(ncquad,3) = node2
    cquad(ncquad,4) = node1
    cquad(ncquad,5) = 3
   else
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node1
      ctria(nctria,2) = node3
      ctria(nctria,3) = node2
      nctria = nctria + 1
      ctria(nctria,5) = 3
      ctria(nctria,1) = node2
      ctria(nctria,2) = node3
      ctria(nctria,3) = node4
   endif

   end do

  end do

!-----------------------------------------------------------------------
! (2)Structured grids
  else

 ! Note: This is for the left half body (y > 0).

 !-------------------------
 ! Lower side of the HC.

  !   HC body on this side
  !     node2      node1
  !    ---o----------o---
  !       |          |   
  !       |          |         <----- to the cylinder base.
  !       o----------o              |
  !     node4      node3            v To the outer boundary

  ik1 = 1 !First node in the circumferential direction.
  ik2 = 0 !Not used

  do ik4 = 0, k4max-2, 2

   do ik5 = 0, k5max-2, 2

     node1 = k2n(ik1,ik2,ik4  , ik5)
     node3 = k2n(ik1,ik2,ik4  , ik5+2)
    if (ik4 == 0) then !<- k1=0 at the apex.
     node1 = k2n(  0,ik2,ik4  , ik5)
     node3 = k2n(  0,ik2,ik4  , ik5+2)
    endif
     node2 = k2n(ik1,ik2,ik4+2, ik5)
     node4 = k2n(ik1,ik2,ik4+2, ik5+2)

    if (ik4 == k4max-2) then
     node1 = k2n(ik1,ik2,ik4  , ik5)
     node3 = k2n(ik1,ik2,ik4  , ik5+2)
     node2 = k2n(  0,ik2,ik4+2, ik5)
     node4 = k2n(  0,ik2,ik4+2, ik5+2)
    endif

      ncquad = ncquad + 1
      cquad(ncquad,1) = node1
      cquad(ncquad,2) = node2
      cquad(ncquad,3) = node4
      cquad(ncquad,4) = node3
      cquad(ncquad,5) = 3

   end do

  end do

 !-------------------------
 ! Upper side of the HC.

  !   HC body on this side        ^ To the outer boundary
  !     node4      node3          |
  !       o----------o      <------ to the cylinder base.
  !       |          |           
  !       |          |            
  !    ---o----------o---         
  !     node2      node1
  !

  ik1 = k1max !End node in the circumferential direction.
  ik2 = 0     !Not used

  do ik4 = 0, k4max-2, 2

   do ik5 = 0, k5max-2, 2

     node1 = k2n(ik1,ik2,ik4  , ik5)
     node3 = k2n(ik1,ik2,ik4  , ik5+2)
    if (ik4 == 0) then !<- k1=0 at the apex.
     node1 = k2n(  0,ik2,ik4  , ik5)
     node3 = k2n(  0,ik2,ik4  , ik5+2)
    elseif (ik4 == k4max-2) then !<- k1=0 at the apex.
     node1 = k2n(  0,ik2,ik4  , ik5)
     node3 = k2n(  0,ik2,ik4  , ik5+2)
    endif

     node2 = k2n(ik1,ik2,ik4+2, ik5)
     node4 = k2n(ik1,ik2,ik4+2, ik5+2)

    if (ik4 == k4max-2) then
     node1 = k2n(ik1,ik2,ik4  , ik5)
     node3 = k2n(ik1,ik2,ik4  , ik5+2)
     node2 = k2n(  0,ik2,ik4+2, ik5)
     node4 = k2n(  0,ik2,ik4+2, ik5+2)
    endif

      ncquad = ncquad + 1
      cquad(ncquad,1) = node1
      cquad(ncquad,2) = node3
      cquad(ncquad,3) = node4
      cquad(ncquad,4) = node2
      cquad(ncquad,5) = 3

   end do

  end do


  endif strct_unstrct_symmetry
!-----------------------------------------------------------------------

 endif half_geom_only

  write(*,*) " Successfully coarsened the symmetry quad/tria boundary, I think. "

! Note: For left half body (y<0), the above needs to be modified.
!       -> Reverse the orientation of trias and quads.

!*******************************************************************************
!
! End of symmetry-boundary coarsening for half-geometry
!
!*******************************************************************************



!*******************************************************************************
!
! Start of coarse-grid node numbering
!
!*******************************************************************************

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 5.1 Construct coarse-grid node numbering. "
  write(*,*) "**************************************************************"

!*******************************************************************************
! Construct coarse-grid node numbering, so that all element-arrays
! and (xc,yc,zc) coordiate array will be switched from the fine-grid
! node numbers to the coarse-grid numbers.
!
!*******************************************************************************

  write(*,*)
  write(*,*) " Generating a coarse-grid node array......."

  allocate(f2c(nnodes))

      f2c = 0
  ncnodes = 0

 !------------------------------------------------
 ! Order the coarse-grid nodes starting from those on the HCH.

  do i = 1,  nctria
   do k = 1, 3
      fnode = ctria(i,k)
    if (k5(fnode) > 0) cycle
    if (f2c(fnode) == 0 ) then
     ncnodes = ncnodes + 1
     f2c(fnode) = ncnodes
    endif
   end do
  end do

   do i = 1, ncquad
    do k = 1, 4
       fnode = cquad(i,k)
     if (k5(fnode) > 0) cycle
     if (f2c(fnode) == 0 ) then
      ncnodes = ncnodes + 1
      f2c(fnode) = ncnodes
     endif
    end do
   end do

 !------------------------------------------------
 ! Off the surface of the HCH.

  do i = 1, nccprs
   do k = 1, 6
      fnode = ccprs(i,k)
    if (f2c(fnode) == 0 ) then
     ncnodes = ncnodes + 1
     f2c(fnode) = ncnodes
    endif
   end do
  end do

  if (nchex > 0) then
   do i = 1, nchex
    do k = 1, 8
       fnode = chex(i,k)
     if (f2c(fnode) == 0 ) then
      ncnodes = ncnodes + 1
      f2c(fnode) = ncnodes
     endif
    end do
   end do
  endif

 !------------------------------------------------
 ! (xc,yc,zc) coordinates defined with coarse-grid numbers.

  allocate( xc(ncnodes))
  allocate( yc(ncnodes))
  allocate( zc(ncnodes))

  do i = 1, nnodes
  if (f2c(i) == 0) cycle
   xc(f2c(i)) = xf(i)
   yc(f2c(i)) = yf(i)
   zc(f2c(i)) = zf(i)
  end do

!*******************************************************************************
!
! End of coarse-grid node numbering
!
!*******************************************************************************

!*******************************************************************************
!
! Start of line coarsening
!
!*******************************************************************************

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 5.2 Coarsen the line information."
  write(*,*) "**************************************************************"

!-------------------------------------------------------------------------
! (1) Coarsen the partial line data.
!-------------------------------------------------------------------------
  write(*,*)
  write(*,*) " Coarsening the partial line info.......: ", filename_lines_finer

  allocate(cline(max_points,n_lines))

  strct_unstrct_cline : if (strct_grid) then

    k_start = 3

  else

   if (k_start_prs==1) then
    k_start = 2
    write(*,*) " Actually, odd k5max is not allowed. So, stop..."
    stop
   else
    k_start = 3
   endif

  endif strct_unstrct_cline

!Note: We always have k_start = 3.

  n_total_cpoints = 0
         n_clines = 0

  flines : do i = 1, n_lines
  if (f2c(fline(1,i)) == 0) cycle flines

   n_clines = n_clines + 1

   i_count = 0

   !First node on the surface.
     n_total_cpoints = n_total_cpoints + 1
             i_count = i_count + 1
    cline(i_count,n_clines) = fline(1,i)

    do k = k_start, max_points, 2
      n_total_cpoints = n_total_cpoints + 1
              i_count = i_count + 1
     cline(i_count,n_clines) = fline(k,i)
    end do

!   if (k_start == 2 .and. mod(max_points,2)/=0) then
!    if (f2c(fline(max_points,i)) > 0) then
!     n_total_cpoints = n_total_cpoints + 1
!             i_count = i_count + 1
!     cline(i_count,n_clines) = fline(max_points,i)
!    endif
!   endif

!   if (k_start == 1 .and. mod(max_points,2)==0) then
!    if (f2c(fline(max_points,i)) > 0) then
!     n_total_cpoints = n_total_cpoints + 1
!             i_count = i_count + 1
!     cline(i_count,n_clines) = fline(max_points,i)
!    endif
!   endif

   max_cpoints = i_count
   min_cpoints = max_cpoints

  end do flines

  do i = 1, n_clines
   do k = 1, max_cpoints
    cline(k,i) = f2c(cline(k,i))
   end do
  end do


 ! # of cells in the coarse-grid line.
   ncells_in_line = max(1, max_cpoints-1)

  write(*,*)
  write(*,*) "  # cells in the coarse-grid line = ", ncells_in_line
  write(*,*)

!-------------------------------------------------------------------------
! (2) Coarsen the full line data.
!-------------------------------------------------------------------------
  write(*,*)
  write(*,*) " Coarsening the full line info.......: ", filename_lines_all_finer

  allocate(cline_all(max_points_all,n_lines_all))

  strct_unstrct_cline_all : if (strct_grid) then

    k_start_all = 3

  else

   if (k_start_prs==1) then
    k_start_all = 2
   else
    k_start_all = 3
   endif

  endif strct_unstrct_cline_all

  n_total_cpoints_all = 0
         n_clines_all = 0

  flines_all : do i = 1, n_lines_all
  if (f2c(fline_all(1,i)) == 0) cycle flines_all

   n_clines_all = n_clines_all + 1

   i_count_all = 0
     n_total_cpoints_all = n_total_cpoints_all + 1
             i_count_all = i_count_all + 1
    cline_all(i_count_all,n_clines_all) = fline_all(1,i)

    do k = k_start_all, max_points_all, 2
      n_total_cpoints_all = n_total_cpoints_all + 1
              i_count_all = i_count_all + 1
     cline_all(i_count_all,n_clines_all) = fline_all(k,i)
    end do

   if (k_start_all == 2 .and. mod(max_points_all,2)/=0) then
    if (f2c(fline_all(max_points_all,i)) > 0) then
     n_total_cpoints_all = n_total_cpoints_all + 1
             i_count_all = i_count_all + 1
     cline_all(i_count_all,n_clines_all) = fline_all(max_points_all,i)
    endif
   endif

   if (k_start_all == 1 .and. mod(max_points_all,2)==0) then
    if (f2c(fline_all(max_points_all,i)) > 0) then
     n_total_cpoints_all = n_total_cpoints_all + 1
             i_count_all = i_count_all + 1
     cline_all(i_count_all,n_clines_all) = fline_all(max_points_all,i)
    endif
   endif

   max_cpoints_all = i_count_all
   min_cpoints_all = max_cpoints_all

  end do flines_all

  do i = 1, n_clines_all
   do k = 1, max_cpoints_all
    cline_all(k,i) = f2c(cline_all(k,i))
   end do
  end do

!*******************************************************************************
!
! End of line coarsening
!
!*******************************************************************************

!*******************************************************************************
!
! Start of coarsening of grid indices (k): kc1, kc2, kc3, kc4, kc5
!
!*******************************************************************************

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 6. Coarsening the k info......."
  write(*,*) "**************************************************************"

  allocate(kc1(ncnodes))
  allocate(kc2(ncnodes))
  allocate(kc3(ncnodes))
  allocate(kc4(ncnodes))
  allocate(kc5(ncnodes))

  do i = 1, nnodes
  if (f2c(i) ==0) cycle

         cnode = f2c(i)

   ! k1 = 0,1,2,3,...,even for prism/tetra/mixed/mixed_ph.

    kc1(cnode) = k1(i)/2

   if (strct_grid) then

   !(1) k1 = 1,2,3,4,..., odd  (structured grid, not full geometry)
   !    The last node is a coarse-grid node.
   !(2) k1 = 1,2,3,4,..., even (structured grid, full geometry)
   !    The last node is not a coarse-grid node, the second to
   !    the last (odd) is the last coarse-grid node.

    kc1(cnode) = (k1(i)+1)/2

   endif

    kc2(cnode) = k2(i)/2
    kc3(cnode) = k3(i)/2
    kc4(cnode) = k4(i)/2
    kc5(cnode) = k5(i)/2

  end do

  if (strct_grid .and. half_geom) then

    allocate(k2nc(k1min/2:(k1max+1)/2,k2min/2:k2max/2,k4min/2:k4max/2,k5min/2:k5max/2))

    kc3(1) = -1 !To indicate that this is a half-geometry structured grid.
    write(*,*)
    write(*,*) " Set k3(1) = -1 to indicate that this is a half-geometry grid."

  else

   allocate(k2nc(k1min/2:k1max/2,k2min/2:k2max/2,k4min/2:k4max/2,k5min/2:k5max/2))

  endif

  do i = 1, ncnodes
   k2nc( kc1(i),kc2(i),kc4(i),kc5(i) ) = i
  end do

  
   kc1min = minval(kc1)
   kc2min = minval(kc2)
   kc3min = minval(kc3)
   kc4min = minval(kc4)
   kc5min = minval(kc5)

   kc1max = maxval(kc1)
   kc2max = maxval(kc2)
   kc3max = maxval(kc3)
   kc4max = maxval(kc4)
   kc5max = maxval(kc5)

   write(*,*) "kc1 min max = ", kc1min, kc1max
   write(*,*) "kc2 min max = ", kc2min, kc2max
   write(*,*) "kc3 min max = ", kc3min, kc3max
   write(*,*) "kc4 min max = ", kc4min, kc4max
   write(*,*) "kc5 min max = ", kc5min, kc5max


!*******************************************************************************
!
! End of coarsening of grid indices (k): kc1, kc2, kc3, kc4, kc5
!
!*******************************************************************************


!*******************************************************************************
! Beginning of prolongation information for CC
!
! Note: This is a map from c-grid cell to f-grid cells.
! Note: Assume k5max is even.
!*******************************************************************************

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 7.1 Constructing prolongation operator for CC......."
  write(*,*) "**************************************************************"

  write(*,*) "  ntet = ", ntet
  write(*,*) "  nprs = ", nprs
  write(*,*) "  nhex = ", nhex

  write(*,*)

  write(*,*) " nctet = ", nctet
  write(*,*) " ncprs = ", ncprs
  write(*,*) " nchex = ", nchex

  write(*,*)
  write(*,*) " Check # of cells in flines and clines:"
  write(*,*) "    # of cells in an f-line = ", max_cells_all
  write(*,*) "    # of cells in a  c-line = ", ncells_in_line_all
  write(*,*)


!------------------------------------------------------------------------------
! Check for a prism/hex element grid (no tetrahedra).
! --- 'hch_prism', 'hch_mixed_ph', or 'hch_strct'

  if ( trim(project) == "hch_prism" .or.  trim(project) == "hch_mixed_ph" .or. &
       trim(project) == "hch_strct"        ) then

    write(*,*) " --- This grid has no tetrahedra."
   if ( max_cells_all - 2*ncells_in_line_all == 0 ) then
    write(*,*) " --- Good. Exactly twice as many f-cells as c-cells in a line. Proceed."   
   else
    write(*,*) " --- Something is wrong..."
    write(*,*) "      Must have # of cells in an f-line = 2*(# of cells in a  c-line): Stop"
    stop
   endif

  endif
    write(*,*)

!------------------------------------------------------------------------------
! Check for a pure tetrahedral grid.
! --- 'hch_tetra'
! For now, let me assume that the grid is pure tetra for all levels (i.e., tet2prism = F).

  if ( trim(project) == "hch_tetra" ) then

    write(*,*) " --- This grid has only tetrahedra."
   if ( max_cells_all - 2*ncells_in_line_all == 0 ) then
    write(*,*) " --- Good. Exactly 2 times as many f-cells as c-cells in each line. Proceed."   
   else
    write(*,*) " --- Something is wrong... This is a pure tetrahedral grid."
    write(*,*) "      Must have # of cells in an f-line = 2*(# of cells in a  c-line): Stop"
    stop
   endif

  endif
    write(*,*)

!------------------------------------------------------------------------------
! Check for a tet-prism mixed grid.
! --- 'hch_mixed'

  if ( trim(project) == "hch_mixed" ) then
!  if ( last_prs_location /= 0 ) then

    write(*,*) " --- This grid has both tetrahedra and prisms."
    write(*,*) " ---   f-grid:  # of prism layers = ", last_prs_location
    write(*,*) " ---   f-grid:  # of tetra layers = ", max_cells_all - last_prs_location
    write(*,*) "                -------------------------------------------------------"
    write(*,*) " ---   f-grid:  # of total layers = ", max_cells_all
    write(*,*)
    write(*,*) " ---   c-grid:  # of prism layers = ", last_cprs_location
    write(*,*) " ---   c-grid:  # of tetra layers = ", ncells_in_line_all - last_cprs_location
    write(*,*) "                -------------------------------------------------------"
    write(*,*) " ---   c-grid:  # of total layers = ", ncells_in_line_all
    write(*,*)

  !--------------------------------------------------------------------------
  ! F-grid prisms are contained in a c-grid prism.
   if ( last_prs_location > 1 ) then

    if ( max_cells_all - 2*ncells_in_line_all == 0 ) then
     write(*,*) " --- Good. Exactly 2 times as many f-cells as c-cells in a line. Proceed."   
    else

     if (mod(last_prs_location,2)/=0) then
      write(*,*) " OK, there will be one c-cell formed by prisms and tets..."
     else
      write(*,*) " --- Something is wrong... This is a mixed grid."
      write(*,*) "      Must have # of cells in an f-line = 2*(# of cells in a  c-line): Stop"
      stop
     endif

    endif

  !--------------------------------------------------------------------------
  ! There is only one prismatic layer over the surface.
  ! The first c-grid prism has 1 f-grid prism + 3 tetra on top of it.
   elseif ( last_prs_location == 1 ) then

                          !Tetrahedra                 4 = 1 prism + 3*tetra
    if ( max_cells_all - ( 2*(ncells_in_line_all-1) + 4 ) == 0 ) then
     write(*,*) " --- Good. Exactly 2 times as many f-cells as c-cells in a line. Proceed."   
    else
     write(*,*) " --- Something is wrong... This is a mixed grid."
     write(*,*) "      Must have # of cells in an f-line = 2*(# of cells in a  c-line): Stop"
     stop
    endif

   endif

  endif
    write(*,*)

!------------------------------------------------------------------------------
! Allocate arrays for a cell prolongation operator.

  allocate(nccells_prolong(     nctet+ncprs+nchex))

  if ( trim(project) == "hch_mixed" ) then
   allocate(  ccell_prolong( 16, nctet+ncprs+nchex))
  else
   allocate(  ccell_prolong(  8, nctet+ncprs+nchex))
  endif

  nccells_prolong = 0

 ! Count the number of prismatic c-layers (for mixed grids).
   i_count        = 0
   merged_prs_tet = 0

!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
! (1)Non-tetrahedral elements
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------

  non_tet_elms : if ( trim(project) == "hch_prism"     .or. &
                      trim(project) == "hch_mixed"     .or. &
                      trim(project) == "hch_mixed_ph"  .or. &
                      trim(project) == "hch_strct"          ) then

   write(*,*) " >>> Collecting information for cc-prolongation for non-tetra cells..."

 !------------------------------------------------------------------------------
 ! Loop over surface cells
 !------------------------------------------------------------------------------

  bcels : do i = 1, ncells_body

 !------------------------------------------------------------------
 ! (1)Bottom coarse-grid cell: cell_body(i)
 !------------------------------------------------------------------

     icell  = cell_body(i)
     etype  = elm_type_c(icell)
     ctetra = (etype == 4)

  !-------------------------------------------------------------
  ! Collect f-grid lines contained in the c-grid boundary cell i.
  !-------------------------------------------------------------

    do j = 1, 4
     flines_incell(j) = felm(i,j)
     if ( flines_incell(j) < 0 ) flines_incell(j) = ntria_body - flines_incell(j) ! f-grid Quad
    end do

  !-------------------------------------------------------------
  ! Collect 4 f-grid cell information: Prism/Hex coarse cell
  !-------------------------------------------------------------

       if (i==1) i_count = i_count + 1

      !--------------------------------------------
      ! All flines contained in the ccell: Add two cells from each fline.
       do j = 1, 4
                               nccells_prolong(icell) = nccells_prolong(icell) +  1
        ccell_prolong( nccells_prolong(icell), icell) = fline_cc_all(1,flines_incell(j))

                               nccells_prolong(icell) = nccells_prolong(icell) + 1
        ccell_prolong( nccells_prolong(icell), icell) = fline_cc_all(2,flines_incell(j))

       end do
      !--------------------------------------------

      cell_below = cell_body(i)

 !------------------------------------------------------------------
 ! (2)Go up along the c-cell line and collect f-cell information
 !------------------------------------------------------------------

   c_line : do k = 2, ncells_in_line_all

   !Next c-grid cell
     icell  = cell_above(cell_below)
     etype  = elm_type_c(icell)
     ctetra = (etype == 4)

   !This is outside the prismatic layer. Exit.
     if (ctetra) then
      exit c_line
     endif

     if (ctetra) then
      write(*,*) " Prismatic f-cell is in a tetrahedral c-cell... Stop"
      write(*,*) "                 k = ", k
      write(*,*) "        cell_below = ", cell_below
      write(*,*) "             icell = ", icell, " = cell_above(cell_below)"
      write(*,*) " elm_type_c(icell) = ", elm_type_c(icell)
      stop
     endif

   !--------------------------------------------
   ! Collect f-grid cell information
   !--------------------------------------------

     !--------------------------------------------
     ! All flines contained in the ccell
      do j = 1, 4

        !Add f-grid cell at 2k-1: 3,5,7,9,....
                                nccells_prolong(icell) = nccells_prolong(icell) + 1
         ccell_prolong( nccells_prolong(icell), icell) = fline_cc_all(2*k-1,flines_incell(j))

         ftetra = ( elm_type_f( fline_cc_all(2*k  ,flines_incell(j)) ) == 4 )

         !Prism has both prism and tets.
         if (ftetra) then

          merged_prs_tet = 1

          !Add f-grid tetra cells at 2k, 2k+1, 2k*2
                                  nccells_prolong(icell) = nccells_prolong(icell) + 1
           ccell_prolong( nccells_prolong(icell), icell) = fline_cc_all(2*k  ,flines_incell(j))
                                  nccells_prolong(icell) = nccells_prolong(icell) + 1
           ccell_prolong( nccells_prolong(icell), icell) = fline_cc_all(2*k+1,flines_incell(j))
                                  nccells_prolong(icell) = nccells_prolong(icell) + 1
           ccell_prolong( nccells_prolong(icell), icell) = fline_cc_all(2*k+2,flines_incell(j))

           !This should be the end of c-prismatic layer.

         else

          !Add f-grid cell at 2k  : 4,6,8,10,....
                                  nccells_prolong(icell) = nccells_prolong(icell) + 1
           ccell_prolong( nccells_prolong(icell), icell) = fline_cc_all(2*k  ,flines_incell(j))

         endif

      end do
     ! End of all fline loop
     !--------------------------------------------

       if (i==1) i_count = i_count + 1

   !--------------------------------------------
   ! Prepare for the next c-grid cell
   !--------------------------------------------
    cell_below = icell

   end do c_line
 !------------------------------------------------------------------
 ! End of Go up and collect f-cell information
 !------------------------------------------------------------------

  end do bcels
 !------------------------------------------------------------------------------
 ! End of Loop over surface cells
 !------------------------------------------------------------------------------

 endif non_tet_elms
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
! End of (1)Non-tetrahedral elements
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------


 if ( trim(project) == "hch_prism"    .or. &
      trim(project) == "hch_mixed_ph" .or. &
      trim(project) == "hch_strct"         ) then

  if (i_count /= ncells_in_line_all) then
   write(*,*) " Something is wrong... i_count /= ncells_in_line_all: "
   write(*,*) "               i_count = ", i_count
   write(*,*) "    ncells_in_line_all = ", ncells_in_line_all
   stop
  endif

 endif

!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
! (2)Tetrahedral elements
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
  tet_elms : if ( trim(project) == "hch_tetra" .or. &
                  trim(project) == "hch_mixed"      ) then

   write(*,*) " >>> Collecting information for cc-prolongation for tetra cells..."

 !------------------------------------------------------------------------------
 ! Loop over surface cells
 !------------------------------------------------------------------------------

  bcels2 : do i = 1, ncells_body

  !-------------------------------------------------------------
  ! Collect 4 f-grid lines contained in the c-grid boundary cell i.
  !-------------------------------------------------------------

    do j = 1, 4
     flines_incell(j) = felm(i,j)
     if ( flines_incell(j) < 0 ) flines_incell(j) = nctria - flines_incell(j) ! Quad
    end do

 !------------------------------------------------------------------
 ! (2)Go up along the c-cell line and collect f-cell information
 !------------------------------------------------------------------

    nclayers = (ncells_in_line_all-i_count)/3 + i_count

   c_line2 : do k = 1, nclayers

   !Skip prismatic layers:
    if (k <= i_count) then

      if (k==1) then
             icell  = cell_body(i)
      else
             icell  = cell_above(cell_below)
      endif

         cell_below = icell
         cycle c_line2

   !This is a tetra layer:
    else

     if (k==1) then
             icell  = cell_body(i)
         c3tetra(1) = icell
         c3tetra(2) = cell_above(c3tetra(1))
         c3tetra(3) = cell_above(c3tetra(2))
     else
             icell  = cell_above(cell_below)
         c3tetra(1) = icell
         c3tetra(2) = cell_above(c3tetra(1))
         c3tetra(3) = cell_above(c3tetra(2))

     endif

         cell_below = c3tetra(3)

    endif

   !--------------------------------------------
   ! Collect f-grid cell information
   !--------------------------------------------

        !     prism layers     tets layers
         kf =   2*i_count   + 6*( (k-i_count) -1 ) + 1 ! 6 f-grid tets in a c-grid layer.

        if ( merged_prs_tet == 1 ) then
        !     prism layers     prs+3*tets     tets layers
         kf = 2*(i_count-1) +    (1+3)     +  6*( (k-i_count) -1 ) + 1
        endif

      !--------------------------------------------
      ! All flines contained in the ccell
       do j = 1, 4

        kk = 6*(j-1) + 1 ! kk = 1,2,3,...,24

       !--- Total 24 f-grid tetrahedra:
        !(1) 3 tets in the first layer
        fcells_loc(kk  ) = fline_cc_all(kf  ,flines_incell(j))
        fcells_loc(kk+1) = fline_cc_all(kf+1,flines_incell(j))
        fcells_loc(kk+2) = fline_cc_all(kf+2,flines_incell(j))
        !(2) Another 3 tets in the second layer
        fcells_loc(kk+3) = fline_cc_all(kf+3,flines_incell(j))
        fcells_loc(kk+4) = fline_cc_all(kf+4,flines_incell(j))
        fcells_loc(kk+5) = fline_cc_all(kf+5,flines_incell(j))

       end do
      !--------------------------------------------

  !-------------------------------------------------------------
  ! For each f-tetra cell, find the c-tetra cell
  !-------------------------------------------------------------

      do j = 1, 24

       ifcell = fcells_loc(j)

       if (elm_type_f(ifcell) /= 4) then
        write(*,*) " k = " , k
        write(*,*) " elm_type_f(ifcell) /= 4 ....." 
        write(*,*) "       elm_type_f(ifcell) =  ", elm_type_f(ifcell)
        do kk = 1, 3
         write(*,*) "             kk = ", kk
         write(*,*) "             c3tetra(kk) =  ", c3tetra(kk), elm_type_c(c3tetra(kk))
        end do
       endif

      !For each c-tetra cell, find 8 f-tetra cells it possibly contains.

        icell = find_ctet_for_fcell(c3tetra, ifcell)

                              nccells_prolong(icell) = nccells_prolong(icell) +  1
       ccell_prolong( nccells_prolong(icell), icell) = ifcell

      end do

   end do c_line2
 !------------------------------------------------------------------
 ! End of Go up and collect f-cell information
 !------------------------------------------------------------------

  end do bcels2
 !------------------------------------------------------------------------------
 ! End of Loop over surface cells
 !------------------------------------------------------------------------------

  endif tet_elms
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
! End of (2)Tetrahedral elements
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------

   write(*,*)
   write(*,*) " maxval(nccells_prolong) = ", maxval(nccells_prolong)
   write(*,*) " minval(nccells_prolong) = ", minval(nccells_prolong)
   write(*,*)

!------------------------------------------------------------------------------
! Write a file

   write(*,*) " Writing a cc prolongation file: ", trim(filename_prolong_cc)

  call write_prolong_file_cc

!*******************************************************************************
!
! End of prolongation information for CC
!
!*******************************************************************************


!*******************************************************************************
!
! Start of prolongation information for NC
!
!*******************************************************************************

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 7.2 Constructing prolongation operator for NC......."
  write(*,*) "**************************************************************"

  allocate(         n_coeff(nnodes))
  allocate(cnode_prolong(8,nnodes))
  allocate(coeff_prolong(8,nnodes))

  n_coeff       = 0
  cnode_prolong = 0
  coeff_prolong = 0.0_dp

!---------------------------------------------------------------------
! Type I: Nested nodes (fine and coarse nodes coincide each other)

  k = 0
  do i = 1, nnodes
   if (f2c(i) > 0) then
                      k = k + 1
                  cnode = f2c(i)
             n_coeff(i) = 1      !<-- No averaging nor interpolation (injection)
     cnode_prolong(1,i) = cnode  !<-- For injection
     coeff_prolong(1,i) = one    !<-- For injection
   endif
  end do

  write(*,*) " Must have (nested nodes) = (ncnodes):"
  write(*,*) ">>>>>  Nested nodes = ", k 
  write(*,*) ">>>>>       ncnodes = ", ncnodes

!---------------------------------------------------------------------
! Type II: Other fine-grid nodes (no corresponding coarse grid nodes)
!

  tet_loop : do i = 1, nctet

 !  o : Coarse grid nodes
 !  x : Removed fine-grid nodes
 !
 !                             4            
 !                             o                
 !                           . . .
 !                          .  .  .
 !                         .   .   .
 !                        .    .    .
 !                       .     .     .
 !                      .      .      .
 !                     .       .       .           
 !                    .        .        .        
 !                   .         x 10      .     
 !                8 .          .          .9
 !                 x           .           x
 !                .            .            .   
 !               .             .             .   
 !              .              .              . 
 !             .               .               .
 !            .                .                .  
 !           .                 o 3               . 
 !          .               .     .               .
 !         .        7   .             .  6         .
 !        .         x                    x          .
 !       .      .                           .        .
 !      .    .                                 .      .
 !     .                                           .   .
 !   1 o-----------------------x------------------------o 2  
 !                            5
 !
 
 ! Note: cprs is still based on f-grid nodes.

     node1  = ctet(i,1)
     node2  = ctet(i,2)
     node3  = ctet(i,3)
     node4  = ctet(i,4)

    cnode1  = f2c(node1)
    cnode2  = f2c(node2)
    cnode3  = f2c(node3)
    cnode4  = f2c(node4)

     node5  = ctet(i, 5)
     node6  = ctet(i, 6)
     node7  = ctet(i, 7)

     node8  = ctet(i, 8)
     node9  = ctet(i, 9)
     node10 = ctet(i,10)

 !----------------------------------------------------------
 ! node5 <- cnode1 and cnode2

      fnode = node5

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node6 <- cnode2 and cnode3

      fnode = node6

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node7 <- cnode3 and cnode1

      fnode = node7

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node8 <- cnode1 and cnode4

      fnode = node8

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node9 <- cnode2 and cnode4

      fnode = node9

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node10 <- cnode3 and cnode4

      fnode = node10

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

  end do tet_loop

 !----------------------------------------
 ! Prisms
 !
 ! Note: By the regular coarsening, this type of fine-grid node always
 !       has two coarse-grid neighbors. Therefore, the prolongation
 !       weight is always 1/2, leading to a simple linear prolongation.
 !
 !           -----> 1/2    1/2 <----
 !           o. . . . . .x..........o
 !          / \           \          \
 !    1/2  /   \1/2        \          \
 !        /  1  \           \          \
 !       x_______x...........x..........x
 !      / \      /\           \          \
 !  1/2/   \  4 /  \1/2        \          \
 !    /  2  \  /  3 \           \          \
 !   o-------x-------o.. . . ....x..........o
 !     1/2->   <-1/2  -----> 1/2    1/2 <-----
 !
 ! Note: Prisms 1, 2, and 3 are the ones considered here.
 !       Prism 4 does not have a coarse grid node. Skip it here.

  prs_loop : do i = 1, ncprs

 !--------------------------------------------------
 !
 !  o : Coarse grid nodes
 !  x : Removed fine-grid nodes
 !
 !                        6
 !                        o                  
 !                     .  .  .               
 !             18   .     .     .  17
 !               x        .        x         
 !            .           .           .      
 !         .              .              .   
 !      .                 . 16              .
 !   4 o------------------x------------------o 5
 !     |                  .                  |
 !     |                  x 9                |
 !     |               .  .  .               |
 !     |       15   .     .     .  14        |
 !     |         x        .        x         |
 !     |      .           .           .      |
 !     |   .              .              .   |
 !     |.                 .13               .|
 !   7 x------------------x------------------x 8
 !     |                  .                  |
 !     |                  o 3                |
 !     |               .     .               |
 !     |       12   .           .  11        |
 !     |         x                 x         |
 !     |      .                       .      |
 !     |   .                             .   |
 !     |.                                   .|
 !   1 o------------------x------------------o 2
 !                       10
 !

 ! Note: cprs is still based on f-grid nodes.

     node1  = cprs(i,1)
     node2  = cprs(i,2)
     node3  = cprs(i,3)
     node4  = cprs(i,4)
     node5  = cprs(i,5)
     node6  = cprs(i,6)

    cnode1  = f2c(node1)
    cnode2  = f2c(node2)
    cnode3  = f2c(node3)
    cnode4  = f2c(node4)
    cnode5  = f2c(node5)
    cnode6  = f2c(node6)

     node7  = cprs(i,7)
     node8  = cprs(i,8)
     node9  = cprs(i,9)

     node10 = cprs(i,10)
     node11 = cprs(i,11)
     node12 = cprs(i,12)

     node13 = cprs(i,13)
     node14 = cprs(i,14)
     node15 = cprs(i,15)

     node16 = cprs(i,16)
     node17 = cprs(i,17)
     node18 = cprs(i,18)

 !----------------------------------------------------------
 ! node7 <- cnode1 and cnode4

      fnode = node7

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node8 <- cnode2 and cnode5

      fnode = node8

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node9 <- cnode3 and cnode6

      fnode = node9

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 !----------------------------------------------------------
 ! node10 <- cnode1 and cnode2

      fnode = node10

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node11 <- cnode2 and cnode3

      fnode = node11

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node12 <- cnode3 and cnode1

      fnode = node12

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 !----------------------------------------------------------
 ! Face-centered fnodes: use 4 cnodes.
 ! node13 <- cnode1, cnode2, cnode4, cnode5

      fnode = node13

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = quater

      endif

 ! node14 <- cnode2, cnode3, cnode5, cnode6

      fnode = node14

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = quater

      endif

 ! node15 <- cnode1, cnode3, cnode4, cnode6

      fnode = node15

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = quater

      endif

 !----------------------------------------------------------
 ! node16 <- cnode4 and cnode5

      fnode = node16

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node17 <- cnode5 and cnode6

      fnode = node17

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node18 <- cnode6 and cnode4

      fnode = node18

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 !----------------------------------------------------------
 ! Process face-centered nodes in the case of structured grids.
 !
 ! Note: Remember that the prism consists of prims and hexas.
 !       The base looks like below:
 !
 !             /|\
 !            / | \
 !           /  |  \
 !          /___|___\   <- There is a node inside the triangle!
 !         /    |    \     So, there are 3 such nodes in a prism.
 !        /     |     \
 !       /      |      \
 !      /_______|_______\
 !

   prism_strct : if (strct_grid) then

     node19 = cprs(i,19)
     node20 = cprs(i,20)
     node21 = cprs(i,21)

    ! node19 (bottom) <- cnode1, cnode2, cnode3

      fnode = node19

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = third

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = third

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = third

      endif

    ! node20 (middle) <- all 6 cnodes.

      fnode = node20

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = sixth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = sixth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = sixth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = sixth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = sixth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = sixth

      endif

    ! node21 (top) <- cnode4, cnode5, cnode6

      fnode = node21

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = third

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = third

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = third

      endif

   endif prism_strct


  end do prs_loop

 !----------------------------------------
 !- Hex region
 !----------------------------------------

  mixed_ph_prorongation : if (mixed_ph .or. strct_grid) then

  hex_loop : do i = 1, nchex

 !--------------------------------------------------
 !
 !  o : Coarse grid nodes
 !  x : Removed fine-grid nodes
 !
 !                        8                                    7
 !                        o ----------------------------------o
 !                     .  .                                 . |
 !                  .     .                              .    |
 !               .        .                            .      |
 !            .           .                         .         |
 !         .              .                      .            |
 !      .                 .                   .               |
 !   5 o-------------------------------------o 6              |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                4 o  .  .  .  .  .   |  .  .  .  .  . o 3
 !     |               .                     |              .
 !     |            .                        |           .
 !     |         .                           |         .
 !     |      .                              |      .
 !     |   .                                 |   .
 !     |.                                    |.
 !   1 o-------------------------------------o 2
 !                         
 !
 ! Side faces: 
 !
 !     4        21       5       6        22       7
 !     o--------x--------o       o--------x--------o
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |17      |       |        |18      |
 !    9x--------x--------x10   10x--------x--------x11
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     o--------x--------o       o--------x--------o
 !     1       13        2       2       14        3
 !
 !
 !     7        23       8       8        24       5
 !     o--------x--------o       o--------x--------o
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |19      |       |        |20      |
 !   11x--------x--------x12   12x--------x--------x9
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     o--------x--------o       o--------x--------o
 !     3       15        4       4       16        1
 !
 !
 !           Top face                Bottom face
 !
 !     8        23       7       4        15       3
 !     o--------x--------o       o--------x--------o
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |26      |       |        |25      |
 !   24x--------x--------x22   16x--------x--------x14
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     o--------x--------o       o--------x--------o
 !     5       21        6       1       13        2
 !
 !
 ! 27: the f-grid node at the center of the c-grid hexa volume.
 !

 ! Note: chex is still based on f-grid nodes.

     node1  = chex(i,1)
     node2  = chex(i,2)
     node3  = chex(i,3)
     node4  = chex(i,4)
     node5  = chex(i,5)
     node6  = chex(i,6)
     node7  = chex(i,7)
     node8  = chex(i,8)

    cnode1  = f2c(node1)
    cnode2  = f2c(node2)
    cnode3  = f2c(node3)
    cnode4  = f2c(node4)
    cnode5  = f2c(node5)
    cnode6  = f2c(node6)
    cnode7  = f2c(node7)
    cnode8  = f2c(node8)

     node9  = chex(i,9)
     node10 = chex(i,10)
     node11 = chex(i,11)
     node12 = chex(i,12)

     node13 = chex(i,13)
     node14 = chex(i,14)
     node15 = chex(i,15)
     node16 = chex(i,16)

     node17 = chex(i,17)
     node18 = chex(i,18)
     node19 = chex(i,19)
     node20 = chex(i,20)

     node21 = chex(i,21)
     node22 = chex(i,22)
     node23 = chex(i,23)
     node24 = chex(i,24)

     node25 = chex(i,25)
     node26 = chex(i,26)

     node27 = chex(i,27)

 !----------------------------------------------------------
 ! node9 <- cnode1 and cnode4

      fnode = node9

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node10 <- cnode2 and cnode5

      fnode = node10

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node11 <- cnode3 and cnode7

      fnode = node11

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode7
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node12 <- cnode4 and cnode8

      fnode = node12

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode8
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 !----------------------------------------------------------
 ! node13 <- cnode1 and cnode2

      fnode = node13

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node14 <- cnode2 and cnode3

      fnode = node14

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node15 <- cnode3 and cnode4

      fnode = node15

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node16 <- cnode4 and cnode1

      fnode = node16

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 !----------------------------------------------------------
 ! Centered at side faces
 ! node17 <- cnode1, node2, node5, node6

      fnode = node17

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = quater

      endif

 ! node18 <- cnode2, node3, node6, node7

      fnode = node18

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode7
       coeff_prolong(n_coeff(fnode),fnode) = quater

      endif

 ! node19 <- cnode3, node4, node7, node8

      fnode = node19

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode7
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode8
       coeff_prolong(n_coeff(fnode),fnode) = quater

      endif

 ! node20 <- cnode1, node4, node5, node8

      fnode = node20

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode8
       coeff_prolong(n_coeff(fnode),fnode) = quater

      endif

 !----------------------------------------------------------
 ! node21 <- cnode4 and cnode5

      fnode = node21

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node22 <- cnode6 and cnode7

      fnode = node22

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode7
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node23 <- cnode7 and cnode8

      fnode = node23

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode7
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode8
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 ! node24 <- cnode8 and cnode5

      fnode = node24

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode8
       coeff_prolong(n_coeff(fnode),fnode) = half

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = half

      endif

 !----------------------------------------------------------
 ! Centered at bottom and top faces
 ! node25 <- cnode1, node2, node3, node4

      fnode = node25

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = quater

      endif

 ! node26 <- cnode5, node6, node7, node8

      fnode = node26

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode7
       coeff_prolong(n_coeff(fnode),fnode) = quater

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode8
       coeff_prolong(n_coeff(fnode),fnode) = quater

      endif

 !----------------------------------------------------------
 ! Center of the hex volume
 ! node27 <- all 8 cnodes.
 
      fnode = node27

      if (n_coeff(fnode) == 0) then

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode1
       coeff_prolong(n_coeff(fnode),fnode) = eighth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode2
       coeff_prolong(n_coeff(fnode),fnode) = eighth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode3
       coeff_prolong(n_coeff(fnode),fnode) = eighth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode4
       coeff_prolong(n_coeff(fnode),fnode) = eighth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode5
       coeff_prolong(n_coeff(fnode),fnode) = eighth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode6
       coeff_prolong(n_coeff(fnode),fnode) = eighth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode7
       coeff_prolong(n_coeff(fnode),fnode) = eighth

       n_coeff(fnode) = n_coeff(fnode) + 1
       cnode_prolong(n_coeff(fnode),fnode) = cnode8
       coeff_prolong(n_coeff(fnode),fnode) = eighth

      endif

  end do hex_loop

  endif mixed_ph_prorongation


  write(*,*) " Max(cnode nghbors) = ", maxval(n_coeff(:))
  write(*,*) " Min(cnode nghbors) = ", minval(n_coeff(:))

 !Check if any f-grid node is missed.
   err = .false.
  do i = 1, nnodes
   if (n_coeff(i)==0) then
    if (.not.err) write(*,*) " Not processed for prolongation... Wrong. Stop."
    write(777,*) " i = ", i
    write(777,*) "      n_coeff(i) = ", n_coeff(i) 
    write(777,*) "          f2c(i) = ", f2c(i)
    if (.not.err) write(*,*) " Error in nc prolong. See fort.777."
    err = .true.
   endif
  end do

  if (err) stop

!---------------------------------------------------------------------------
!---------------------------------------------------------------------------

 write(*,*)
 write(*,*) " Writing a prolongation file: ", filename_prolong_nc
 call write_prolong_file_nc

!---------------------------------------------------------------------------
! Write out a list of removed nodes for the current level.

  write(*,*)
  write(*,*) " Writing a removed node list file: ", filename_rmp
  call write_rmp_file_c
  write(*,*)

!*******************************************************************************
!
! End of prolongation information for NC
!
!*******************************************************************************


 !------------------------------------------------
 ! Prismatic elements defined with coarse-grid numbers.

  do i = 1, ncprs
   cprs(i,1) = f2c(cprs(i,1))
   cprs(i,2) = f2c(cprs(i,2))
   cprs(i,3) = f2c(cprs(i,3))
   cprs(i,4) = f2c(cprs(i,4))
   cprs(i,5) = f2c(cprs(i,5))
   cprs(i,6) = f2c(cprs(i,6))
  end do

 !------------------------------------------------
 ! Hex elements defined with coarse-grid numbers.

  if (nchex > 0) then
  do i = 1, nchex
   chex(i,1) = f2c(chex(i,1))
   chex(i,2) = f2c(chex(i,2))
   chex(i,3) = f2c(chex(i,3))
   chex(i,4) = f2c(chex(i,4))
   chex(i,5) = f2c(chex(i,5))
   chex(i,6) = f2c(chex(i,6))
   chex(i,7) = f2c(chex(i,7))
   chex(i,8) = f2c(chex(i,8))
  end do
  endif

 !------------------------------------------------
 ! Tet elements defined with coarse-grid numbers.

  do i = 1, nctet
   ctet(i,1) = f2c(ctet(i,1))
   ctet(i,2) = f2c(ctet(i,2))
   ctet(i,3) = f2c(ctet(i,3))
   ctet(i,4) = f2c(ctet(i,4))
  end do

 !------------------------------------------------
 ! Construct tetra neighbor data

  if (nctet > 0) then

   allocate(ncnghbrs_tet(ncnodes))
   allocate(  cnghbr_tet(ncnodes,100) )

    ncnghbrs_tet = 0
   do i = 1, nctet

    k = ctet(i,1)
    ncnghbrs_tet(k) = ncnghbrs_tet(k) + 1
    cnghbr_tet(k,ncnghbrs_tet(k)) = i

    k = ctet(i,2)
    ncnghbrs_tet(k) = ncnghbrs_tet(k) + 1
    cnghbr_tet(k,ncnghbrs_tet(k)) = i

    k = ctet(i,3)
    ncnghbrs_tet(k) = ncnghbrs_tet(k) + 1
    cnghbr_tet(k,ncnghbrs_tet(k)) = i

    k = ctet(i,4)
    ncnghbrs_tet(k) = ncnghbrs_tet(k) + 1
    cnghbr_tet(k,ncnghbrs_tet(k)) = i

   end do

   write(*,*) " Tetra neighbor list constructed for c-grid... "

  else

   allocate(ncnghbrs_tet(ncnodes))
    ncnghbrs_tet = 0
   allocate(  cnghbr_tet(1,1) )

  endif

 !------------------------------------------------
 ! Tria elements defined with coarse-grid numbers.

  do i = 1, nctria
   ctria(i,1) = f2c(ctria(i,1))
   ctria(i,2) = f2c(ctria(i,2))
   ctria(i,3) = f2c(ctria(i,3))
  end do

 !------------------------------------------------
 ! Quad elements defined with coarse-grid numbers.

  do i = 1, ncquad
   cquad(i,1) = f2c(cquad(i,1))
   cquad(i,2) = f2c(cquad(i,2))
   cquad(i,3) = f2c(cquad(i,3))
   cquad(i,4) = f2c(cquad(i,4))
  end do

!
! The coarse grid has been completely determined at this point.
! Below, coarse-grid element information will be used only for writing
! grid files, not for generating line information and prolongation information.
!

 write(*,*) "   ncnodes = ", ncnodes
 write(*,*) " max(ctet) = ", maxval(ctet)
 write(*,*) " max(cprs) = ", maxval(cprs)
 if (nchex > 0) write(*,*) " max(chex) = ", maxval(chex)


!*******************************************************************************
!
! End of prolongation information
!
!*******************************************************************************

!*******************************************************************************
!*******************************************************************************
!
! Negative volume check.
!
! Note: The code will proceed even if negative volumes are detected.
!       Some solvers work just fine with zero/negative-volume elements.
!
!       Ref.: H. Nishikawa, "Uses of Zero and Negative Volume Elements for
!             Node-Centered Edge-Based Discretization", AIAA Paper 2017-4295,
!             23rd AIAA CFD Conference, 5 - 9 June 2017, Denver, Colorado.
!             http://hiroakinishikawa.com/My_papers/nishikawa_aiaa2017-4295.pdf
!
!*******************************************************************************
!*******************************************************************************

  write(*,*)
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*)
  write(*,*) ">>> Check element volumes for the coarse grid..."
  write(*,*)
  write(*,*) "  # of Tetrahedra = ", nctet
  write(*,*) "  # of Hexahedra  = ", nchex
  write(*,*) "  # of Prisms     = ", ncprs
  write(*,*)

  call volume_check(negative_volume_detected)

  !negative_volume_detected(1) = T if negative Tet   detected.
  !negative_volume_detected(2) = T if negative Hexa  detected.
  !negative_volume_detected(3) = T if negative Prism detected.

  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*)

!*******************************************************************************
!*******************************************************************************
!
! Check non-planerity of quadrilateral element-faces.
!
!*******************************************************************************
!*******************************************************************************

  write(*,*)
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*)
  write(*,*) ">>> Check non-planerity of quadrilateral faces..."
  write(*,*)

  if (nchex == 0 .and. ncprs == 0) then

   write(*,*) " Well, this is a pure tet grid, and so, "
   write(*,*) " no quadrilateral faces exist. Skip the check! "

  else

   call non_planarity_check

  endif

  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*) ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  write(*,*)


  if (maxval(cell_body) > nctet+ncprs+nchex) then
   write(*,*) " Something is wrong... "
   write(*,*) "     maxval(cell_body) > nctet+ncprs+nchex"
   stop
  endif

!*******************************************************************************
!
! Start of output
!
!*******************************************************************************

  write(*,*)
  write(*,*) "**************************************************************"
  write(*,*) " 8. Write output files."
  write(*,*) "**************************************************************"

  write(*,*)
  if (generate_tec_file_b) then
   write(*,*) " Writing a tecplot boundary file: ", filename_tecplot_b
   call write_tecplot_boundary_file_c
  else
   write(*,*) " Skipped writing a tecplot boundary file... "
  endif

  write(*,*)
  if (generate_tec_file_vol) then
   write(*,*) " Writing a tecplot volume file: ", filename_tecplot_v
   call write_tecplot_volume_file_c
  else
   write(*,*) " Skipped writing a tecplot volume file... "
  endif

  write(*,*)
  write(*,*) " Writing coarse-grid .ugrid file: ", filename_ugrid
  call write_ugrid_file_c

  write(*,*)
  write(*,*) " Writing coarse-grid .lines_fmt file: ", filename_lines
  call line_info_file_c

  write(*,*)
  write(*,*) " Writing coarse-grid .lines_fmt_all file: ", filename_lines_all
  call line_info_file_all_c

 ! Coarse-grid cell center coordinates (for cc line files):

  allocate(ccell(nctet+ncprs+nchex))

    if (nctet > 0) then
     do i = 1, nctet
      ccell(i)%x = (xc(ctet(i,1))+xc(ctet(i,2))+xc(ctet(i,3))+xc(ctet(i,4)))/4.0_dp
      ccell(i)%y = (yc(ctet(i,1))+yc(ctet(i,2))+yc(ctet(i,3))+yc(ctet(i,4)))/4.0_dp
      ccell(i)%z = (zc(ctet(i,1))+zc(ctet(i,2))+zc(ctet(i,3))+zc(ctet(i,4)))/4.0_dp
     end do
    endif

    if (ncprs > 0) then
     do i = 1, ncprs
      ccell(nctet+i)%x = ( xc(cprs(i,1))+xc(cprs(i,2))+xc(cprs(i,3)) &
                          +xc(cprs(i,4))+xc(cprs(i,5))+xc(cprs(i,6)) )/6.0_dp
      ccell(nctet+i)%y = ( yc(cprs(i,1))+yc(cprs(i,2))+yc(cprs(i,3)) &
                          +yc(cprs(i,4))+yc(cprs(i,5))+yc(cprs(i,6)) )/6.0_dp
      ccell(nctet+i)%z = ( zc(cprs(i,1))+zc(cprs(i,2))+zc(cprs(i,3)) &
                          +zc(cprs(i,4))+zc(cprs(i,5))+zc(cprs(i,6)) )/6.0_dp
     end do
    endif

    if (nchex > 0) then
     do i = 1, nchex
      ccell(nctet+ncprs+i)%x = (xc(chex(i,1))+xc(chex(i,2))+xc(chex(i,3))+xc(chex(i,4)) &
                             +  xc(chex(i,5))+xc(chex(i,6))+xc(chex(i,7))+xc(chex(i,8)))/8.0_dp
      ccell(nctet+ncprs+i)%y = (yc(chex(i,1))+yc(chex(i,2))+yc(chex(i,3))+yc(chex(i,4)) &
                             +  yc(chex(i,5))+yc(chex(i,6))+yc(chex(i,7))+yc(chex(i,8)))/8.0_dp
      ccell(nctet+ncprs+i)%z = (zc(chex(i,1))+zc(chex(i,2))+zc(chex(i,3))+zc(chex(i,4)) &
                             +  zc(chex(i,5))+zc(chex(i,6))+zc(chex(i,7))+zc(chex(i,8)))/8.0_dp
     end do
    endif

  write(*,*)
  write(*,*) " Writing coarse-grid .lines_cc_fmt file: ", filename_lines_cc
  call line_info_file_cc_c

  write(*,*)
  write(*,*) " Writing coarse-grid .lines_cc_fmt_all file: ", filename_lines_cc_all
  call line_info_file_cc_all_c

  write(*,*)
  write(*,*) " Writing coarse-grid .k file: ", filename_k
  call write_k_file_c

  write(*,*)
  write(*,*) " Writing a boundary map file......."

  open(unit=16, file=filename_mapbc, status="unknown", iostat=os)

 !Full domain
  full_geometry_mapbc : if (.not.half_geom) then

   if ( trim(project)=="hch_prism" .or. trim(project)=="hch_tetra"    .or. &
        trim(project)=="hch_mixed" .or. trim(project)=="hch_mixed_ph" .or. &
        trim(project)=="hch_strct" ) then

    write(*,*) " Full geometry -> 2 boundary groups."
    write(*,*) "   --- (1)HCH axisymmetric body."
    write(*,*) "   --- (2)Farfield"

    write(16,'(a57)') "2       !Number of boundary parts (boundary conditions)"
    write(16,'(a32)') "1, 4000 !Viscous wall in FUN3D"
    write(16,'(a55)') "2, 5050 !Characteristic-based inflow/outflow in FUN3D"

   endif

 !Half-domain
  else

    write(*,*) " Partial geometry -> 3 boundary groups."
    write(*,*) "   --- (1)HCH axisymmetric body."
    write(*,*) "   --- (2)Farfield"
    write(*,*) "   --- (3)y-symmetry"

    write(16,'(a57)') "3       !Number of boundary parts (boundary conditions)"
    write(16,'(a32)') "1, 4000 !Viscous wall in FUN3D"
    write(16,'(a55)') "2, 5050 !Characteristic-based inflow/outflow in FUN3D"
    write(16,'(a22)') "3, 6662 !Y-Symmetry?"

  endif full_geometry_mapbc

  close(16)

   write(*,*) " Boundary info file written:", filename_mapbc

  if (strct_grid) then

   write(*,*) " Writing a PLOT3D file..... "
   write(*,*) " Writing a .nmf file..... "
    call write_plot3d_file
   write(*,*) "PLOT3D file written : ", filename_p3d
   write(*,*) "  .nmf file written : ", filename_nmf

  endif


  write(*,*)
  write(*,*) "Grid generation successfully completed at level ", icgrid

!*******************************************************************************
!
! End of output
!
!*******************************************************************************

!*******************************************************************************
! Deallocate arrays and move on to the next coarse grid if feasible.
!*******************************************************************************

  deallocate(node, k1, k2, k3, k4, k5)
  if (allocated( tria)) deallocate(tria)
  if (allocated(  tet)) deallocate(tet)
  if (allocated(  prs)) deallocate(prs)
  if (allocated(  hex)) deallocate(hex)
  if (allocated( quad)) deallocate(quad)
  if (allocated(ctria)) deallocate(ctria)
  if (allocated(cquad)) deallocate(cquad)
  if (allocated(ctria2)) deallocate(ctria2)
  if (allocated(cquad2)) deallocate(cquad2)
  if (allocated( cprs)) deallocate(cprs)
  if (allocated(ccprs)) deallocate(ccprs)
  if (allocated( chex)) deallocate(chex)
  if (allocated( ctet)) deallocate(ctet)
  deallocate(xf, yf, zf)
  deallocate(xc, yc, zc)
  deallocate(k2n)
  deallocate(k2nc)
  deallocate(f2c)
  deallocate(ncnghbrs_tet)
  deallocate(cnghbr_tet)
  deallocate(kc1, kc2, kc3, kc4, kc5)
  deallocate(fline)
  deallocate(cline)
  deallocate(fline_all)
  deallocate(cline_all)
  deallocate(n_coeff)
  deallocate(cnode_prolong)
  deallocate(coeff_prolong)

  deallocate(cell_above,cell_body)
  deallocate(ccell)
  deallocate(nccells_prolong)
  deallocate(  ccell_prolong)
  deallocate(fline_cc_all)
  deallocate(ncelms, celm)
  deallocate(nfelms, felm)

  deallocate(dual_vol)

 end do coarse_levels

!*******************************************************************************
!*******************************************************************************
!
! End of coarse grid generation loop.
!
!*******************************************************************************
!*******************************************************************************

 write(*,*) "-----------------------------------------------------------------"
 write(*,*) "-----------------------------------------------------------------"
 write(*,*) " Post processing..."
 write(*,*) "-----------------------------------------------------------------"
 write(*,*) "-----------------------------------------------------------------"
 write(*,*)

!*******************************************************************************
! Write out the volume and heff information for all grids.
!*******************************************************************************

  if (generate_heff_vol_report) then

   write(*,*) " Writing vol/heff information for all grids: ", trim(filename_heff_vol)
   call write_heff_vol_info

  else

   write(*,*) " Skipped writing the volume/heff info file... ", trim(filename_heff_vol)

  endif

!*******************************************************************************
! Write out natural partition files for all levels.
!*******************************************************************************

  if (generate_ntrl_partition_files) then

   write(*,*) " Writing natural partition files (.ntrl_part) for all grids..... "
   call write_ntrl_part_files_cc !project.level.cc.ntrl_part_xxx (xxx = # of partitions)

  else

   write(*,*) " Skipped writing natural partition files ... "

  endif

 write(*,*)
 write(*,*) " End of post processing. "
 write(*,*) "-----------------------------------------------------------------"
 write(*,*) "-----------------------------------------------------------------"
 write(*,*)

!*******************************************************************************
!*******************************************************************************

  write(*,*)
  write(*,*) " End of the coarsening program. Bye."
  write(*,*)

 stop


contains 

!*******************************************************************************
! This subroutine writes a Tecplot file for boundaries.
!******************************************************************************
 subroutine write_tecplot_boundary_file_c

 integer(kd) :: nelms
 integer(kd)                               :: nnodes_loc, i, j, k, i_boundary
 integer(kd),  dimension(:,:), allocatable :: g2l
 integer(kd),  dimension(:  ), allocatable :: l2g

 open(unit=7, file=filename_tecplot_b, status="unknown", iostat=os)
 write(7,*) 'TITLE = "GRID"'
 write(7,*) 'VARIABLES = "x","y","z","k1","k2","k3","k4","k5"'

 allocate(g2l(ncnodes,2))
 allocate(l2g(ncnodes  ))

!--------------------------------------------------------------
! Triangles on the HCH surface: i_boundary = 1.

  i_boundary = 1

       nelms = 0
  nnodes_loc = 0
         g2l = -1
  do i = 1, nctria
   if ( ctria(i,5) == i_boundary ) then
    nelms = nelms + 1
    do k = 1, 3
     if (g2l(ctria(i,k),2) == -1) then
      nnodes_loc = nnodes_loc + 1
      g2l(ctria(i,k),1) = nnodes_loc
      g2l(ctria(i,k),2) = 100 !Flag to indicate the node is recorded.
      l2g(nnodes_loc)   = ctria(i,k)
     endif
    end do
   endif
  end do

  if (nelms > 0) then
   write(7,*) 'ZONE T="HCH body: triangles"  N=', nnodes_loc,',E=', nelms,' , ET=quadrilateral, F=FEPOINT'

   do j = 1, nnodes_loc
     i = l2g(j)
     write(7,'(3ES20.10,5i13)') xc(i),yc(i),zc(i), kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

   do i = 1, nctria
    if ( ctria(i,5) == i_boundary ) write(7,'(4I12)') g2l(ctria(i,1),1), g2l(ctria(i,2),1), &
                                                      g2l(ctria(i,3),1), g2l(ctria(i,3),1)
   end do
  endif

!--------------------------------------------------------------
! Triangles on the farfield: i_boundary = 2

  i_boundary = 2

       nelms = 0
  nnodes_loc = 0
         g2l = -1
  do i = 1, nctria
   if ( ctria(i,5) == i_boundary ) then
    nelms = nelms + 1
    do k = 1, 3
     if (g2l(ctria(i,k),2) == -1) then
      nnodes_loc = nnodes_loc + 1
      g2l(ctria(i,k),1) = nnodes_loc
      g2l(ctria(i,k),2) = 100 !Flag to indicate the node is recorded.
      l2g(nnodes_loc)   = ctria(i,k)
     endif
    end do
   endif
  end do

  if (nelms > 0) then
   write(7,*) 'ZONE T="Outflow: triangles"  N=', nnodes_loc,',E=', nelms,' , ET=quadrilateral, F=FEPOINT'

   do j = 1, nnodes_loc
     i = l2g(j)
     write(7,'(3ES20.10,5i13)') xc(i),yc(i),zc(i), kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

   do i = 1, nctria
    if ( ctria(i,5) == i_boundary ) write(7,'(4I12)') g2l(ctria(i,1),1), g2l(ctria(i,2),1), &
                                                      g2l(ctria(i,3),1), g2l(ctria(i,3),1)
   end do
  endif

!--------------------------------------------------------------
! Triangles on the symmetry plane 1: i_boundary = 3

  i_boundary = 3

       nelms = 0
  nnodes_loc = 0
         g2l = -1
  do i = 1, nctria
   if ( ctria(i,5) == i_boundary ) then
    nelms = nelms + 1
    do k = 1, 3
     if (g2l(ctria(i,k),2) == -1) then
      nnodes_loc = nnodes_loc + 1
      g2l(ctria(i,k),1) = nnodes_loc
      g2l(ctria(i,k),2) = 100 !Flag to indicate the node is recorded.
      l2g(nnodes_loc)   = ctria(i,k)
     endif
    end do
   endif
  end do

  if (nelms > 0) then
   write(7,*) 'ZONE T="Symmetry: triangles"  N=', nnodes_loc,',E=', nelms,' , ET=quadrilateral, F=FEPOINT'

   do j = 1, nnodes_loc
     i = l2g(j)
     write(7,'(3ES20.10,5i13)') xc(i),yc(i),zc(i), kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

   do i = 1, nctria
    if ( ctria(i,5) == i_boundary ) write(7,'(4I12)') g2l(ctria(i,1),1), g2l(ctria(i,2),1), &
                                                      g2l(ctria(i,3),1), g2l(ctria(i,3),1)
   end do
  endif

!--------------------------------------------------------------
!--------------------------------------------------------------

 if (ncquad > 0) then

 !--------------------------------------------------------------
 !Body: i_boundary = 1.

  i_boundary = 1

       nelms = 0
  nnodes_loc = 0
         g2l = -1
  do i = 1, ncquad
   if ( cquad(i,5) == i_boundary ) then
    nelms = nelms + 1
    do k = 1, 4
     if (g2l(cquad(i,k),2) == -1) then
      nnodes_loc = nnodes_loc + 1
      g2l(cquad(i,k),1) = nnodes_loc
      g2l(cquad(i,k),2) = 100 !Flag to indicate the node is recorded.
      l2g(nnodes_loc)   = cquad(i,k)
     endif
    end do
   endif
  end do

  if (nelms > 0) then
   write(7,*) 'ZONE T="HC body: quads"  N=', nnodes_loc,',E=', nelms,' , ET=quadrilateral, F=FEPOINT'

   do j = 1, nnodes_loc
     i = l2g(j)
     write(7,'(3ES20.10,5i13)') xc(i),yc(i),zc(i), kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

   do i = 1, ncquad
    if ( cquad(i,5) == i_boundary ) write(7,'(4I12)') g2l(cquad(i,1),1), g2l(cquad(i,2),1), &
                                                      g2l(cquad(i,3),1), g2l(cquad(i,4),1)
   end do
  endif


 !--------------------------------------------------------------
 !Farfield boundary: i_boundary = 2.

  i_boundary = 2

       nelms = 0
  nnodes_loc = 0
         g2l = -1
  do i = 1, ncquad
   if ( cquad(i,5) == i_boundary ) then
    nelms = nelms + 1
    do k = 1, 4
     if (g2l(cquad(i,k),2) == -1) then
      nnodes_loc = nnodes_loc + 1
      g2l(cquad(i,k),1) = nnodes_loc
      g2l(cquad(i,k),2) = 100 !Flag to indicate the node is recorded.
      l2g(nnodes_loc)   = cquad(i,k)
     endif
    end do
   endif
  end do

  if (nelms > 0) then
   write(7,*) 'ZONE T="Outflow: quads"  N=', nnodes_loc,',E=', nelms,' , ET=quadrilateral, F=FEPOINT'

   do j = 1, nnodes_loc
     i = l2g(j)
     write(7,'(3ES20.10,5i13)') xc(i),yc(i),zc(i), kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

   do i = 1, ncquad
    if ( cquad(i,5) == i_boundary ) write(7,'(4I12)') g2l(cquad(i,1),1), g2l(cquad(i,2),1), &
                                                      g2l(cquad(i,3),1), g2l(cquad(i,4),1)
   end do
  endif

!--------------------------------------------------------------
! Symmetry plane: i_boundary = 3

  i_boundary = 3

       nelms = 0
  nnodes_loc = 0
         g2l = -1
  do i = 1, ncquad
   if ( cquad(i,5) == i_boundary ) then
    nelms = nelms + 1
    do k = 1, 4
     if (g2l(cquad(i,k),2) == -1) then
      nnodes_loc = nnodes_loc + 1
      g2l(cquad(i,k),1) = nnodes_loc
      g2l(cquad(i,k),2) = 100 !Flag to indicate the node is recorded.
      l2g(nnodes_loc)   = cquad(i,k)
     endif
    end do
   endif
  end do

  if (nelms > 0) then
   write(7,*) 'ZONE T="Symmetry: quads"  N=', nnodes_loc,',E=', nelms,' , ET=quadrilateral, F=FEPOINT'

   do j = 1, nnodes_loc
     i = l2g(j)
     write(7,'(3ES20.10,5i13)') xc(i),yc(i),zc(i), kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

   do i = 1, ncquad
    if ( cquad(i,5) == i_boundary ) write(7,'(4I12)') g2l(cquad(i,1),1), g2l(cquad(i,2),1), &
                                                      g2l(cquad(i,3),1), g2l(cquad(i,4),1)
   end do
  endif

 endif

 close(7)

 deallocate(g2l,l2g)

 end subroutine write_tecplot_boundary_file_c
!*******************************************************************************
! This subroutine writes a Tecplot file for the volume grid.
!*******************************************************************************
 subroutine write_tecplot_volume_file_c

 open(unit=8, file=filename_tecplot_v, status="unknown", iostat=os)
 write(8,*) 'TITLE = "GRID"'
 write(8,*) 'VARIABLES = "x","y","z","k1","k2","k3","k4","k5"'

! Tetra Zone
  if (nctet > 0) then

   write(8,*) 'zone t="Tetra" n=', ncnodes,',e=', nctet,' , et=tetrahedron, f=fepoint'
   do i = 1, ncnodes
     write(8,'(3es20.10,5i13)') xc(i),yc(i),zc(i), &
                                kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

   do i = 1, nctet
    write(8,'(4i12)') ctet(i,1), ctet(i,2), ctet(i,3), ctet(i,4)
   end do

  endif

! Prism zone
  if (ncprs > 0) then

   write(8,*) 'zone t="Prism"  n=', ncnodes,',e=', ncprs,' , et=brick, f=fepoint'
   do i = 1, ncnodes
     write(8,'(3es20.10,5i13)') xc(i),yc(i),zc(i), &
                                kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

   do i = 1, ncprs
    write(8,'(8i12)') cprs(i,1), cprs(i,2), cprs(i,3), cprs(i,3), &
                      cprs(i,4), cprs(i,5), cprs(i,6), cprs(i,6)
   end do

  endif

! Hex zone
  if (nchex > 0) then

   write(8,*) 'zone t="Hex"  n=', ncnodes,',e=', nchex,' , et=brick, f=fepoint'
   do i = 1, ncnodes
     write(8,'(3es20.10,5i13)') xc(i),yc(i),zc(i), &
                                kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

   do i = 1, nchex
    write(8,'(8i12)') chex(i,1), chex(i,2), chex(i,3), chex(i,4), &
                      chex(i,5), chex(i,6), chex(i,7), chex(i,8)
   end do

  endif

 close(8)

 end subroutine write_tecplot_volume_file_c
!********************************************************************************

!*******************************************************************************
! This subroutine writes a .ugrid file.
!*******************************************************************************
 subroutine write_ugrid_file_c

  if ( ugrid_file_unformatted ) then
  open(unit=9, file=filename_ugrid, form='unformatted',access="stream",&
                                      status='unknown', iostat=os )
   write(9) ncnodes, nctria, ncquad, nctet, 0, ncprs, nchex
  else
  !  #nodes, #tri_faces, #quad_faces, #tetra, #pyr, #prz, #hex
   write(9,'(7I12)') ncnodes, nctria, ncquad, nctet, 0, 0, ncprs, nchex
  endif

!---------------------------------------------------------------
!(1) Unformatted grid file
!---------------------------------------------------------------

  if ( ugrid_file_unformatted ) then

  ! Nodes
    do i = 1, ncnodes
     write(9) xc(i), yc(i), zc(i)
    end do

  ! Triangular faces = ntri
    if (nctria > 0) then
     do i = 1, nctria
      write(9) ctria(i,1), ctria(i,2), ctria(i,3)
     end do
    endif

  ! Quad faces = nquad
    if (ncquad > 0) then
     do i = 1, ncquad
      write(9) cquad(i,1), cquad(i,2), cquad(i,3), cquad(i,4)
     end do
    endif

  ! Face tag
    if (nctria > 0) then
     do i = 1, nctria
      write(9) ctria(i,5)
     end do
    endif

    if (ncquad > 0) then
     do i = 1, ncquad
      write(9) cquad(i,5)
     end do
    endif

  ! tet
    if (nctet > 0) then
     do i = 1, nctet
      write(9) ctet(i,1), ctet(i,2), ctet(i,3), ctet(i,4)
     end do
    endif

  ! Prism
    if (ncprs > 0) then
     do i = 1, ncprs
      write(9) cprs(i,1), cprs(i,2), cprs(i,3), &
               cprs(i,4), cprs(i,5), cprs(i,6)
     end do
    endif

  ! Hex
    if (nchex > 0) then
     do i = 1, nchex
      write(9) chex(i,1), chex(i,2), chex(i,3), &
               chex(i,4), chex(i,5), chex(i,6), chex(i,7), chex(i,8)
     end do
    endif

!---------------------------------------------------------------
!(2) Formatted grid file
!---------------------------------------------------------------

  else

  ! Nodes
    do i = 1, ncnodes
     write(9,'(3ES20.10)') xc(i), yc(i), zc(i)
    end do

  ! Triangular faces = ntri
    if (nctria > 0) then
     do i = 1, nctria
      write(9,'(3I12)') ctria(i,1), ctria(i,2), ctria(i,3)
     end do
    endif

  ! Quad faces = nquad
    if (ncquad > 0) then
     do i = 1, ncquad
      write(9,'(4I12)') cquad(i,1), cquad(i,2), cquad(i,3), cquad(i,4)
     end do
    endif

  ! Face tag
    if (nctria > 0) then
     do i = 1, nctria
      write(9,'(I12)') ctria(i,5)
     end do
    endif

    if (ncquad > 0) then
     do i = 1, ncquad
      write(9,'(I12)') cquad(i,5)
     end do
    endif

  ! tet
    if (nctet > 0) then
     do i = 1, nctet
      write(9,'(4I20)') ctet(i,1), ctet(i,2), ctet(i,3), ctet(i,4)
     end do
    endif

  ! Prism
    if (ncprs > 0) then
     do i = 1, ncprs
      write(9,'(6I12)') cprs(i,1), cprs(i,2), cprs(i,3), &
                        cprs(i,4), cprs(i,5), cprs(i,6)
     end do
    endif

  ! Hex
    if (nchex > 0) then
     do i = 1, nchex
      write(9,'(8I12)') chex(i,1), chex(i,2), chex(i,3), &
                        chex(i,4), chex(i,5), chex(i,6), chex(i,7), chex(i,8)
     end do
    endif

   endif

!---------------------------------------------------------------
! End of Unformatted or Formatted
!---------------------------------------------------------------

  close(9)

 end subroutine write_ugrid_file_c

!*******************************************************************************
!* Write out a file containing line info (only within the BL region):
!* This information is for the implicit line relaxations or line agglomeration.
!* This format is used by FUN3D.
!*******************************************************************************
 subroutine line_info_file_c
 implicit none

 integer(kd) :: i, k, i_count, os
 integer(kd) :: i_pts


  open(unit=1, file=filename_lines, status="unknown", iostat=os)

  write(*,*) " Total number of lines = ", n_clines
  write(*,*) "            max points = ", max_cpoints
  write(*,*) "            min points = ", min_cpoints

  write(1,*) n_clines, n_total_cpoints, "Total lines and points"
  write(1,*) min_cpoints, max_cpoints, "Min and max points in line"

  i_count = 0
    i_pts = 0

  do i = 1, n_clines

     i_count = i_count + 1

!  1. First node (on the body)
     write(1,*) max_cpoints, " Points in line for line = ", i_count
     write(1,'(i12,a10,3es30.20)') cline(1,i), " x/y/z= ", &
            xc(cline(1,i)), yc(cline(1,i)), zc(cline(1,i))
     i_pts = i_pts + 1

!  2. Second node to the node below the last one.
   do k = 2, max_cpoints-1
     write(1,'(i12)') cline(k,i)
     i_pts = i_pts + 1
   end do

!  3. Last node
     write(1,'(i12,a10,3es30.20)') cline(max_cpoints,i), " x/y/z= ", &
     xc(cline(max_cpoints,i)), yc(cline(max_cpoints,i)), zc(cline(max_cpoints,i))
     i_pts = i_pts + 1

  end do

  write(*,*)
  write(*,*) " Total number of pts written = ", i_pts

 if (i_count /= n_clines) write(*,*) "Error: i_count /= n_lines"
 write(*,*)
 write(*,*) "lines_fmt file has been written: ", filename_lines

 close(1)
 end subroutine line_info_file_c

!*******************************************************************************
!* Write out a file containing line info (Lines go all the way up to the outer):
!* This information is for the implicit line relaxations or line agglomeration.
!* This format is used by FUN3D.
!*******************************************************************************
 subroutine line_info_file_all_c
 implicit none

 integer(kd) :: i, k, i_count, os
 integer(kd) :: i_pts


  open(unit=1, file=filename_lines_all, status="unknown", iostat=os)

  write(*,*) " Total number of lines = ", n_clines_all
  write(*,*) "            max points = ", max_cpoints_all
  write(*,*) "            min points = ", min_cpoints_all

  write(1,*) n_clines_all, n_total_cpoints_all, "Total lines and points"
  write(1,*) min_cpoints_all, max_cpoints_all, "Min and max points in line"

  i_count = 0
    i_pts = 0

  do i = 1, n_clines_all

     i_count = i_count + 1

!  1. First node (on the body)
     write(1,*) max_cpoints_all, " Points in line for line = ", i_count
     write(1,'(i12,a10,3es30.20)') cline_all(1,i), " x/y/z= ", &
            xc(cline_all(1,i)), yc(cline_all(1,i)), zc(cline_all(1,i))
     i_pts = i_pts + 1

!  2. Second node to the node below the last one.
   do k = 2, max_cpoints_all-1
     write(1,'(i12)') cline_all(k,i)
     i_pts = i_pts + 1
   end do

!  3. Last node
     write(1,'(i12,a10,3es30.20)') cline_all(max_cpoints_all,i), " x/y/z= ", &
     xc(cline_all(max_cpoints_all,i)), yc(cline_all(max_cpoints_all,i)), &
     zc(cline_all(max_cpoints_all,i))
     i_pts = i_pts + 1

  end do

  write(*,*)
  write(*,*) " Total number of pts written = ", i_pts

 if (i_pts /= ncnodes) then
  write(*,*) "Error: i_pts /= ncnodes: line_info_file_all_c... Stop"
  stop
 endif

 if (i_count /= n_clines_all) write(*,*) "Error: i_count /= n_lines"
 write(*,*)
 write(*,*) "lines_fmt_all file has been written: ", filename_lines_all

 close(1)
 end subroutine line_info_file_all_c

!*******************************************************************************
!* Write out a file containing line info (only within the BL region):
!* This information is for the implicit line relaxations or line agglomeration.
!*******************************************************************************
 subroutine line_info_file_cc_c
 implicit none

 integer(kd) :: cell_below, icell, os
 integer(kd) :: i, k, n_clines, n_total_ccells, max_ccells, min_ccells

  max_ccells     = ncells_in_line
  min_ccells     = ncells_in_line
  n_clines       = ncells_body
  n_total_ccells = n_clines * max_ccells

  open(unit=1, file=filename_lines_cc, status="unknown", iostat=os)

  write(*,*)
  write(*,*) " Cell-line information: "
  write(*,*) " Total number of lines = ", n_clines
  write(*,*) "            max cells = ", max_ccells
  write(*,*) "            min cells = ", min_ccells

  write(1,*) n_clines, n_total_ccells, "Total lines and cells"
  write(1,*)   min_ccells, max_ccells, "Min and max cells in line"

  do i = 1, ncells_body

!  1. First cell (on the body)
     write(1,*) max_ccells, " Cells in line for line = ", i
     write(1,'(i12,a10,3es30.20)') cell_body(i), " x/y/z= ", ccell(cell_body(i))%x, &
                                       ccell(cell_body(i))%y, ccell(cell_body(i))%z

     cell_below = cell_body(i)

!  2. Second cell to the cell below the last one.
     if (max_ccells > 2) then

      do k = 2, max_ccells-1
        write(1,'(i12)') cell_above(cell_below)
        cell_below = cell_above(cell_below)
      end do

     endif

!  3. Last cell
     if (max_ccells == 1) then
     else
      icell = cell_above(cell_below)
      write(1,'(i12,a10,3es30.20)') icell, " x/y/z= ", ccell(icell)%x, &
                                        ccell(icell)%y, ccell(icell)%z
     endif

  end do

 write(*,*)
 write(*,*) "lines_fmt file has been written: ", filename_lines_cc

 close(1)
 end subroutine line_info_file_cc_c

!*******************************************************************************
!* Write out a file containing line info (only within the BL region):
!* This information is for the implicit line relaxations or line agglomeration.
!*******************************************************************************
 subroutine line_info_file_cc_all_c
 implicit none

 integer(kd) :: cell_below, icell, os
 integer(kd) :: i, k, n_clines, n_total_ccells, max_ccells, min_ccells

  max_ccells     = ncells_in_line_all
  min_ccells     = ncells_in_line_all !max_cpoints_all
  n_clines       = ncells_body
  n_total_ccells = n_clines * max_ccells

  open(unit=1, file=filename_lines_cc_all, status="unknown", iostat=os)

  write(*,*)
  write(*,*) " Cell-line information: "
  write(*,*) " Total number of lines = ", n_clines
  write(*,*) "            max cells = ", max_ccells
  write(*,*) "            min cells = ", min_ccells

  write(1,*) n_clines, n_total_ccells, "Total lines and cells"
  write(1,*)   min_ccells, max_ccells, "Min and max cells in line"

  do i = 1, ncells_body

!  1. First cell (on the body)
     write(1,*) max_ccells, " Cells in line for line = ", i
     write(1,'(i12,a10,3es30.20)') cell_body(i), " x/y/z= ", ccell(cell_body(i))%x, &
                                       ccell(cell_body(i))%y, ccell(cell_body(i))%z

     cell_below = cell_body(i)

!  2. Second cell to the cell below the last one.
   if (max_ccells > 2) then

    do k = 2, max_ccells-1
      write(1,'(i12)') cell_above(cell_below)
      cell_below = cell_above(cell_below)
    end do

   endif

!  3. Last cell
    if (max_ccells == 1) then
    else
     icell = cell_above(cell_below)
     write(1,'(i12,a10,3es30.20)') icell, " x/y/z= ", ccell(icell)%x, &
                                       ccell(icell)%y, ccell(icell)%z
    endif

  end do

 write(*,*)
 write(*,*) "lines_fmt file has been written: ", filename_lines_cc

 close(1)
 end subroutine line_info_file_cc_all_c

!*******************************************************************************
! This subroutine writes an k file, which will be used for
!******************************************************************************
 subroutine write_k_file_c

 !----------------------------------------------------------------------------------
  if (k_file_unformatted) then

   open(unit=10, file=filename_k, form='unformatted', status="unknown", iostat=os)
  ! Write node_number, k1, k2, k3, k4, k5
   write(10) ncnodes
   do i = 1, ncnodes
    write(10) i, kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

 !----------------------------------------------------------------------------------
  else

   open(unit=10, file=filename_k, status="unknown", iostat=os)
  ! Write node_number, k1, k2, k3, k4, k5
   write(10,*) ncnodes
   do i = 1, ncnodes
    write(10,'(6i13)') i, kc1(i),kc2(i),kc3(i),kc4(i),kc5(i)
   end do

  endif
 !----------------------------------------------------------------------------------

  close(10)

 end subroutine write_k_file_c

!*******************************************************************************
! This subroutine writes an rmp file (removed points)
!******************************************************************************
 subroutine write_rmp_file_c

 !----------------------------------------------------------------------------------
 if (rmp_file_unformatted) then

  open(unit=10, file=filename_rmp, form='unformatted', status="unknown", iostat=os)

  write(10) nctet, ncprs, nchex

 ! tet
 !  o : Coarse grid nodes
 !  x : Removed fine-grid nodes
 !
 !                             4            
 !                             o                
 !                           . . .
 !                          .  .  .
 !                         .   .   .
 !                        .    .    .
 !                       .     .     .
 !                      .      .      .
 !                     .       .       .           
 !                    .        .        .        
 !                   .         x 10      .     
 !                8 .          .          .9
 !                 x           .           x
 !                .            .            .   
 !               .             .             .   
 !              .              .              . 
 !             .               .               .
 !            .                .                .  
 !           .                 o 3               . 
 !          .               .     .               .
 !         .        7   .             .  6         .
 !        .         x                    x          .
 !       .      .                           .        .
 !      .    .                                 .      .
 !     .                                           .   .
 !   1 o-----------------------x------------------------o 2  
 !                            5
 !

    if (nctet > 0) then
     do i = 1, nctet
      do k = 5, 10
       write(10) xf(ctet(i,k)), yf(ctet(i,k)), zf(ctet(i,k))
      end do
     end do
    endif

 ! prs
 !  o : Coarse grid nodes
 !  x : Removed fine-grid nodes
 !
 !                        6
 !                        o                  
 !                     .  .  .               
 !             18   .     .     .  17
 !               x        .        x         
 !            .           .           .      
 !         .              .              .   
 !      .                 . 16              .
 !   4 o------------------x------------------o 5
 !     |                  .                  |
 !     |                  x 9                |
 !     |               .  .  .               |
 !     |       15   .     .     .  14        |
 !     |         x        .        x         |
 !     |      .           .           .      |
 !     |   .              .              .   |
 !     |.                 .13               .|
 !   7 x------------------x------------------x 8
 !     |                  .                  |
 !     |                  o 3                |
 !     |               .     .               |
 !     |       12   .           .  11        |
 !     |         x                 x         |
 !     |      .                       .      |
 !     |   .                             .   |
 !     |.                                   .|
 !   1 o------------------x------------------o 2
 !                       10
 !

    if (ncprs > 0) then
     do i = 1, ncprs
      do k = 7, 18
       write(10) xf(cprs(i,k)), yf(cprs(i,k)), zf(cprs(i,k))
      end do
     end do
    endif

 ! Hex

 !  o : Coarse grid nodes
 !  x : Removed fine-grid nodes
 !
 !                        8                                    7
 !                        o ----------------------------------o
 !                     .  .                                 . |
 !                  .     .                              .    |
 !               .        .                            .      |
 !            .           .                         .         |
 !         .              .                      .            |
 !      .                 .                   .               |
 !   5 o-------------------------------------o 6              |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                  .                  |                |
 !     |                4 o -----------------|----------------o 3
 !     |               .                     |              .
 !     |            .                        |           .
 !     |         .                           |         .
 !     |      .                              |      .
 !     |   .                                 |   .
 !     |.                                    |.
 !   1 o-------------------------------------o 2
 !                         
 !
 ! Side faces: 
 !
 !     4        21       5       6        22       7
 !     o--------x--------o       o--------x--------o
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |17      |       |        |18      |
 !    9x--------x--------x10   10x--------x--------x11
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     o--------x--------o       o--------x--------o
 !     1       13        2       2       14        3
 !
 !
 !     7        23       8       8        24       5
 !     o--------x--------o       o--------x--------o
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |19      |       |        |20      |
 !   11x--------x--------x12   12x--------x--------x9
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     o--------x--------o       o--------x--------o
 !     3       15        4       4       16        1
 !
 ! Top and Bottom faces:
 !
 !     8        23       7       4        15       3
 !     o--------x--------o       o--------x--------o
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |26      |       |        |25      |
 !   24x--------x--------x22   16x--------x--------x14
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     |        |        |       |        |        |
 !     o--------x--------o       o--------x--------o
 !     5       21        6       1       13        2
 !
 !
 ! 27: the f-grid node at the center of the c-grid hexa volume.
 !

    if (nchex > 0) then
     do i = 1, nchex
      do k = 9, 27
       write(10) xf(chex(i,k)), yf(chex(i,k)), zf(chex(i,k))
      end do
     end do
    endif

 !----------------------------------------------------------------------------------
 else

  open(unit=10, file=filename_rmp, status="unknown", iostat=os)

  write(10) nctet, ncprs, nchex

    if (nctet > 0) then
     do i = 1, nctet
      do k = 5, 10
       write(10,'(3es28.15)') xf(ctet(i,k)), yf(ctet(i,k)), zf(ctet(i,k))
      end do
     end do
    endif

 ! prs

    if (ncprs > 0) then
     do i = 1, ncprs
      do k = 7, 18
       write(10,'(3es28.15)') xf(cprs(i,k)), yf(cprs(i,k)), zf(cprs(i,k))
      end do
     end do
    endif

 ! Hex

    if (nchex > 0) then
     do i = 1, nchex
      do k = 9, 27
       write(10,'(3es28.15)') xf(chex(i,k)), yf(chex(i,k)), zf(chex(i,k))
      end do
     end do
    endif


 endif
 !----------------------------------------------------------------------------------

 close(10)

  write(*,*)

 end subroutine write_rmp_file_c

!*******************************************************************************
! This subroutine writes a prolongation information file
!******************************************************************************
 subroutine write_prolong_file_nc

 integer(kd) :: nc_seq, coarse_max

  write(*,*) ' nnodes=',nnodes,' in prolongation file'

 !----------------------------------------------------------------------------------
 if (prolong_file_unformatted) then

  open(unit=11, file=filename_prolong_nc, form='unformatted', status="unknown", iostat=os)
  open(unit=12, file=filename_prolong_nc_seq, form='unformatted', status="unknown",iostat=os)

  write(11) nnodes

  nc_seq = 0
  coarse_max = 0
  do i = 1, nnodes
    if ( n_coeff(i) /= 1 ) cycle
    ! Count the nodes that interpolate 1:1 to the fine grid.
    nc_seq = nc_seq + 1
  end do

  write(12) nnodes,nc_seq

  do i = 1, nnodes
    write(11) i, n_coeff(i)

    do k=1,n_coeff(i)
      write(11) cnode_prolong(k,i),coeff_prolong(k,i)
    enddo

    if ( n_coeff(i) == 1 ) then
      ! write the nodes that interpolate 1:1 to the fine grid.
      write(12)  i,cnode_prolong(1,i)
      coarse_max = max( coarse_max, cnode_prolong(1,i) )
    endif

  end do

 !----------------------------------------------------------------------------------
 else

  open(unit=11, file=filename_prolong_nc, status="unknown", iostat=os)
  open(unit=12, file=filename_prolong_nc_seq, status="unknown", form='formatted',iostat=os)

  write(11,"(i12)") nnodes

  nc_seq = 0
  coarse_max = 0
  do i = 1, nnodes
    if ( n_coeff(i) /= 1 ) cycle
    ! Count the nodes that interpolate 1:1 to the fine grid.
    nc_seq = nc_seq + 1
  end do

  write(12,"(2i12)") nnodes,nc_seq

  do i = 1, nnodes
    write(11,"(2i12)") i, n_coeff(i)

    do k=1,n_coeff(i)
      write(11,"(20x,i12,f20.12)") cnode_prolong(k,i),coeff_prolong(k,i)
    enddo

    if ( n_coeff(i) == 1 ) then
      ! write the nodes that interpolate 1:1 to the fine grid.
      write(12,"(10x,2i12)")  i,cnode_prolong(1,i)
      coarse_max = max( coarse_max, cnode_prolong(1,i) )
    endif

  end do

 endif
 !----------------------------------------------------------------------------------

 write(*,*) ' fine grid nodes=',nnodes,' underlying coarse grid nodes=',nc_seq

 close(11)
 close(12)

 if ( ncnodes /= nc_seq ) then
   write(*,*) ' ncnodes /= nc_seq : not regular refinement'
   write(*,*) '    ncnodes = ', ncnodes
   write(*,*) '     nc_seq = ', nc_seq, " = # of nested fine-grid nodes"
   stop
 endif

 if ( coarse_max /= ncnodes ) then
   write(*,*) ' ncnodes /= coarse_max: not regular refinement'
   stop
 endif

 end subroutine write_prolong_file_nc

!*******************************************************************************
! This subroutine writes a prolongation information file
!******************************************************************************
 subroutine write_prolong_file_cc

 integer(kd) :: i, k !, kk

!  character(80) :: filename_temp, char_temp

  write(*,*) ' Total c-grid cells = ', nctet+ncprs+nchex,' in prolongation file for cc'

 !----------------------------------------------------------------------------------
 if (prolong_file_unformatted) then

  open(unit=11, file=filename_prolong_cc, form='unformatted', status="unknown", iostat=os)

  write(11) nctet+ncprs+nchex

  do i = 1, nctet+ncprs+nchex
     write(11) nccells_prolong(i), (ccell_prolong(k,i), k=1,nccells_prolong(i))

if ( nccells_prolong(i) == 0 ) then
 write(*,*) " Missing information!!! "
 write(*,*) " i = ", i
 write(*,*) " elm_type(i) = ", elm_type_c(i)
 write(*,*) "   nccells_prolong(i) = ", nccells_prolong(i)
 write(*,*) "                nctet = ", nctet
 write(*,*) "                ncprs = ", ncprs
 write(*,*) "                nchex = ", nchex
 stop
endif

  end do

 !----------------------------------------------------------------------------------
 else

  open(unit=11, file=filename_prolong_cc, status="unknown", iostat=os)

  write(11,"(i12)") nctet+ncprs+nchex
  do i = 1, nctet+ncprs+nchex

     write(11,"(10i12)") nccells_prolong(i), (ccell_prolong(k,i), k=1,nccells_prolong(i))

if ( nccells_prolong(i) == 0 ) then
 write(*,*) " Missing information!!! "
 write(*,*) " i = ", i
 write(*,*) " elm_type(i) = ", elm_type_c(i)
 write(*,*) "   nccells_prolong(i) = ", nccells_prolong(i)
 write(*,*) "                nctet = ", nctet
 write(*,*) "                ncprs = ", ncprs
 write(*,*) "                nchex = ", nchex
 stop
endif

  end do

 endif
 !----------------------------------------------------------------------------------
!stop
 end subroutine write_prolong_file_cc


!*******************************************************************************
! This subroutine writes a PLOT3D file (for structured grids only: igrid_type=5).
!*******************************************************************************
 subroutine write_plot3d_file

  integer(kd) :: i, j, k
  integer(kd) :: k1min, k4min, k5min
  integer(kd) :: k1max, k4max, k5max
  logical :: full_gmtry

  integer(kd) :: imax, jmax, kmax

   if (half_geom) then
    full_gmtry = .false.
   else
    full_gmtry = .true.
   endif

  !Original data

   k1min = minval(kc1)
   k4min = minval(kc4)
   k5min = minval(kc5)

   k1max = maxval(kc1)
   k4max = maxval(kc4)
   k5max = maxval(kc5)

  !Original data: start from 0, k1=0 is used for the apex node only.

   allocate( k2n_p3d_temp(k4min:k4max, k5min:k5max, k1min:k1max) )

   do i = 1, ncnodes
    k2n_p3d_temp( kc4(i), kc5(i), kc1(i) ) = i
   end do

  !Modified data: start from 1, k1=0 is distributed over k1=1,k1max.

   k4max = k4max + 1
   k5max = k5max + 1
   k1max = k1max

   if (full_gmtry) then
    k1max = k1max + 1
   endif

   allocate( k2n_p3d(k4max, k5max, k1max+1) )

    k2n = -1

   do i = 1, ncnodes
    if (kc1(i)==0) cycle !<- Exclude the apex node.
    k2n_p3d( kc4(i)+1, kc5(i)+1, kc1(i) ) = k2n_p3d_temp( kc4(i), kc5(i), kc1(i) )
   end do

   do k = 1, k1max
    k2n_p3d(     1, :, k ) = k2n_p3d_temp(       0, 0:k5max-1, 0 ) !Nodes above the apex (front).
   end do

   do k = 1, k1max
    k2n_p3d( k4max, :, k ) = k2n_p3d_temp( k4max-1, 0:k5max-1, 0 ) !Nodes above the apex (back).
   end do

   if (full_gmtry) then
    !Copy the first plane to close.
     k2n_p3d( :, :, k1max ) = k2n_p3d( :, :, 1 )
   endif

   deallocate( k2n_p3d_temp )

  if ( ugrid_file_unformatted ) then
    !Note: access="stream" removed (04-04-2017). It was causing some problems...
    open(unit=9, file=filename_p3d, form='unformatted', status='unknown', iostat=os )
    write(9) 1                   ! Single block
    write(9) k4max, k5max, k1max ! ni, nj, nk
  else
    open(unit=9, file=filename_p3d, status="unknown", iostat=os)
    write(9,'(I20)') 1                    ! Single block
    write(9,'(3I20)') k4max, k5max, k1max ! ni, nj, nk
  endif

  do i = 1, k4max
   do j = 1, k5max
    do k = 1, k1max
    if (k2n_p3d(i,j,k)==0) then
     write(*,*) " k2n_p3d(i,j,k) = 0: ", i,j,k
     write(*,*) " imax(k4max) = ", k4max
     write(*,*) " jmax(k5max) = ", k5max
     write(*,*) " kmax(k1max) = ", k1max
     stop
    endif
    end do
   end do
  end do


   if ( ugrid_file_unformatted ) then
    write(9)                                                            &
         ((( xc( k2n_p3d(i,j,k) ) , i=1,k4max), j=1,k5max), k=1,k1max), &
         ((( yc( k2n_p3d(i,j,k) ) , i=1,k4max), j=1,k5max), k=1,k1max), &
         ((( zc( k2n_p3d(i,j,k) ) , i=1,k4max), j=1,k5max), k=1,k1max)
   else
    write(9,'(3ES26.15)')                                               &
         ((( xc( k2n_p3d(i,j,k) ) , i=1,k4max), j=1,k5max), k=1,k1max), &
         ((( yc( k2n_p3d(i,j,k) ) , i=1,k4max), j=1,k5max), k=1,k1max), &
         ((( zc( k2n_p3d(i,j,k) ) , i=1,k4max), j=1,k5max), k=1,k1max)
   endif

  close(9)


  deallocate( k2n_p3d )

!----------------------------------------------------------------------------------
!----------------------------------------------------------------------------------
! Write .nmf file.
!
! 1 -> kmin,   i, j
! 2 -> kmax,   i, j
!
! 3 -> imin,   j, k
! 4 -> imax,   j, k
!
! 5 -> jmin,   k, i
! 6 -> jmax,   k, i
!----------------------------------------------------------------------------------

! imin = 1
  imax = k4max
! jmin = 1
  jmax = k5max
! kmin = 1
  kmax = k1max

 open(unit=9, file=filename_nmf, status='unknown', iostat=os )

 write(9,'(a)') "# ============= NASA Langley Geometry Laboratory TOG Neutral Map File ==============="
 write(9,'(a)') "# ==================================================================================="
 write(9,'(a)') "# Block#   IDIM   JDIM   KDIM"
 write(9,'(a)') "# ==================================================================================="
 write(9,'(i3)')     1
 write(9,*)
 write(9,'(4i15)')   1,  imax, jmax, kmax
 write(9,*)
 write(9,'(a)') "# ==================================================================================="
 write(9,'(a)') "# Type         B1  F1     S1   E1     S2   E2    B2  F2     S1   E1     S2   E2  Swap"
 write(9,'(a)') "#------------------------------------------------------------------------------------"
 write(9,'(a,2i3,i3,i15,i3,i15,i3)') "   front_pole ", 1, 3, 1, jmax, 1, kmax, 2
 write(9,'(a,2i3,i3,i15,i3,i15,i3)') "    back_pole ", 1, 4, 1, jmax, 1, kmax, 2
 write(9,'(a,2i3,i3,i15,i3,i15)')    "viscous_solid ", 1, 5, 1, kmax, 1, imax
 write(9,'(a,2i3,i3,i15,i3,i15)')    "     farfield ", 1, 6, 1, kmax, 1, imax

 !(1)Full geometry: Just to tell two boundaries match and form an interior plane.
 if (full_gmtry) then
  write(9,'(a,2i3,i3,i15,i3,i15, 2i3, i3,i15,i3,i15, a)') "   one_to_one "      , &
                                                          1, 1, 1, imax, 1, jmax, &
                                                          1, 2, 1, imax, 1, jmax, "  FALSE"
 !(2)Half geometry -> Two symmetry planes (one for positive z; the other for negative z).
 else
  write(9,'(a,2i3,i3,i15,i3,i15)')    "   symmetry_y ", 1, 1, 1, imax, 1, jmax 
  write(9,'(a,2i3,i3,i15,i3,i15)')    "   symmetry_y ", 1, 2, 1, imax, 1, jmax 
 endif

 close(9)
!----------------------------------------------------------------------------------
!----------------------------------------------------------------------------------


 end subroutine write_plot3d_file
!********************************************************************************

!*******************************************************************************
! This subroutine writes the volume and heff information for all grids.
!******************************************************************************
 subroutine write_heff_vol_info

 implicit none

 integer :: itet = 1, ihex = 2, iprs = 3, ielm = 0

  open(unit=10, file=filename_heff_vol, status="unknown", iostat=os)

  write(10,*)
  write(10,*) " Volume and heff information for all grids. "
  write(10,*)

  do k = 1, ngrids

   write(10,*) "------------------------------------------------------------------"
   write(10,*) " Grid level = ", k, " ( level = 1 is the finest grid. )"
   write(10,*) "------------------------------------------------------------------"
   write(10,*)

   write(10,*) " 1. Element-volume quantities: "
   write(10,*)
   write(10,'(a,es30.15)') "   Min(element vol) = ", min_evol(k,ielm)
   write(10,'(a,es30.15)') "   Max(element vol) = ", max_evol(k,ielm)
   write(10,'(a,es30.15)') "   Ave(element vol) = ", ave_evol(k,ielm)
   write(10,*)

   if (ntet > 0) then
    write(10,'(a,es30.15)') "       Min(tet vol) = ", min_evol(k,itet)
    write(10,'(a,es30.15)') "       Max(tet vol) = ", max_evol(k,itet)
    write(10,'(a,es30.15)') "       Ave(tet vol) = ", ave_evol(k,itet)
    write(10,*)
   else
    write(10,*) "              No tetrahedral elements in the grid"
    write(10,*)
   endif

   if (nhex > 0) then
    write(10,'(a,es30.15)') "       Min(hex vol) = ", min_evol(k,ihex)
    write(10,'(a,es30.15)') "       Max(hex vol) = ", max_evol(k,ihex)
    write(10,'(a,es30.15)') "       Ave(hex vol) = ", ave_evol(k,ihex)
    write(10,*)
   else
    write(10,*) "              No hexahedral elements in the grid"
    write(10,*)
   endif

   if (nprs0 > 0) then
    write(10,'(a,es30.15)') "       Min(prs vol) = ", min_evol(k,iprs)
    write(10,'(a,es30.15)') "       Max(prs vol) = ", max_evol(k,iprs)
    write(10,'(a,es30.15)') "       Ave(prs vol) = ", ave_evol(k,iprs)
    write(10,*)
   else
    write(10,*) "              No prismatic elements in the grid"
    write(10,*)
   endif

   write(10,'(a)')         "   - heff computed as (element volume)**(1/3)"
   write(10,'(a,es30.15)') "     Max(heff evol) = ", heff_evol(k,1)
   write(10,'(a,es30.15)') "     Max(heff evol) = ", heff_evol(k,2)
   write(10,'(a,es30.15)') "     Ave(heff evol) = ", heff_evol(k,3)
   write(10,*)
   write(10,*)
   write(10,*) " 2. Dual-volume quantities: "
   write(10,*)
   write(10,'(a,es30.15)') "     Min(dual vol) = ", min_dvol(k)
   write(10,'(a,es30.15)') "     Max(dual vol) = ", max_dvol(k)
   write(10,'(a,es30.15)') "     Ave(dual vol) = ", ave_dvol(k)
   write(10,*)
   write(10,'(a)')         "  - heff computed as (dual volume)**(1/3)"
   write(10,'(a,es30.15)') "    Max(heff dvol) = ", heff_dvol(k,1)
   write(10,'(a,es30.15)') "    Max(heff dvol) = ", heff_dvol(k,2)
   write(10,'(a,es30.15)') "    Ave(heff dvol) = ", heff_dvol(k,3)
   write(10,*)

   write(10,*)
   write(10,*)

  end do

  close(10)

  write(*,*)

 end subroutine write_heff_vol_info

!********************************************************************************
! Find out big_endian_io.
!********************************************************************************
 function big_endian_io( opt_unit )

 integer, intent(in) :: opt_unit
 logical             :: big_endian_io
! one-byte integer(kind)
 integer, parameter :: i1 = selected_int_kind(2)
! two-byte integer(kind)
 integer, parameter :: i2 = selected_int_kind(4)
 integer(i1) :: byte_one, byte_two
! 00000000 00000001 big-endian binary
 integer(i2) :: two_byte_int = 1_i2

    open(opt_unit,status='scratch',form='unformatted')
      write( opt_unit) two_byte_int
      rewind(opt_unit)
      read(  opt_unit) byte_one, byte_two
    close(opt_unit)
    big_endian_io = ( byte_one == 0 .and. byte_two == 1 )

 end function big_endian_io
!********************************************************************************

!********************************************************************************
!********************************************************************************
!********************************************************************************
!********************************************************************************
!********************************************************************************
!********************************************************************************

!********************************************************************************
!*
!********************************************************************************
  subroutine finer_grid_volumes(    vol_max,     vol_min,     vol_ave, &
                                   dvol_max,    dvol_min,    dvol_ave, &
                                vol_tet_max, vol_tet_min, vol_tet_ave, &
                                vol_hex_max, vol_hex_min, vol_hex_ave, &
                                vol_prs_max, vol_prs_min, vol_prs_ave, &
                          heff_dvol_max, heff_dvol_min, heff_dvol_ave, &
                          heff_evol_max, heff_evol_min, heff_evol_ave  )

  implicit none

  real(dp), intent(out) ::     vol_max,     vol_min,     vol_ave
  real(dp), intent(out) ::    dvol_max,    dvol_min,    dvol_ave
  real(dp), intent(out) :: vol_tet_max, vol_tet_min, vol_tet_ave
  real(dp), intent(out) :: vol_hex_max, vol_hex_min, vol_hex_ave
  real(dp), intent(out) :: vol_prs_max, vol_prs_min, vol_prs_ave

  real(dp), intent(out) :: heff_dvol_max, heff_dvol_min, heff_dvol_ave
  real(dp), intent(out) :: heff_evol_max, heff_evol_min, heff_evol_ave

  real(dp) :: x1,x2,x3,x4, y1,y2,y3,y4, z1,z2,z3,z4
  real(dp) :: x5,x6,x7,x8, y5,y6,y7,y8, z5,z6,z7,z8
  real(dp) :: xbg, xg, xml ,xmr, xvm, xvml, xvmr
  real(dp) :: ybg, yg, yml ,ymr, yvm, yvml, yvmr
  real(dp) :: zbg, zg, zml ,zmr, zvm, zvml, zvmr
  real(dp) :: volume, dual

  integer(kd)               :: i, k, n_negative_vol, nelms
  integer(kd), dimension(8) :: v

  nelms = 0

  dual_vol = 0.0_dp

          vol_max = -1.0_dp
          vol_min =  1.0e+15_dp
          vol_ave =  0.0_dp

          heff_evol_max = -1.0_dp
          heff_evol_min =  1.0e+15_dp
          heff_evol_ave =  0.0_dp

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! (1)Check Tetrahedral elements
!
!            4
!            o
!           /| .
!          / |   .
!         /  |     .
!        /   |       .
!     1 o----|-------o 3
!        \   |     .
!         \  |    .
!          \ |  .
!           \|.
!            o
!            2
!
!--------------------------------------------------------------------
!--------------------------------------------------------------------
 tet_vol : if (ntet > 0) then

 write(*,*)
 write(*,*) " Computing volumes/dual for tetrahedra....."
 write(*,*)

   n_negative_vol =  0
      vol_tet_max = -1.0_dp
      vol_tet_min =  1.0e+15_dp
      vol_tet_ave =  0.0_dp

   nelms = nelms + ntet

   do i = 1, ntet

    v(1:4) =  tet(i,1:4)

    x1 = xf( v(1) )
    y1 = yf( v(1) )
    z1 = zf( v(1) )

    x2 = xf( v(2) )
    y2 = yf( v(2) )
    z2 = zf( v(2) )

    x3 = xf( v(3) )
    y3 = yf( v(3) )
    z3 = zf( v(3) )

    x4 = xf( v(4) )
    y4 = yf( v(4) )
    z4 = zf( v(4) )

     volume = tet_volume(x1,x2,x3,x4, y1,y2,y3,y4, z1,z2,z3,z4)

    vol_tet_max = max(vol_tet_max,volume)
    vol_tet_min = min(vol_tet_min,volume)
    vol_tet_ave = vol_tet_ave + volume

    vol_max = max(vol_max,volume)
    vol_min = min(vol_min,volume)
    vol_ave = vol_ave + volume

    heff_evol_max = max(heff_evol_max,volume**third)
    heff_evol_min = min(heff_evol_min,volume**third)
    heff_evol_ave = heff_evol_ave +   volume**third

    if (volume < 0.0_dp) n_negative_vol = n_negative_vol + 1

    do k = 1, 4
     dual_vol(v(k)) = dual_vol(v(k)) + volume/4.0_dp 
    end do

   end do

   vol_tet_ave = vol_tet_ave / real(ntet,dp)

   if (n_negative_vol == 0) then
     write(*,*)
     write(*,'(a)') " Finer-grid: Negative tetra volume not detected. "
     write(*,*)
   else
     write(*,'(a)') " Finer-grid: # of tets having negative volume = ", n_negative_vol
   endif

   write(*,*)
   write(*,'(a,es26.16)') " Finer-grid:  Minimum tetrahedral volume = ", vol_tet_min
   write(*,'(a,es26.16)') " Finer-grid:  Maximum tetrahedral volume = ", vol_tet_max
   write(*,'(a,es26.16)') " Finer-grid:  Average tetrahedral volume = ", vol_tet_ave
   write(*,*)

 endif tet_vol
!--------------------------------------------------------------------
!--------------------------------------------------------------------
! End fo (1)Check Tetrahedral elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! (2)Check Hexahedral elements
!
!       5             8
!       o------------o
!       |\           .\
!       | \          . \ 
!       |  \         .  \
!       |   \ 6      .   \ 7
!       |    o -----------o
!       |    |       .    |
!       |    |       .    |
!       |    |       .    |
!     1 o----|-------o 4  |
!        \   |        \   |
!         \  |         \  |
!          \ |          \ |
!           \|           \|
!            o------------o
!            2            3
!
!--------------------------------------------------------------------
!--------------------------------------------------------------------
 hex_vol_check : if (nhex > 0) then

 write(*,*)
 write(*,*) " Computing volumes/dual for hexahedra....."
 write(*,*)

   n_negative_vol =  0
      vol_hex_max = -1.0_dp
      vol_hex_min =  1.0e+15_dp
      vol_hex_ave =  0.0_dp

   nelms = nelms + nhex

  do i = 1, nhex

    v(1:8) =  hex(i,1:8)

    x1 = xf( v(1) )
    y1 = yf( v(1) )
    z1 = zf( v(1) )

    x2 = xf( v(2) )
    y2 = yf( v(2) )
    z2 = zf( v(2) )

    x3 = xf( v(3) )
    y3 = yf( v(3) )
    z3 = zf( v(3) )

    x4 = xf( v(4) )
    y4 = yf( v(4) )
    z4 = zf( v(4) )

    x5 = xf( v(5) )
    y5 = yf( v(5) )
    z5 = zf( v(5) )

    x6 = xf( v(6) )
    y6 = yf( v(6) )
    z6 = zf( v(6) )

    x7 = xf( v(7) )
    y7 = yf( v(7) )
    z7 = zf( v(7) )

    x8 = xf( v(8) )
    y8 = yf( v(8) )
    z8 = zf( v(8) )

  !Cut into 6 tetrahedra and compute the volume of hex:

     volume = hex_volume( x1,x2,x3,x4,x5,x6,x7,x8, &
                          y1,y2,y3,y4,y5,y6,y7,y8, &
                          z1,z2,z3,z4,z5,z6,z7,z8  )

    vol_hex_max = max(vol_hex_max,volume)
    vol_hex_min = min(vol_hex_min,volume)
    vol_hex_ave = vol_hex_ave + volume

    vol_max = max(vol_max,volume)
    vol_min = min(vol_min,volume)
    vol_ave = vol_ave + volume

    heff_evol_max = max(heff_evol_max,volume**third)
    heff_evol_min = min(heff_evol_min,volume**third)
    heff_evol_ave = heff_evol_ave +   volume**third

    if (volume < 0.0_dp) n_negative_vol = n_negative_vol + 1

  !Dual volumes

     xg = ( x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 )/8.0_dp
     yg = ( y1 + y2 + y3 + y4 + y5 + y6 + y7 + y8 )/8.0_dp
     zg = ( z1 + z2 + z3 + z4 + z5 + z6 + z7 + z8 )/8.0_dp

  !--------------------------------------------------------------
  ! Bottom

     xbg = 0.25_dp*( x1 + x2 + x3 + x4 )
     ybg = 0.25_dp*( y1 + y2 + y3 + y4 )
     zbg = 0.25_dp*( z1 + z2 + z3 + z4 )

   !Vertex 1

    k = 1

     xml = half*( x1 + x4 )
     yml = half*( y1 + y4 )
     zml = half*( z1 + z4 )

     xmr = half*( x1 + x2 )
     ymr = half*( y1 + y2 )
     zmr = half*( z1 + z2 )

     xvm = half*( x1 + x5 )
     yvm = half*( y1 + y5 )
     zvm = half*( z1 + z5 )

     xvml = 0.25_dp*( x1 + x4 + x5 + x8 )
     yvml = 0.25_dp*( y1 + y4 + y5 + y8 )
     zvml = 0.25_dp*( z1 + z4 + z5 + z8 )

     xvmr = 0.25_dp*( x1 + x2 + x5 + x6 )
     yvmr = 0.25_dp*( y1 + y2 + y5 + y6 )
     zvmr = 0.25_dp*( z1 + z2 + z5 + z6 )

     dual = hex_volume( x1,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y1,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z1,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   !Vertex 2

    k = 2

     xml = half*( x2 + x1 )
     yml = half*( y2 + y1 )
     zml = half*( z2 + z1 )

     xmr = half*( x2 + x3 )
     ymr = half*( y2 + y3 )
     zmr = half*( z2 + z3 )

     xvm = half*( x2 + x6 )
     yvm = half*( y2 + y6 )
     zvm = half*( z2 + z6 )

     xvml = 0.25_dp*( x1 + x2 + x6 + x5 )
     yvml = 0.25_dp*( y1 + y2 + y6 + y5 )
     zvml = 0.25_dp*( z1 + z2 + z6 + z5 )

     xvmr = 0.25_dp*( x3 + x2 + x6 + x7 )
     yvmr = 0.25_dp*( y3 + y2 + y6 + y7 )
     zvmr = 0.25_dp*( z3 + z2 + z6 + z7 )

     dual = hex_volume( x2,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y2,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z2,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   !Vertex 3

    k = 3

     xml = half*( x3 + x2 )
     yml = half*( y3 + y2 )
     zml = half*( z3 + z2 )

     xmr = half*( x3 + x4 )
     ymr = half*( y3 + y4 )
     zmr = half*( z3 + z4 )

     xvm = half*( x3 + x7 )
     yvm = half*( y3 + y7 )
     zvm = half*( z3 + z7 )

     xvml = 0.25_dp*( x2 + x3 + x6 + x7 )
     yvml = 0.25_dp*( y2 + y3 + y6 + y7 )
     zvml = 0.25_dp*( z2 + z3 + z6 + z7 )

     xvmr = 0.25_dp*( x3 + x4 + x8 + x7 )
     yvmr = 0.25_dp*( y3 + y4 + y8 + y7 )
     zvmr = 0.25_dp*( z3 + z4 + z8 + z7 )

     dual = hex_volume( x3,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y3,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z3,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   !Vertex 4

    k = 4

     xml = half*( x4 + x3 )
     yml = half*( y4 + y3 )
     zml = half*( z4 + z3 )

     xmr = half*( x4 + x1 )
     ymr = half*( y4 + y1 )
     zmr = half*( z4 + z1 )

     xvm = half*( x4 + x8 )
     yvm = half*( y4 + y8 )
     zvm = half*( z4 + z8 )

     xvml = 0.25_dp*( x3 + x4 + x7 + x8 )
     yvml = 0.25_dp*( y3 + y4 + y7 + y8 )
     zvml = 0.25_dp*( z3 + z4 + z7 + z8 )

     xvmr = 0.25_dp*( x4 + x1 + x5 + x8 )
     yvmr = 0.25_dp*( y4 + y1 + y5 + y8 )
     zvmr = 0.25_dp*( z4 + z1 + z5 + z8 )

     dual = hex_volume( x4,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y4,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z4,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

  !--------------------------------------------------------------
  ! Top

     xbg = 0.25_dp*( x5 + x6 + x7 + x8 )
     ybg = 0.25_dp*( y5 + y6 + y7 + y8 )
     zbg = 0.25_dp*( z5 + z6 + z7 + z8 )

   !Vertex 5

    k = 5

     xml = half*( x5 + x6 )
     yml = half*( y5 + y6 )
     zml = half*( z5 + z6 )

     xmr = half*( x5 + x8 )
     ymr = half*( y5 + y8 )
     zmr = half*( z5 + z8 )

     xvm = half*( x5 + x1 )
     yvm = half*( y5 + y1 )
     zvm = half*( z5 + z1 )

     xvml = 0.25_dp*( x5 + x6 + x2 + x1 )
     yvml = 0.25_dp*( y5 + y6 + y2 + y1 )
     zvml = 0.25_dp*( z5 + z6 + z2 + z1 )

     xvmr = 0.25_dp*( x5 + x8 + x4 + x1 )
     yvmr = 0.25_dp*( y5 + y8 + y4 + y1 )
     zvmr = 0.25_dp*( z5 + z8 + z4 + z1 )

     dual = hex_volume( x5,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y5,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z5,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   !Vertex 6

    k = 6

     xml = half*( x6 + x7 )
     yml = half*( y6 + y7 )
     zml = half*( z6 + z7 )

     xmr = half*( x6 + x5 )
     ymr = half*( y6 + y5 )
     zmr = half*( z6 + z5 )

     xvm = half*( x6 + x2 )
     yvm = half*( y6 + y2 )
     zvm = half*( z6 + z2 )

     xvml = 0.25_dp*( x6 + x7 + x3 + x2 )
     yvml = 0.25_dp*( y6 + y7 + y3 + y2 )
     zvml = 0.25_dp*( z6 + z7 + z3 + z2 )

     xvmr = 0.25_dp*( x6 + x5 + x1 + x2 )
     yvmr = 0.25_dp*( y6 + y5 + y1 + y2 )
     zvmr = 0.25_dp*( z6 + z5 + z1 + z2 )

     dual = hex_volume( x6,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y6,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z6,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   !Vertex 7

    k = 7

     xml = half*( x7 + x8 )
     yml = half*( y7 + y8 )
     zml = half*( z7 + z8 )

     xmr = half*( x7 + x6 )
     ymr = half*( y7 + y6 )
     zmr = half*( z7 + z6 )

     xvm = half*( x7 + x3 )
     yvm = half*( y7 + y3 )
     zvm = half*( z7 + z3 )

     xvml = 0.25_dp*( x7 + x8 + x4 + x3 )
     yvml = 0.25_dp*( y7 + y8 + y4 + y3 )
     zvml = 0.25_dp*( z7 + z8 + z4 + z3 )

     xvmr = 0.25_dp*( x7 + x6 + x2 + x3 )
     yvmr = 0.25_dp*( y7 + y6 + y2 + y3 )
     zvmr = 0.25_dp*( z7 + z6 + z2 + z3 )

     dual = hex_volume( x7,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y7,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z7,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   !Vertex 8

    k = 8

     xml = half*( x8 + x5 )
     yml = half*( y8 + y5 )
     zml = half*( z8 + z5 )

     xmr = half*( x8 + x7 )
     ymr = half*( y8 + y7 )
     zmr = half*( z8 + z7 )

     xvm = half*( x8 + x4 )
     yvm = half*( y8 + y4 )
     zvm = half*( z8 + z4 )

     xvml = 0.25_dp*( x8 + x5 + x1 + x4 )
     yvml = 0.25_dp*( y8 + y5 + y1 + y4 )
     zvml = 0.25_dp*( z8 + z5 + z1 + z4 )

     xvmr = 0.25_dp*( x8 + x7 + x3 + x4 )
     yvmr = 0.25_dp*( y8 + y7 + y3 + y4 )
     zvmr = 0.25_dp*( z8 + z7 + z3 + z4 )

     dual = hex_volume( x8,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y8,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z8,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

  end do

   vol_hex_ave = vol_hex_ave / real(nhex,dp)

   if (n_negative_vol == 0) then
     write(*,*)
     write(*,'(a)') " Finer-grid: Negative hex volume not detected. "
     write(*,*)
   else
     write(*,'(a)') " Finer-grid: # of hex having negative volume = ", n_negative_vol
   endif

   write(*,*)
   write(*,'(a,es26.16)') " Finer-grid:  Minimum hexahedral volume = ", vol_hex_min
   write(*,'(a,es26.16)') " Finer-grid:  Maximum hexahedral volume = ", vol_hex_max
   write(*,'(a,es26.16)') " Finer-grid:  Average hexahedral volume = ", vol_hex_ave
   write(*,*)

 endif hex_vol_check

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! End fo (2)Check Hexahedral elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------


!--------------------------------------------------------------------
!--------------------------------------------------------------------
! (3)Check Prismatic elements
!
!                  6
!                  o
!                 /.\
!                / . \
!               /  .  \ 
!              /   .   \
!             /    .    \ 
!          4 o ----------o 5
!            |     .     |
!            |     .     |
!            |     o3    |
!            |    / \    |
!            |   /   \   |
!            |  /     \  |
!            | /       \ |
!            |/         \|
!            o-----------o
!            1           2
!
!--------------------------------------------------------------------
!--------------------------------------------------------------------
 prs_vol_check : if (nprs > 0) then

 write(*,*)
 write(*,*) " Computing volumes/dual for prisms....."
 write(*,*)

   n_negative_vol =  0
      vol_prs_max = -1.0_dp
      vol_prs_min =  1.0e+15_dp
      vol_prs_ave =  0.0_dp

   nelms = nelms + nprs

   do i = 1, nprs

    v(1:6) =  prs(i,1:6)

    x1 = xf( v(1) )
    y1 = yf( v(1) )
    z1 = zf( v(1) )

    x2 = xf( v(2) )
    y2 = yf( v(2) )
    z2 = zf( v(2) )

    x3 = xf( v(3) )
    y3 = yf( v(3) )
    z3 = zf( v(3) )

    x4 = xf( v(4) )
    y4 = yf( v(4) )
    z4 = zf( v(4) )

    x5 = xf( v(5) )
    y5 = yf( v(5) )
    z5 = zf( v(5) )

    x6 = xf( v(6) )
    y6 = yf( v(6) )
    z6 = zf( v(6) )

  !Cut prism into 3 tetrahedra and compute the volume of prism:

     volume = prs_volume( x1, x2, x3, x4, x5, x6, &
                          y1, y2, y3, y4, y5, y6, &
                          z1, z2, z3, z4, z5, z6  )

    vol_prs_max = max(vol_prs_max,volume)
    vol_prs_min = min(vol_prs_min,volume)
    vol_prs_ave = vol_prs_ave + volume

    vol_max = max(vol_max,volume)
    vol_min = min(vol_min,volume)
    vol_ave = vol_ave + volume

    heff_evol_max = max(heff_evol_max,volume**third)
    heff_evol_min = min(heff_evol_min,volume**third)
    heff_evol_ave = heff_evol_ave +   volume**third

    if (volume < 0.0_dp) n_negative_vol = n_negative_vol + 1

  !Dual volumes

     xg = ( x1 + x2 + x3 + x4 + x5 + x6 )/6.0_dp
     yg = ( y1 + y2 + y3 + y4 + y5 + y6 )/6.0_dp
     zg = ( z1 + z2 + z3 + z4 + z5 + z6 )/6.0_dp

  !--------------------------------------------------------------
  ! Bottom

     xbg = third*( x1 + x2 + x3 )
     ybg = third*( y1 + y2 + y3 )
     zbg = third*( z1 + z2 + z3 )

   !Vertex 1

    k = 1

     xml = half*( x1 + x3 )
     yml = half*( y1 + y3 )
     zml = half*( z1 + z3 )

     xmr = half*( x1 + x2 )
     ymr = half*( y1 + y2 )
     zmr = half*( z1 + z2 )

     xvm = half*( x1 + x4 )
     yvm = half*( y1 + y4 )
     zvm = half*( z1 + z4 )

     xvml = 0.25_dp*( x1 + x3 + x6 + x4 )
     yvml = 0.25_dp*( y1 + y3 + y6 + y4 )
     zvml = 0.25_dp*( z1 + z3 + z6 + z4 )

     xvmr = 0.25_dp*( x1 + x2 + x5 + x4 )
     yvmr = 0.25_dp*( y1 + y2 + y5 + y4 )
     zvmr = 0.25_dp*( z1 + z2 + z5 + z4 )

     dual = hex_volume( x1,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y1,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z1,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   !Vertex 2

    k = 2

     xml = half*( x2 + x1 )
     yml = half*( y2 + y1 )
     zml = half*( z2 + z1 )

     xmr = half*( x2 + x3 )
     ymr = half*( y2 + y3 )
     zmr = half*( z2 + z3 )

     xvm = half*( x2 + x5 )
     yvm = half*( y2 + y5 )
     zvm = half*( z2 + z5 )

     xvml = 0.25_dp*( x2 + x1 + x4 + x5 )
     yvml = 0.25_dp*( y2 + y1 + y4 + y5 )
     zvml = 0.25_dp*( z2 + z1 + z4 + z5 )

     xvmr = 0.25_dp*( x2 + x3 + x6 + x5 )
     yvmr = 0.25_dp*( y2 + y3 + y6 + y5 )
     zvmr = 0.25_dp*( z2 + z3 + z6 + z5 )

     dual = hex_volume( x2,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y2,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z2,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   !Vertex 3

    k = 3

     xml = half*( x3 + x2 )
     yml = half*( y3 + y2 )
     zml = half*( z3 + z2 )

     xmr = half*( x3 + x1 )
     ymr = half*( y3 + y1 )
     zmr = half*( z3 + z1 )

     xvm = half*( x3 + x6 )
     yvm = half*( y3 + y6 )
     zvm = half*( z3 + z6 )

     xvml = 0.25_dp*( x3 + x2 + x5 + x6 )
     yvml = 0.25_dp*( y3 + y2 + y5 + y6 )
     zvml = 0.25_dp*( z3 + z2 + z5 + z6 )

     xvmr = 0.25_dp*( x3 + x1 + x4 + x6 )
     yvmr = 0.25_dp*( y3 + y1 + y4 + y6 )
     zvmr = 0.25_dp*( z3 + z1 + z4 + z6 )

     dual = hex_volume( x3,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y3,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z3,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

  !--------------------------------------------------------------
  ! Top

     xbg = third*( x4 + x5 + x6 )
     ybg = third*( y4 + y5 + y6 )
     zbg = third*( z4 + z5 + z6 )

   !Vertex 4

    k = 4

     xml = half*( x4 + x5 )
     yml = half*( y4 + y5 )
     zml = half*( z4 + z5 )

     xmr = half*( x4 + x6 )
     ymr = half*( y4 + y6 )
     zmr = half*( z4 + z6 )

     xvm = half*( x4 + x1 )
     yvm = half*( y4 + y1 )
     zvm = half*( z4 + z1 )

     xvml = 0.25_dp*( x4 + x5 + x2 + x1 )
     yvml = 0.25_dp*( y4 + y5 + y2 + y1 )
     zvml = 0.25_dp*( z4 + z5 + z2 + z1 )

     xvmr = 0.25_dp*( x4 + x6 + x3 + x1 )
     yvmr = 0.25_dp*( y4 + y6 + y3 + y1 )
     zvmr = 0.25_dp*( z4 + z6 + z3 + z1 )

     dual = hex_volume( x4,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y4,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z4,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   !Vertex 5

    k = 5

     xml = half*( x5 + x6 )
     yml = half*( y5 + y6 )
     zml = half*( z5 + z6 )

     xmr = half*( x5 + x4 )
     ymr = half*( y5 + y4 )
     zmr = half*( z5 + z4 )

     xvm = half*( x5 + x2 )
     yvm = half*( y5 + y2 )
     zvm = half*( z5 + z2 )

     xvml = 0.25_dp*( x5 + x6 + x3 + x2 )
     yvml = 0.25_dp*( y5 + y6 + y3 + y2 )
     zvml = 0.25_dp*( z5 + z6 + z3 + z2 )

     xvmr = 0.25_dp*( x5 + x4 + x1 + x2 )
     yvmr = 0.25_dp*( y5 + y4 + y1 + y2 )
     zvmr = 0.25_dp*( z5 + z4 + z1 + z2 )

     dual = hex_volume( x5,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y5,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z5,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   !Vertex 6

    k = 6

     xml = half*( x6 + x4 )
     yml = half*( y6 + y4 )
     zml = half*( z6 + z4 )

     xmr = half*( x6 + x5 )
     ymr = half*( y6 + y5 )
     zmr = half*( z6 + z5 )

     xvm = half*( x6 + x3 )
     yvm = half*( y6 + y3 )
     zvm = half*( z6 + z3 )

     xvml = 0.25_dp*( x6 + x4 + x1 + x3 )
     yvml = 0.25_dp*( y6 + y4 + y1 + y3 )
     zvml = 0.25_dp*( z6 + z4 + z1 + z3 )

     xvmr = 0.25_dp*( x6 + x5 + x2 + x3 )
     yvmr = 0.25_dp*( y6 + y5 + y2 + y3 )
     zvmr = 0.25_dp*( z6 + z5 + z2 + z3 )

     dual = hex_volume( x6,xmr,xbg,xml, xvm,xvmr,xg,xvml, &
                        y6,ymr,ybg,yml, yvm,yvmr,yg,yvml, &
                        z6,zmr,zbg,zml, zvm,zvmr,zg,zvml  )

     dual_vol(v(k)) = dual_vol(v(k)) + dual

   end do

   vol_prs_ave = vol_prs_ave / real(nprs,dp)

   if (n_negative_vol == 0) then
     write(*,*)
     write(*,*) " Finer-grid: Negative prism volume not detected. "
     write(*,*)
   else
     write(*,*) " Finer-grid: # of prism having negative volume = ", n_negative_vol
   endif

   write(*,*)
   write(*,'(a,es26.16)') " Finer-grid:  Minimum prismatic volume = ", vol_prs_min
   write(*,'(a,es26.16)') " Finer-grid:  Maximum prismatic volume = ", vol_prs_max
   write(*,'(a,es26.16)') " Finer-grid:  Average prismatic volume = ", vol_prs_ave
   write(*,*)

 endif prs_vol_check

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! End fo (3)Check Prismatic elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------

         vol_ave =       vol_ave / real(nelms,dp)
   heff_evol_ave = heff_evol_ave / real(nelms,dp)

   write(*,*)
   write(*,*)"---------------------------------------------------------------"
   write(*,*)" All elements"
   write(*,*)"---------------------------------------------------------------"
   write(*,'(a,es26.16)') " Finer-grid:  Minimum element volume = ", vol_min
   write(*,'(a,es26.16)') " Finer-grid:  Maximum element volume = ", vol_max
   write(*,'(a,es26.16)') " Finer-grid:  Average element volume = ", vol_ave
   write(*,*)
   write(*,'(a,es26.16)') " Finer-grid:  Minimum heff (=cubic root(vol)) = ", heff_evol_min
   write(*,'(a,es26.16)') " Finer-grid:  Maximum heff (=cubic root(vol)) = ", heff_evol_max
   write(*,'(a,es26.16)') " Finer-grid:  Average heff (=cubic root(vol)) = ", heff_evol_ave
   write(*,*)"---------------------------------------------------------------"
   write(*,*)

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! Dual volume
!--------------------------------------------------------------------
!--------------------------------------------------------------------
 
 write(*,*)
 write(*,*) " Computing dual volumes....."
 write(*,*)

   n_negative_vol =  0
         dvol_max = -1.0_dp
         dvol_min =  1.0e+15_dp
         dvol_ave =  0.0_dp

          heff_dvol_max = -1.0_dp
          heff_dvol_min =  1.0e+15_dp
          heff_dvol_ave =  0.0_dp

  do i = 1, nnodes

      volume = dual_vol(i)

    dvol_max = max(dvol_max,volume)
    dvol_min = min(dvol_min,volume)
    dvol_ave = dvol_ave + volume

    heff_dvol_max = max(heff_dvol_max,volume**third)
    heff_dvol_min = min(heff_dvol_min,volume**third)
    heff_dvol_ave = heff_dvol_ave +   volume**third

  end do

        dvol_ave =      dvol_ave / real(nnodes,dp)
   heff_dvol_ave = heff_dvol_ave / real(nnodes,dp)

   if (n_negative_vol == 0) then
     write(*,*)
     write(*,'(a)') " Finer-grid: Negative dual-volume not detected. "
     write(*,*)
   else
     write(*,'(a)') " Finer-grid: # of dual volumes having negative volume = ", n_negative_vol
   endif

   write(*,*)
   write(*,'(a,es26.16)') " Finer-grid:  Minimum dual volume = ", dvol_min
   write(*,'(a,es26.16)') " Finer-grid:  Maximum dual volume = ", dvol_max
   write(*,'(a,es26.16)') " Finer-grid:  Average dual volume = ", dvol_ave
   write(*,*)
   write(*,'(a,es26.16)') " Finer-grid:  Minimum heff (=cubic root(dvol)) = ", heff_dvol_min
   write(*,'(a,es26.16)') " Finer-grid:  Maximum heff (=cubic root(dvol)) = ", heff_dvol_max
   write(*,'(a,es26.16)') " Finer-grid:  Average heff (=cubic root(dvol)) = ", heff_dvol_ave
   write(*,*)

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! End of Dual volume
!--------------------------------------------------------------------
!--------------------------------------------------------------------

   write(*,*) "------------------------------------------------------------------"
   write(*,*) "------------------------------------------------------------------"
   write(*,*)

  end subroutine finer_grid_volumes


!********************************************************************************
!* Check the volume of all types of elements.
!*
!********************************************************************************
  subroutine volume_check(negative_volume)
  implicit none

  logical, dimension(3), intent(out) :: negative_volume

  real(dp) :: x1,x2,x3,x4, y1,y2,y3,y4, z1,z2,z3,z4
  real(dp) :: x5,x6,x7,x8, y5,y6,y7,y8, z5,z6,z7,z8
  real(dp) :: volume, vol_max, vol_min, vol_ave

  integer(kd)               :: i, n_negative_vol, itet, ihex, iprs
  integer(kd), dimension(8) :: v
  character(80)         :: i_char, filename

  itet = 1
  ihex = 2
  iprs = 3
  negative_volume = .false.

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! (1)Check Tetrahedral elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------
 tet_vol_check : if (nctet > 0) then

   n_negative_vol =  0
          vol_max = -1.0_dp
          vol_min =  1.0e+15_dp
          vol_ave =  0.0_dp

  !-------------------------------------------------------------
  ! Loop over tetrahedra and check the volumne one by one.
  !-------------------------------------------------------------
   do i = 1, nctet

    v(1:4) =  ctet(i,1:4)

    x1 = xc( v(1) )
    y1 = yc( v(1) )
    z1 = zc( v(1) )

    x2 = xc( v(2) )
    y2 = yc( v(2) )
    z2 = zc( v(2) )

    x3 = xc( v(3) )
    y3 = yc( v(3) )
    z3 = zc( v(3) )

    x4 = xc( v(4) )
    y4 = yc( v(4) )
    z4 = zc( v(4) )

     volume = tet_volume(x1,x2,x3,x4, y1,y2,y3,y4, z1,z2,z3,z4)

    vol_max = max(vol_max,volume)
    vol_min = min(vol_min,volume)
    vol_ave = vol_ave + volume

    if (volume < 0.0_dp) then

     write(8933,*) " Negative volume tet at element = ", i

     !Write a Tecplot file for the negative-volume tetrahedra,
     !only for the first 20 tetra (to avoid too many files).
     if (n_negative_vol < 21) then

      write( i_char  , '(i0)' ) i
      filename = "negative_vol_tet_" // trim(cgrid_level_char) // "." // trim(i_char) // "_tec.dat"
      open(unit=3, file=filename, status="unknown", iostat=os)
      write(3,*) 'TITLE = ', "negative_vol_tet_" // trim(i_char)
      write(3,*) 'VARIABLES = "x","y","z"'
      write(3,*) 'ZONE  N=', 4,',E=', 1,' , et=tetrahedron, F=FEPOINT'
      write(3,'(3ES20.10)') x1, y1, z1
      write(3,'(3ES20.10)') x2, y2, z2
      write(3,'(3ES20.10)') x3, y3, z3
      write(3,'(3ES20.10)') x4, y4, z4
      write(3,'(4i10)'    )  1, 2, 3, 4
      close(3)

     endif

     n_negative_vol = n_negative_vol + 1

     ! Display a WARNING MESSAGE
     if (n_negative_vol == 1) then
      write(*,*)
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) " Negative tet volume deteceted. See fort.8933..."
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*)
     endif

    endif

   end do
  !-------------------------------------------------------------
  ! End of loop over tetrahedra
  !-------------------------------------------------------------

   vol_ave = vol_ave / real(ntet,dp)

   if (n_negative_vol == 0) then
     write(*,*)
     write(*,*) " Negative tetra volume not detected. "
     write(*,*)
   endif

   write(*,*)
   write(*,'(a,es26.16)') " Minimum tetrahedral volume = ", vol_min
   write(*,'(a,es26.16)') " Maximum tetrahedral volume = ", vol_max
   write(*,'(a,es26.16)') " Average tetrahedral volume = ", vol_ave
   write(*,*)

   if (n_negative_vol > 0) then
     write(*,*) " Tetrahedra with negative volume created....."
     write(*,*) "  # of tets having negative volume = ", n_negative_vol
     negative_volume(itet) = .true.
   endif

 endif tet_vol_check
!--------------------------------------------------------------------
!--------------------------------------------------------------------
! End fo (1)Check Tetrahedral elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! (2)Check Hexahedral elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------
 hex_vol_check : if (nchex > 0) then

   n_negative_vol = 0
   vol_max = -1.0_dp
   vol_min =  1.0e+15_dp
   vol_ave =  0.0_dp

  !-------------------------------------------------------------
  ! Loop over hex and check the volumne one by one.
  !-------------------------------------------------------------
   do i = 1, nchex

    v(1:8) =  chex(i,1:8)

    x1 = xc( v(1) )
    y1 = yc( v(1) )
    z1 = zc( v(1) )

    x2 = xc( v(2) )
    y2 = yc( v(2) )
    z2 = zc( v(2) )

    x3 = xc( v(3) )
    y3 = yc( v(3) )
    z3 = zc( v(3) )

    x4 = xc( v(4) )
    y4 = yc( v(4) )
    z4 = zc( v(4) )

    x5 = xc( v(5) )
    y5 = yc( v(5) )
    z5 = zc( v(5) )

    x6 = xc( v(6) )
    y6 = yc( v(6) )
    z6 = zc( v(6) )

    x7 = xc( v(7) )
    y7 = yc( v(7) )
    z7 = zc( v(7) )

    x8 = xc( v(8) )
    y8 = yc( v(8) )
    z8 = zc( v(8) )


  !Cut into 6 tetrahedra and compute the volume of hex:

     volume = 0.0_dp
     volume = volume + tet_volume( x1, x4, x5, x6, &
                                   y1, y4, y5, y6, &
                                   z1, z4, z5, z6  )

     volume = volume + tet_volume( x4, x8, x5, x6, &
                                   y4, y8, y5, y6, &
                                   z4, z8, z5, z6  )

     volume = volume + tet_volume( x3, x2, x6, x4, &
                                   y3, y2, y6, y4, &
                                   z3, z2, z6, z4  )

     volume = volume + tet_volume( x3, x6, x7, x4, &
                                   y3, y6, y7, y4, &
                                   z3, z6, z7, z4  )

     volume = volume + tet_volume( x1, x2, x4, x6, &
                                   y1, y2, y4, y6, &
                                   z1, z2, z4, z6  )

     volume = volume + tet_volume( x4, x7, x8, x6, &
                                   y4, y7, y8, y6, &
                                   z4, z7, z8, z6  )

    vol_max = max(vol_max,volume)
    vol_min = min(vol_min,volume)
    vol_ave = vol_ave + volume

    if (volume < 0.0_dp) then

     write(8933,*) " Negative volume hex at element = ", i

     !Write a Tecplot file for the negative-volume tetrahedra,
     !only for the first 20 tetra (to avoid too many files).
     if (n_negative_vol < 21) then

      write( i_char  , '(i0)' ) i
      filename = "negative_vol_hex_" // trim(i_char) // "_tec.dat"
      open(unit=3, file=filename, status="unknown", iostat=os)
      write(3,*) 'TITLE = ', "negative_vol_tet_" // trim(i_char)
      write(3,*) 'VARIABLES = "x","y","z"'
      write(3,*) 'ZONE  N=', 8,',E=', 1,' , et=tetrahedron, F=FEPOINT'
      write(3,'(3ES20.10)') x1, y1, z1
      write(3,'(3ES20.10)') x2, y2, z2
      write(3,'(3ES20.10)') x3, y3, z3
      write(3,'(3ES20.10)') x4, y4, z4
      write(3,'(3ES20.10)') x5, y5, z5
      write(3,'(3ES20.10)') x6, y6, z6
      write(3,'(3ES20.10)') x7, y7, z7
      write(3,'(3ES20.10)') x8, y8, z8
      write(3,'(4i10)'    )  1, 2, 3, 4, 5, 6, 7, 8
      close(3)

     endif

     n_negative_vol = n_negative_vol + 1

     ! Display a WARNING MESSAGE
     if (n_negative_vol == 1) then
      write(*,*)
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) " Negative Hex volume deteceted. See fort.8933..."
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*)
     endif

    endif

   end do
  !-------------------------------------------------------------
  ! End of loop over hex
  !-------------------------------------------------------------

   vol_ave = vol_ave / real(nhex,dp)

   if (n_negative_vol == 0) then
     write(*,*)
     write(*,*) " Negative hex volume not detected. "
     write(*,*)
   endif

   write(*,*)
   write(*,'(a,es26.16)') " Minimum hexahedral volume = ", vol_min
   write(*,'(a,es26.16)') " Maximum hexahedral volume = ", vol_max
   write(*,'(a,es26.16)') " Average hexahedral volume = ", vol_ave
   write(*,*)

   if (n_negative_vol > 0) then
     write(*,*) " Hexahedra with negative volume created....."
     write(*,*) "  # of hex having negative volume = ", n_negative_vol
     negative_volume(ihex) = .true.
   endif

 endif hex_vol_check

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! End fo (2)Check Hexahedral elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------


!--------------------------------------------------------------------
!--------------------------------------------------------------------
! (3)Check Prismatic elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------
 prs_vol_check : if (ncprs > 0) then

   n_negative_vol = 0
   vol_max = -1.0_dp
   vol_min =  1.0e+15_dp
   vol_ave =  0.0_dp

  !-------------------------------------------------------------
  ! Loop over prism and check the volumne one by one.
  !-------------------------------------------------------------
   do i = 1, ncprs

    v(1:6) =  cprs(i,1:6)

    x1 = xc( v(1) )
    y1 = yc( v(1) )
    z1 = zc( v(1) )

    x2 = xc( v(2) )
    y2 = yc( v(2) )
    z2 = zc( v(2) )

    x3 = xc( v(3) )
    y3 = yc( v(3) )
    z3 = zc( v(3) )

    x4 = xc( v(4) )
    y4 = yc( v(4) )
    z4 = zc( v(4) )

    x5 = xc( v(5) )
    y5 = yc( v(5) )
    z5 = zc( v(5) )

    x6 = xc( v(6) )
    y6 = yc( v(6) )
    z6 = zc( v(6) )

  !Cut prism into 3 tetrahedra and compute the volume of prism:

     volume = 0.0_dp
     volume = volume + tet_volume( x1, x2, x3, x4, &
                                   y1, y2, y3, y4, &
                                   z1, z2, z3, z4  )

     volume = volume + tet_volume( x5, x6, x3, x4, &
                                   y5, y6, y3, y4, &
                                   z5, z6, z3, z4  )

     volume = volume + tet_volume( x5, x3, x2, x4, &
                                   y5, y3, y2, y4, &
                                   z5, z3, z2, z4  )

    vol_max = max(vol_max,volume)
    vol_min = min(vol_min,volume)
    vol_ave = vol_ave + volume

    if (volume < 0.0_dp) then

     write(8933,*) " Negative volume prism at element = ", i

     !Write a Tecplot file for the negative-volume tetrahedra,
     !only for the first 20 tetra (to avoid too many files).
     if (n_negative_vol < 21) then

      write( i_char  , '(i0)' ) i
      filename = "negative_vol_prism_" // trim(i_char) // "_tec.dat"
      open(unit=3, file=filename, status="unknown", iostat=os)
      write(3,*) 'TITLE = ', "negative_vol_tet_" // trim(i_char)
      write(3,*) 'VARIABLES = "x","y","z"'
      write(3,*) 'ZONE  N=', 6,',E=', 1,' , et=tetrahedron, F=FEPOINT'
      write(3,'(3ES20.10)') x1, y1, z1
      write(3,'(3ES20.10)') x2, y2, z2
      write(3,'(3ES20.10)') x3, y3, z3
      write(3,'(3ES20.10)') x4, y4, z4
      write(3,'(3ES20.10)') x5, y5, z5
      write(3,'(3ES20.10)') x6, y6, z6
      write(3,'(4i10)'    )  1, 2, 3, 4, 5, 6
      close(3)

     endif

     n_negative_vol = n_negative_vol + 1

     ! Display a WARNING MESSAGE
     if (n_negative_vol == 1) then
      write(*,*)
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) " Negative Prism volume deteceted. See fort.8933..."
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*) "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      write(*,*)
     endif

    endif

   end do
  !-------------------------------------------------------------
  ! End of loop over prism
  !-------------------------------------------------------------

   vol_ave = vol_ave / real(nprs,dp)

   if (n_negative_vol == 0) then
     write(*,*)
     write(*,*) " Negative prism volume not detected."
     write(*,*)
   endif

   write(*,*)
   write(*,'(a,es26.16)') " Minimum prismatic volume = ", vol_min
   write(*,'(a,es26.16)') " Maximum prismatic volume = ", vol_max
   write(*,'(a,es26.16)') " Average prismatic volume = ", vol_ave
   write(*,*)

   if (n_negative_vol > 0) then
     write(*,*) " prisms with negative volume created....."
     write(*,*) "  # of prisms having negative volume = ", n_negative_vol
     negative_volume(iprs) = .true.
   endif

 endif prs_vol_check

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! End fo (3)Check Prismatic elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------


  end subroutine volume_check

!*******************************************************************************
! Compute the volume of a hexahedron defined by 8 vertices:
!
!       (x1,y1,z1), (x2,y2,z2), (x3,y3,z3), (x4,y4,z4),
!       (x5,y5,z5), (x6,y6,z6), (x7,y7,z7), (x8,y8,z8),
!
!       5             8
!       o------------o
!       |\           .\
!       | \          . \ 
!       |  \         .  \
!       |   \ 6      .   \ 7
!       |    o -----------o
!       |    |       .    |
!       |    |       .    |
!       |    |       .    |
!     1 o----|-------o 4  |
!        \   |        \   |
!         \  |         \  |
!          \ |          \ |
!           \|           \|
!            o------------o
!            2            3
!
!*******************************************************************************
 function hex_volume( x1,x2,x3,x4,x5,x6,x7,x8, &
                      y1,y2,y3,y4,y5,y6,y7,y8, &
                      z1,z2,z3,z4,z5,z6,z7,z8  )

 implicit none

 integer , parameter :: dp = selected_real_kind(15) !Double precision

 !Input
 real(dp), intent(in)   :: x1,x2,x3,x4,x5,x6,x7,x8
 real(dp), intent(in)   :: y1,y2,y3,y4,y5,y6,y7,y8
 real(dp), intent(in)   :: z1,z2,z3,z4,z5,z6,z7,z8
 !Output
 real(dp)               :: hex_volume

     hex_volume = 0.0_dp

     hex_volume = hex_volume + tet_volume( x1, x4, x5, x6, &
                                           y1, y4, y5, y6, &
                                           z1, z4, z5, z6  )

     hex_volume = hex_volume + tet_volume( x4, x8, x5, x6, &
                                           y4, y8, y5, y6, &
                                           z4, z8, z5, z6  )

     hex_volume = hex_volume + tet_volume( x3, x2, x6, x4, &
                                           y3, y2, y6, y4, &
                                           z3, z2, z6, z4  )

     hex_volume = hex_volume + tet_volume( x3, x6, x7, x4, &
                                           y3, y6, y7, y4, &
                                           z3, z6, z7, z4  )

     hex_volume = hex_volume + tet_volume( x1, x2, x4, x6, &
                                           y1, y2, y4, y6, &
                                           z1, z2, z4, z6  )

     hex_volume = hex_volume + tet_volume( x4, x7, x8, x6, &
                                           y4, y7, y8, y6, &
                                           z4, z7, z8, z6  )

 end function hex_volume

!*******************************************************************************
! Compute the volume of a prism defined by 6 vertices:
!
!       (x1,y1,z1), (x2,y2,z2), (x3,y3,z3), (x4,y4,z4),
!       (x5,y5,z5), (x6,y6,z6)
!
!                  6
!                  o
!                 /.\
!                / . \
!               /  .  \ 
!              /   .   \
!             /    .    \ 
!          4 o ----------o 5
!            |     .     |
!            |     .     |
!            |     o3    |
!            |    / \    |
!            |   /   \   |
!            |  /     \  |
!            | /       \ |
!            |/         \|
!            o-----------o
!            1           2
!
!*******************************************************************************
 function prs_volume( x1,x2,x3,x4,x5,x6, &
                      y1,y2,y3,y4,y5,y6, &
                      z1,z2,z3,z4,z5,z6  )

 implicit none

 integer , parameter :: dp = selected_real_kind(15) !Double precision

 !Input
 real(dp), intent(in)   :: x1,x2,x3,x4,x5,x6
 real(dp), intent(in)   :: y1,y2,y3,y4,y5,y6
 real(dp), intent(in)   :: z1,z2,z3,z4,z5,z6
 !Output
 real(dp)               :: prs_volume

     prs_volume = 0.0_dp

     prs_volume = prs_volume + tet_volume( x1, x2, x3, x4, &
                                           y1, y2, y3, y4, &
                                           z1, z2, z3, z4  )

     prs_volume = prs_volume + tet_volume( x5, x6, x3, x4, &
                                           y5, y6, y3, y4, &
                                           z5, z6, z3, z4  )

     prs_volume = prs_volume + tet_volume( x5, x3, x2, x4, &
                                           y5, y3, y2, y4, &
                                           z5, z3, z2, z4  )

 end function prs_volume

!*******************************************************************************
! Compute the volume of a tetrahedron defined by 4 vertices:
!
!       (x1,y1,z1), (x2,y2,z2), (x3,y3,z3), (x4,y4,z4),
!
! which are ordered as follows:
!
!            1
!            o
!           /| .
!          / |   .
!         /  |     .
!        /   |       .
!     2 o----|-------o 3
!        \   |     .
!         \  |    .
!          \ |  .
!           \|.
!            o
!            4
!
! Note: Volume = volume integral of 1 = 1/3 * volume integral of div(x,y,z) dV
!              = surface integral of (x,y,z)*dS
!              = sum of [ (xc,yc,zc)*area_vector ] over triangular faces.
!
! where the last step is exact because (x,y,z) vary linearly over the triangle.
! There are other ways to compute the volume, of course.
!
!*******************************************************************************
 function tet_volume(x1,x2,x3,x4, y1,y2,y3,y4, z1,z2,z3,z4)

 implicit none

 integer , parameter :: dp = selected_real_kind(15) !Double precision

 !Input
 real(dp), intent(in)   :: x1,x2,x3,x4, y1,y2,y3,y4, z1,z2,z3,z4
 !Output
 real(dp)               :: tet_volume

 real(dp)               :: xc, yc, zc
 real(dp), dimension(3) :: area
 integer(kd)                :: ix=1, iy=2, iz=3


 tet_volume = 0.0_dp

! Triangle 1-3-2

   !Centroid of the triangular face
      xc = (x1+x3+x2)/3.0_dp
      yc = (y1+y3+y2)/3.0_dp
      zc = (z1+z3+z2)/3.0_dp
   !Outward normal surface vector
   area = triangle_area_vector(x1,x3,x2, y1,y3,y2, z1,z3,z2)

   tet_volume = tet_volume + ( xc*area(ix) + yc*area(iy) + zc*area(iz) )

! Triangle 1-4-3

   !Centroid of the triangular face
      xc = (x1+x4+x3)/3.0_dp
      yc = (y1+y4+y3)/3.0_dp
      zc = (z1+z4+z3)/3.0_dp
   !Outward normal surface vector
   area = triangle_area_vector(x1,x4,x3, y1,y4,y3, z1,z4,z3)

   tet_volume = tet_volume + ( xc*area(ix) + yc*area(iy) + zc*area(iz) )

! Triangle 1-2-4

   !Centroid of the triangular face
      xc = (x1+x2+x4)/3.0_dp
      yc = (y1+y2+y4)/3.0_dp
      zc = (z1+z2+z4)/3.0_dp
   !Outward normal surface vector
   area = triangle_area_vector(x1,x2,x4, y1,y2,y4, z1,z2,z4)

   tet_volume = tet_volume + ( xc*area(ix) + yc*area(iy) + zc*area(iz) )

! Triangle 2-3-4

   !Centroid of the triangular face
      xc = (x2+x3+x4)/3.0_dp
      yc = (y2+y3+y4)/3.0_dp
      zc = (z2+z3+z4)/3.0_dp
   !Outward normal surface vector
   area = triangle_area_vector(x2,x3,x4, y2,y3,y4, z2,z3,z4)

   tet_volume = tet_volume + ( xc*area(ix) + yc*area(iy) + zc*area(iz) )

   tet_volume = tet_volume / 3.0_dp

 end function tet_volume

!*******************************************************************************
! Compute the area of a triangle in 3D defined by 3 vertices:
!
!       (x1,y1,z1), (x2,y2,z2), (x3,y3,z3),
!
! which is assumed to be ordered clockwise.
!
!     1             2
!      o------------o
!       \         .
!        \       . --------->
!         \    .
!          \ .
!           o
!           3
!
! Note: Area is a vector based on the right-hand rule: 
!       when wrapping the right hand around the triangle with the fingers in the
!       direction of the vertices [1,2,3], the thumb points in the positive
!       direction of the area.
!
! Note: Area vector is computed as the cross product of edge vectors [31] and [32].
!
!*******************************************************************************
 function triangle_area_vector(x1,x2,x3, y1,y2,y3, z1,z2,z3) result(area_vector)
 
 implicit none
 integer , parameter :: dp = selected_real_kind(15) !Double precision

 !Input
  real(dp), intent(in)   :: x1,x2,x3, y1,y2,y3, z1,z2,z3
 !Output
  real(dp), dimension(3) :: area_vector

  integer(kd) :: ix=1, iy=2, iz=3

   area_vector(ix) = 0.5_dp*( (y1-y3)*(z2-z3)-(z1-z3)*(y2-y3) )
   area_vector(iy) = 0.5_dp*( (z1-z3)*(x2-x3)-(x1-x3)*(z2-z3) )
   area_vector(iz) = 0.5_dp*( (x1-x3)*(y2-y3)-(y1-y3)*(x2-x3) )

 end function triangle_area_vector


!*******************************************************************************
! Compute the unit area vector of a triangle in 3D.
!
!*******************************************************************************
 function unit_triangle_area_vector(x1,x2,x3, y1,y2,y3, z1,z2,z3) result(area_vector)
 
 implicit none
 integer , parameter :: dp = selected_real_kind(15) !Double precision

 !Input
  real(dp), intent(in)   :: x1,x2,x3, y1,y2,y3, z1,z2,z3
 !Output
  real(dp), dimension(3) :: area_vector

  real(dp) :: mag
  integer(kd)  :: ix=1, iy=2, iz=3

   area_vector(ix) = 0.5_dp*( (y1-y3)*(z2-z3)-(z1-z3)*(y2-y3) )
   area_vector(iy) = 0.5_dp*( (z1-z3)*(x2-x3)-(x1-x3)*(z2-z3) )
   area_vector(iz) = 0.5_dp*( (x1-x3)*(y2-y3)-(y1-y3)*(x2-x3) )

   mag = sqrt(   area_vector(ix)**2 &
               + area_vector(iy)**2 &
               + area_vector(iz)**2 )

   if (mag < 1.0e-18) then
    write(*,*) "!!!!!!!!!!!!!!!!!!! Very small area vector...: Area = ", mag
    stop
   endif

   area_vector = area_vector / mag

 end function unit_triangle_area_vector

!********************************************************************************
!* Check non-planarity of quad faces.
!*
!* Note: All faces are oriented clockwise to give an outward area vector.
!*
!********************************************************************************
  subroutine non_planarity_check
  implicit none

  real(dp) :: x1,x2,x3,x4, y1,y2,y3,y4, z1,z2,z3,z4
  real(dp) :: cos_max, cos_min, cos_ave

  integer(kd)               :: i, k, nqface
  integer(kd), dimension(8) :: v

  !3 quad-faces for prism, 6 quad-faces for hex.
  integer(kd), dimension(6,4) :: face

  real(dp), dimension(3) :: unit_norm01, unit_norm02
  real(dp)               :: cos_p1, cos_p2, cos_p

   cos_max = -1.0_dp
   cos_min =  1.0e+15_dp
   cos_ave =  0.0_dp
    nqface = 0

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! (2)Loop over Hexahedral elements
!
!       5             8
!       o------------o
!       |\           .\
!       | \          . \ 
!       |  \         .  \
!       |   \ 6      .   \ 7
!       |    o -----------o
!       |    |       .    |
!       |    |       .    |
!       |    |       .    |
!     1 o----|-------o 4  |
!        \   |        \   |
!         \  |         \  |
!          \ |          \ |
!           \|           \|
!            o------------o
!            2            3
!
!--------------------------------------------------------------------
!--------------------------------------------------------------------
 hex_check : if (nchex > 0) then

  !-------------------------------------------------------------
  ! Loop over hex and check quad faces  one by one.
  !-------------------------------------------------------------
   do i = 1, nchex

    v(1:8) =  chex(i,1:8)

    face(1, 1) = v(1)
    face(1, 2) = v(4)
    face(1, 3) = v(3)
    face(1, 4) = v(2)

    face(2, 1) = v(5)
    face(2, 2) = v(6)
    face(2, 3) = v(7)
    face(2, 4) = v(8)

    face(3, 1) = v(1)
    face(3, 2) = v(2)
    face(3, 3) = v(6)
    face(3, 4) = v(5)

    face(4, 1) = v(3)
    face(4, 2) = v(4)
    face(4, 3) = v(8)
    face(4, 4) = v(7)

    face(5, 1) = v(1)
    face(5, 2) = v(5)
    face(5, 3) = v(8)
    face(5, 4) = v(4)

    face(6, 1) = v(2)
    face(6, 2) = v(3)
    face(6, 3) = v(7)
    face(6, 4) = v(6)

    do k = 1, 6

     nqface = nqface + 1

     x1 = xc( face(k,1) )
     y1 = yc( face(k,1) )
     z1 = zc( face(k,1) )

     x2 = xc( face(k,2) )
     y2 = yc( face(k,2) )
     z2 = zc( face(k,2) )

     x3 = xc( face(k,3) )
     y3 = yc( face(k,3) )
     z3 = zc( face(k,3) )

     x4 = xc( face(k,4) )
     y4 = yc( face(k,4) )
     z4 = zc( face(k,4) )

   !Compute the dot product of unit normals of triangular faces within the quad:
   !There are two possible pairs of triangular faces.
   !The dot product is equal to cos(angle) because the normals are unit vectors.

     unit_norm01 = unit_triangle_area_vector(x1,x2,x3, y1,y2,y3, z1,z2,z3)
     unit_norm02 = unit_triangle_area_vector(x1,x3,x4, y1,y3,y4, z1,z3,z4)

     cos_p1 = unit_norm01(1)*unit_norm02(1) &
            + unit_norm01(2)*unit_norm02(2) &
            + unit_norm01(3)*unit_norm02(3)

     unit_norm01 = unit_triangle_area_vector(x1,x2,x4, y1,y2,y4, z1,z2,z4)
     unit_norm02 = unit_triangle_area_vector(x2,x3,x4, y2,y3,y4, z2,z3,z4)

     cos_p2 = unit_norm01(1)*unit_norm02(1) &
            + unit_norm01(2)*unit_norm02(2) &
            + unit_norm01(3)*unit_norm02(3)

     cos_p = max(cos_p1, cos_p2)

    cos_max = max(cos_max,cos_p)
    cos_min = min(cos_min,cos_p)
    cos_ave = cos_ave + cos_p

    end do

   end do
  !-------------------------------------------------------------
  ! End of loop over hex
  !-------------------------------------------------------------

 endif hex_check

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! End fo (2)Loop over Hexahedral elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! (2)Loop over Prismatic elements
!
!                  6
!                  o
!                 /.\
!                / . \
!               /  .  \ 
!              /   .   \
!             /    .    \ 
!          4 o ----------o 5
!            |     .     |
!            |     .     |
!            |     o3    |
!            |    / \    |
!            |   /   \   |
!            |  /     \  |
!            | /       \ |
!            |/         \|
!            o-----------o
!            1           2
!
!--------------------------------------------------------------------
!--------------------------------------------------------------------
 prs_check : if (ncprs > 0) then

  !-------------------------------------------------------------
  ! Loop over prisms and check quad faces one by one.
  !-------------------------------------------------------------
   do i = 1, ncprs

    v(1:6) =  cprs(i,1:6)

    face(1, 1) = v(1)
    face(1, 2) = v(2)
    face(1, 3) = v(5)
    face(1, 4) = v(4)

    face(2, 1) = v(3)
    face(2, 2) = v(1)
    face(2, 3) = v(4)
    face(2, 4) = v(6)

    face(3, 1) = v(2)
    face(3, 2) = v(3)
    face(3, 3) = v(6)
    face(3, 4) = v(5)

    do k = 1, 3

     nqface = nqface + 1

     x1 = xc( face(k,1) )
     y1 = yc( face(k,1) )
     z1 = zc( face(k,1) )

     x2 = xc( face(k,2) )
     y2 = yc( face(k,2) )
     z2 = zc( face(k,2) )

     x3 = xc( face(k,3) )
     y3 = yc( face(k,3) )
     z3 = zc( face(k,3) )

     x4 = xc( face(k,4) )
     y4 = yc( face(k,4) )
     z4 = zc( face(k,4) )

   !Compute the dot product of unit normals of triangular faces within the quad:
   !There are two possible pairs of triangular faces.
   !The dot product is equal to cos(angle) because the normals are unit vectors.

     unit_norm01 = unit_triangle_area_vector(x1,x2,x3, y1,y2,y3, z1,z2,z3)
     unit_norm02 = unit_triangle_area_vector(x1,x3,x4, y1,y3,y4, z1,z3,z4)

     cos_p1 = unit_norm01(1)*unit_norm02(1) &
            + unit_norm01(2)*unit_norm02(2) &
            + unit_norm01(3)*unit_norm02(3)

     unit_norm01 = unit_triangle_area_vector(x1,x2,x4, y1,y2,y4, z1,z2,z4)
     unit_norm02 = unit_triangle_area_vector(x2,x3,x4, y2,y3,y4, z2,z3,z4)

     cos_p2 = unit_norm01(1)*unit_norm02(1) &
            + unit_norm01(2)*unit_norm02(2) &
            + unit_norm01(3)*unit_norm02(3)

     cos_p = max(cos_p1, cos_p2)

    cos_max = max(cos_max,cos_p)
    cos_min = min(cos_min,cos_p)
    cos_ave = cos_ave + cos_p

    end do

   end do
  !-------------------------------------------------------------
  ! End of loop over hex
  !-------------------------------------------------------------

 endif prs_check

!--------------------------------------------------------------------
!--------------------------------------------------------------------
! End of (2)Loop over Prismatic elements
!--------------------------------------------------------------------
!--------------------------------------------------------------------


   cos_ave = cos_ave / real(nqface,dp)

   write(*,*)
   write(*,*) " Non-planarity:"
   write(*,*) "   Each quad face is split into two triangles: T1 and T2."
   write(*,*) "   Dot product of unit tria-face normals computed: n(T1)*n(T2)."
   write(*,*) "   Two possible splits considered, and the larger is taken."
   write(*,*)
   write(*,'(a,es26.16)') " Minimum  = ", cos_min
   write(*,'(a,es26.16)') " Maximum  = ", cos_max
   write(*,'(a,es26.16)') " Average  = ", cos_ave
   write(*,*)

 end subroutine non_planarity_check

!*******************************************************************************
! Add a c-grid cell to the list of c-cell neghbors of an f-grid node.
!
! Note: ncelms(fnode) = # of c-grid cells sharing the f-grid node, fnode.
!       celm(fnode,:) = List of c-grid cells sharing the f-grid node.
!*******************************************************************************
 subroutine add_to_celm(fnode,coarse_cell)

 integer(kd), intent(in) :: fnode, coarse_cell

               ncelms(fnode)  =            ncelms(fnode)  + 1
    celm(fnode,ncelms(fnode)) = celm(fnode,ncelms(fnode)) + coarse_cell

 end subroutine add_to_celm
!********************************************************************************

!*******************************************************************************
! Find a c-grid boundary cell in which the f-grid cell is contained.
!
! nvtx: # of vertices of an f-grid boundary element)
!  vtx: The list of the vertices.
!
! Find a c-grid cell number shared by all the vertices.
! There must be a common number.
! Then, the f-grid cell is contained in the c-grid cell (topologically).
! Return this value as a result.
!
!*******************************************************************************
 function find_common_ccell(vtx,nvtx)

 integer(kd), dimension(:), intent(in) :: vtx
 integer(kd),               intent(in) :: nvtx

 integer(kd) :: i, k, i_min, ncelms_min, ic, find_common_ccell
 logical, dimension(4) :: found

  find_common_ccell = 0
              found = .false.

!---------------------------------------------------------------------
! To minimize the work, first find the vertex shared by
! the least number of c-grid cells.
!---------------------------------------------------------------------

       i_min = 1
  ncelms_min = ncelms(vtx(1)) 

  do i = 2, nvtx
   if (ncelms_min > ncelms(vtx(i)) ) then
         i_min = i
    ncelms_min = ncelms(vtx(i)) 
   endif
  end do

    found(i_min) = .true.
    if (nvtx == 3) found(4) = .true.

!---------------------------------------------------------------------
! Loop over the c-grid cells for the vertex found above.
!---------------------------------------------------------------------

!           i_min = 1
!           found = .false.
!    found(i_min) = .true.
!    if (nvtx == 3) found(4) = .true.

  do k = 1, ncelms(vtx(i_min))
    ic = celm(vtx(i_min),k)

  !--------------------------------------
  ! For each remaining vertex, check if it is in the c-grid cell 'ic'.
   do i = 1, nvtx
   if (i==i_min) cycle ! Skip the i_min vertex.

    found(i) = .false.

   !Loop over the list of c-grid cell of vertex i.
    do j = 1,  ncelms(vtx(i))
     if (ic == celm(vtx(i),j)) then
      found(i) = .true.
      exit
     endif
    end do

   end do
  !--------------------------------------

!-----------------------------------------------------------------------
! If the same c-grid cell found at all vertices, congratulations!
! You've just identified the c-grid cell that contains the f-grid cell.
!-----------------------------------------------------------------------

   if (found(1) .and. found(2) .and. found(3) .and. found(4)) then
    find_common_ccell = ic
    return
   endif

  end do
!---------------------------------------------------------------------

   write(*,*) " This cannot happen... Something is wrong... : find_common_ccell()"
   write(*,*) "    nvtx = ", nvtx
   stop

 end function find_common_ccell
!********************************************************************************

!*******************************************************************************
! This subroutine writes a Tecplot file for the volume grid.
!*******************************************************************************
 subroutine write_tet_tec(filename_elm,    &
                              x1,x2,x3,x4, &
                              y1,y2,y3,y4, &
                              z1,z2,z3,z4  )

 character(80), intent(in) :: filename_elm
 real(dp)     , intent(in) :: x1,x2,x3,x4
 real(dp)     , intent(in) :: y1,y2,y3,y4
 real(dp)     , intent(in) :: z1,z2,z3,z4

 open(unit=8, file=filename_elm, status="unknown", iostat=os)
 write(8,*) 'TITLE = "element"'
 write(8,*) 'VARIABLES = "x","y","z"'

! Hex zone

   write(8,*) 'zone t="Tet"  n=', 4,',e=', 1,' , et=tetrahedron, f=fepoint'
     write(8,'(3es20.10)') x1,y1,z1
     write(8,'(3es20.10)') x2,y2,z2
     write(8,'(3es20.10)') x3,y3,z3
     write(8,'(3es20.10)') x4,y4,z4

    write(8,'(8i10)') 1,2,3,4

 close(8)

 end subroutine write_tet_tec
!********************************************************************************

!*******************************************************************************
! This returns the element type of a c-grid cell:
!
! Input:
!
!  c-grid cell number: This is a number within [1, nctet + ncprs + nchex].
!                      The cells are ordered as tetra -> prisms -> hexa.
!
! Output:
!
!  4 = tetra
!  6 = prism
!  8 = hexa
!
!*******************************************************************************
 function elm_type_c(icell)

 integer(kd), intent(in) :: icell
 integer(kd)             :: elm_type_c

 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------
 ! 'hch_prism', 'hch_mixed_ph', or 'hch_strct'
 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------

  if (nctet == 0) then

   !---------------------------------
   ! 'hch_prism'
   !---------------------------------

    if (nchex == 0) then

     elm_type_c = 6 ! Prism
     return

   !---------------------------------
   ! 'hch_mixed_ph', or 'hch_strct'
   !---------------------------------

    else

     if (icell < ncprs + 1) then

       elm_type_c = 6 ! Prism
       return

     else

       elm_type_c = 8 ! Hexa
       return

     endif

    endif

 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------
 ! 'hch_tetra', 'hch_mixed'
 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------

  else

     if (icell < nctet + 1) then

       elm_type_c = 4 ! Tetra
       return

     else

       elm_type_c = 6 ! Prism
       return

     endif

  endif
 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------
 !
 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------

 end function elm_type_c
!********************************************************************************

!*******************************************************************************
! This returns the element type of a f-grid cell:
!
! Input:
!
!  f-grid cell number: This is a number within [1, ntet + nprs + nhex].
!                      The cells are ordered as tetra -> prisms -> hexa.
!
! Output:
!
!  4 = tetra
!  6 = prism
!  8 = hexa
!
!*******************************************************************************
 function elm_type_f(icell)

 integer(kd), intent(in) :: icell
 integer(kd)             :: elm_type_f

 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------
 ! 'hch_prism', 'hch_mixed_ph', or 'hch_strct'
 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------

  if (ntet == 0) then

   !---------------------------------
   ! 'hch_prism'
   !---------------------------------

    if (nhex == 0) then

     elm_type_f = 6 ! Prism
     return

   !---------------------------------
   ! 'hch_mixed_ph', or 'hch_strct'
   !---------------------------------

    else

     if (icell < nprs + 1) then

       elm_type_f = 6 ! Prism
       return

     else

       elm_type_f = 8 ! Hexa
       return

     endif

    endif

 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------
 ! 'hch_tetra', 'hch_mixed'
 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------

  else

     if (icell < ntet + 1) then

       elm_type_f = 4 ! Tetra
       return

     else

       elm_type_f = 6 ! Prism
       return

     endif

  endif
 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------
 !
 !-------------------------------------------------------------------------------
 !-------------------------------------------------------------------------------

 end function elm_type_f
!********************************************************************************

!*******************************************************************************
! Find a c-grid tet cell that contains the f-grid cell.
!
!      fcell : An f-grid cell.
! ctet3(1:3) : 3 c-grid tetrahedra that you think contains an f-grid cell, fcell.
!
!*******************************************************************************
 function find_ctet_for_fcell(ctet3,fcell)

 integer(kd), dimension(3), intent(in) :: ctet3
 integer(kd),               intent(in) :: fcell
 integer(kd)                           :: find_ctet_for_fcell

! Local variables
 integer(kd)               :: i, k, ii
 logical, dimension(4) :: found
 logical               :: addit
 
 integer(kd)               :: ifnode, icell, icell_found
 integer(kd)               :: ncccells
 integer(kd), dimension(3) :: cccell

 character(80) :: filename_temp, char_temp

  find_ctet_for_fcell = 0
                found = .false.

!---------------------------------------------------------------------
! Find ccells that contain the first node of the f-cell.
!---------------------------------------------------------------------

  ifnode = tet(fcell,1)

  ncccells = 0

 !----------------------------------------
  do i = 1, 3

   icell = ctet3(i)

   !----------------------------------------
   tet_vtx : do k = 1, 10
    if ( ctet(icell,k) == ifnode ) then
      ncccells = ncccells + 1
      cccell(ncccells) = icell
      found(1) = .true.
      exit tet_vtx
    endif
   end do tet_vtx
   !----------------------------------------

  end do
 !----------------------------------------

  if (ncccells == 0 .or. ncccells > 3) then
   write(*,*) " Strange... cccells = ", ncccells 
   stop
  endif

  if (.not.found(1)) then
   write(*,*) " Not found... Strange... find_ctet_for_fcell(). Stop"
   write(*,*) "  ncccells  = ", ncccells
   write(*,*) "  fcell = ", fcell
   write(*,*) "  ctet3 = ", ctet3


    write( char_temp  , '(i0)' ) fcell
    filename_temp = "debug2_find_ctet_for_fcell_ftet_" // trim(char_temp) // ".dat"
    write(*,*) " Writing a tecplot file for fcell: ", trim(filename_temp)
    call write_tet_tec(filename_temp,            &
      xf(tet(fcell,1)), xf(tet(fcell,2)), xf(tet(fcell,3)), xf(tet(fcell,4)), &
      yf(tet(fcell,1)), yf(tet(fcell,2)), yf(tet(fcell,3)), yf(tet(fcell,4)), &
      zf(tet(fcell,1)), zf(tet(fcell,2)), zf(tet(fcell,3)), zf(tet(fcell,4))  )

    write( char_temp  , '(i0)' ) ctet3(1)
    filename_temp = "debug2_find_ctet_for_fcell_ctet_" // trim(char_temp) // ".dat"
    write(*,*) " Writing a tecplot file for ccell1: ", trim(filename_temp)
    call write_tet_tec(filename_temp,            &
      xf(ctet(fcell,1)), xf(ctet(fcell,2)), xf(ctet(fcell,3)), xf(ctet(fcell,4)), &
      yf(ctet(fcell,1)), yf(ctet(fcell,2)), yf(ctet(fcell,3)), yf(ctet(fcell,4)), &
      zf(ctet(fcell,1)), zf(ctet(fcell,2)), zf(ctet(fcell,3)), zf(ctet(fcell,4))  )

    write( char_temp  , '(i0)' ) ctet3(2)
    filename_temp = "debug2_find_ctet_for_fcell_ctet_" // trim(char_temp) // ".dat"
    write(*,*) " Writing a tecplot file for ccell2: ", trim(filename_temp)
    call write_tet_tec(filename_temp,            &
      xf(ctet(fcell,1)), xf(ctet(fcell,2)), xf(ctet(fcell,3)), xf(ctet(fcell,4)), &
      yf(ctet(fcell,1)), yf(ctet(fcell,2)), yf(ctet(fcell,3)), yf(ctet(fcell,4)), &
      zf(ctet(fcell,1)), zf(ctet(fcell,2)), zf(ctet(fcell,3)), zf(ctet(fcell,4))  )

    write( char_temp  , '(i0)' ) ctet3(3)
    filename_temp = "debug2_find_ctet_for_fcell_ctet_" // trim(char_temp) // ".dat"
    write(*,*) " Writing a tecplot file for ccell3: ", trim(filename_temp)
    call write_tet_tec(filename_temp,            &
      xf(ctet(fcell,1)), xf(ctet(fcell,2)), xf(ctet(fcell,3)), xf(ctet(fcell,4)), &
      yf(ctet(fcell,1)), yf(ctet(fcell,2)), yf(ctet(fcell,3)), yf(ctet(fcell,4)), &
      zf(ctet(fcell,1)), zf(ctet(fcell,2)), zf(ctet(fcell,3)), zf(ctet(fcell,4))  )

   stop
  endif

!---------------------------------------------------------------------
! Loop over the candidate ccells
!---------------------------------------------------------------------

  candidates : do i = 1, ncccells

    icell = cccell(i)

    found(2:4) = .false.

   do ii = 2, 4

       ifnode = tet(fcell,ii)

    do k = 1, 10
     if ( ctet(icell,k) == ifnode ) then
       found(ii) = .true.
       exit
     endif
    end do

   end do

! Sharing all vertices (fully contained)
   addit = ( found(1) .and. found(2) .and. found(3) .and. found(4))

   if (addit) then
    icell_found = icell
    exit candidates
   endif

  end do candidates


  if (addit) then
   find_ctet_for_fcell = icell_found
   return
  endif

!-----------------------------------------------------------------------------------
! Should not reach here...

   write(*,*) " This cannot happen... Something is wrong... : find_ctet_for_fcell()"
   write(*,*) "     fcell = ", fcell
   write(*,*) "     found = ", found
   write(*,*) "  ncccells = ", ncccells
   write(*,*)

   do i = 1, 4
    write(*,*) i, "  fcell node = ", tet(fcell,i)
   end do

    write( char_temp  , '(i0)' ) fcell
    filename_temp = "debug_ftet_" // trim(char_temp) // ".dat"
    call write_tet_tec(filename_temp,            &
      xf(tet(fcell,1)), xf(tet(fcell,2)), xf(tet(fcell,3)), xf(tet(fcell,4)), &
      yf(tet(fcell,1)), yf(tet(fcell,2)), yf(tet(fcell,3)), yf(tet(fcell,4)), &
      zf(tet(fcell,1)), zf(tet(fcell,2)), zf(tet(fcell,3)), zf(tet(fcell,4))  )

    write(*,*)

   do i = 1, 3
    write(*,*) i, "  ctet = ", ctet3(i)
    do k=1,10
     write(*,*) "                node = ",  ctet(ctet3(i),k)
    end do

    write( char_temp  , '(i0)' ) ctet3(i)
    filename_temp = "debug_ctet_" // trim(char_temp) // ".dat"
    call write_tet_tec(filename_temp,            &
      xf(ctet(fcell,1)), xf(ctet(fcell,2)), xf(ctet(fcell,3)), xf(ctet(fcell,4)), &
      yf(ctet(fcell,1)), yf(ctet(fcell,2)), yf(ctet(fcell,3)), yf(ctet(fcell,4)), &
      zf(ctet(fcell,1)), zf(ctet(fcell,2)), zf(ctet(fcell,3)), zf(ctet(fcell,4))  )

   end do

   stop

 end function find_ctet_for_fcell
!********************************************************************************

!*******************************************************************************
! This generates natural partitions based on coarser grids.
! 
!*******************************************************************************
 subroutine write_ntrl_part_files_cc

 character(80) :: filename_c2f       , cgrid_level_char
 character(80) :: filename_part , fgrid_level_char
 character(80) :: ncelms_char, filename_lines_all_finer
 integer       :: icgrid
 character(80) :: dummy

 integer(kd)                              :: i, k, nccells_body, nfcells
 integer(kd), dimension(:)  , allocatable :: nf
 integer(kd), dimension(:,:), allocatable :: fcell
 integer(kd)                              :: ifcell

 integer(kd), dimension(:,:), allocatable :: fline_all
 integer(kd), dimension(:)  , allocatable :: part

 integer(kd) :: j, n_lines_all, n_total_points_all, min_points_all, max_points_all

 integer       :: igrid, nccells

 integer(kd), dimension(:)  , allocatable :: part2
 integer(kd), dimension(:)  , allocatable :: nccells_prlng
 integer(kd), dimension(:,:), allocatable :: ccell_prlng

  filename_c2f_cell_body = trim(project) // trim(".") // trim(cgrid_level_char) // '.surface.cc.c2f'

!-----------------------------------------------------------------------------
! Begin with the coarsest level, and move up.

 outer : do icgrid = ngrids, 2, -1

  !----------------------------
  ! Read .surface.cc.c2f file.

    write( cgrid_level_char  , '(i0)' ) icgrid
    filename_c2f = trim(project) // trim(".") // trim(cgrid_level_char) // '.surface.cc.c2f'
    open(unit=58, file=filename_c2f, status="unknown", iostat=os)
     read(58,*) nccells_body
    allocate( nf(nccells_body), fcell(nccells_body,16) ) !16 may be needed for mixed grids.
    do i = 1, nccells_body
     read(58,*) nf(i), ( fcell(i,k), k = 1, nf(i) )
     if (nf(i)/=4) stop
    end do
    close(58)

   write(*,*) "   -----------------------------------------------------"
   write(*,*) "    Partitions = ", nccells_body

 !--------------------------------------------------------------------------
 ! 1-level-finer grid: igrid = icgrid-1: Use the line info here.

  !--------------------------------------------------
  ! Read the line file for the finer grid.

   write( fgrid_level_char  , '(i0)' ) icgrid-1
   filename_lines_all_finer = trim(project) // trim(".") // trim(fgrid_level_char) // '.lines_fmt_cc_all'
   open(unit=3, file=filename_lines_all_finer, status="unknown", iostat=os)
   read(3,*)    n_lines_all, n_total_points_all, dummy
   read(3,*) min_points_all,     max_points_all, dummy
   allocate(fline_all(max_points_all,n_lines_all))
   nfcells = n_total_points_all
   do i = 1, n_lines_all
      read(3,*) max_points_all, (dummy_v(j),j=1,6), k
      read(3,*) fline_all(1,i), dummy, x, y, z
     if (max_points_all > 2) then
      do k = 2, max_points_all-1
       read(3,*) fline_all(k,i)
      end do
     endif
     if (max_points_all > 1) then
      read(3,*) fline_all(max_points_all,i), dummy, x, y, z
     endif
   end do
   close(3)

  !--------------------------------------------------
  ! Allocate and fill the part array.
  ! Note: Coarse-grid cell # = partition #.

   allocate(part(nfcells))
   part = 0_kd

   !Loop over the coarse grid surface cells.
    do i = 1, nccells_body

    !Loop over fine grid cells contained in the coarse grid cell.
     do k = 1, nf(i)

       ifcell = fcell(i,k)

     !Move up in a fine-grid line and mark the fcell as i (partition number).
      do j = 1, max_points_all
       part( fline_all(j,ifcell) ) = i
      end do

     end do
    end do

  !Just checking...
   if (minval(part) <= 0) then
    write(*,*) " Error: minval(part) = ", minval(part)
    stop
   endif

  !--------------------------------------------------
  ! Write out the partition file.

   write(ncelms_char,'(i0)') nccells_body
   filename_part = trim(project) // trim(".") // trim(fgrid_level_char) // '.cc.ntrl_part_' // trim(ncelms_char)
   call write_part_file(filename_part,part,nfcells)
   write(*,*)
   write(*,*) "         Level = ", trim(fgrid_level_char), ": ", &
               trim(filename_part), nfcells/nccells_body," cells/part"

   deallocate(fline_all)

  !Prepare for the next level.
   nccells = nfcells

 !--------------------------------------------------------------------------
 ! 2-level-finer and up to the finest level:  igrid = icgrid-2,...,1
 ! Note: Here, we use prolongation info (instead of lin info).
 !--------------------------------------------------------------------------
 !--------------------------------------------------------------------------
  do igrid = icgrid-2, 1, -1

  !----------------------------
  ! Read .lines_fmt_cc_all file.
  ! This is the target grid that we're going to partition: part2(1:nfcells).

   write( fgrid_level_char  , '(i0)' ) igrid
   filename_lines_all_finer = trim(project) // trim(".") // trim(fgrid_level_char) // '.lines_fmt_cc_all'
   open(unit=3, file=filename_lines_all_finer, status="unknown", iostat=os)
   read(3,*)    n_lines_all, n_total_points_all, dummy
   close(3)
   nfcells = n_total_points_all

  !----------------------------
  ! Read .prolong_cc file.
  ! This is one-level coarser than the target level: part(1:nccells).

    write( cgrid_level_char  , '(i0)' ) igrid+1
    filename_prolong_cc = &
         trim(project) // trim(".") // trim(cgrid_level_char) // '.prolong_cc'
    if (prolong_file_unformatted) then
     open(unit=58, file=filename_prolong_cc, form='unformatted', status="unknown", iostat=os)
      read(58) nccells
     allocate( nccells_prlng(nccells), ccell_prlng(16,nccells)) !16 f-cells/c-cell for mixed
     do i = 1, nccells
      read(58) nccells_prlng(i), (ccell_prlng(k,i), k=1,nccells_prlng(i))
     end do
    else
     open(unit=58, file=filename_prolong_cc, status="unknown", iostat=os)
      read(58,*) nccells
     allocate( nccells_prlng(nccells), ccell_prlng(16,nccells)) !16 f-cells/c-cell for mixed
     do i = 1, nccells
      read(58,*) nccells_prlng(i), (ccell_prlng(k,i), k=1,nccells_prlng(i))
     end do
    endif
    close(58)

    allocate( part2(nfcells) )

   !-------------------------------
   ! Easy now since all fine-grid cells are topologically contained in a coarse-grid cell.
   ! Partition # is inherited from the coarse grid.

     do i = 1, nccells
      do k = 1, nccells_prlng(i)
       part2( ccell_prlng(k,i) ) = part(i)
      end do
     end do

    deallocate(part)

  !--------------------------------------------------
  ! Write out the partition file for the target 'igrid'-level.

   write( fgrid_level_char  , '(i0)' ) igrid
   filename_part = trim(project) // trim(".") // trim(fgrid_level_char) // '.cc.ntrl_part_' // trim(ncelms_char)
   call write_part_file(filename_part,part2,nfcells)
   write(*,*)
   write(*,*) "         Level = ", trim(fgrid_level_char), ": ", trim(filename_part), &
               nfcells/nccells_body," cells/part"

  !--------------------------------------------------
  ! Prepare for the next level.

    allocate( part(nfcells) )
    do i = 1, nfcells
      part(i) = part2(i)
    end do
    deallocate(part2)
    nccells = nfcells

    deallocate( nccells_prlng, ccell_prlng )

  end do
 !--------------------------------------------------------------------------
 !--------------------------------------------------------------------------

  deallocate(part)
  deallocate(nf,fcell)

 end do outer
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------

  ncelms_char = dummy 
  i = min_points_all

   write(*,*) "   -----------------------------------------------------"

 end subroutine write_ntrl_part_files_cc
!********************************************************************************

!*******************************************************************************
! Write a partition file.
!*******************************************************************************
 subroutine write_part_file(filename,part,n)

 character(80),             intent(in) :: filename
 integer(kd),               intent(in) :: n
 integer(kd), dimension(:), intent(in) :: part

 integer(kd) :: i, os

  open(unit=10, file=filename, status="unknown", iostat=os)

   write(10,'(i15)') n
  do i = 1, n
   write(10,'(i15)') part(i)
  end do

 close(10)

 end subroutine write_part_file



end program regular_hcfamily_coarsening

